---
export const prerender = false;
import Layout from '../layouts/Layout.astro';
import SearchBar from '../components/recipe_list/SearchBar.astro';
import RecipeCard from '../components/recipe_list/RecipeCard.astro';
import RecipeListHeader from '../components/recipe_list/RecipeListHeader.astro';
import EmptyState from '../components/recipe_list/EmptyState.astro';
import { db } from '../lib/database';
import type { Recipe } from '../types/recipe';

type RecipeWithVariants = Recipe & { variants?: Recipe[] };

// Load recipes from database
let allRecipes: Recipe[] = [];
let recipes: RecipeWithVariants[] = [];
try {
  allRecipes = db.getAllRecipes();
  // Only show original recipes in the overview list, but attach their variants for selection mode
  const originals = allRecipes.filter((recipe) => !recipe.parentRecipeId);
  recipes = originals.map((original) => ({
    ...original,
    variants: allRecipes.filter((r) => r.parentRecipeId === original.id)
  }));
} catch (error) {
  console.error('Error loading recipes:', error);
}

// Extract unique categories and remove undefined/null
const categories = Array.from(new Set(
  recipes
    .map(r => r.category)
    .filter((c): c is string => c != null)
));

// Get URL parameters
const searchQuery = Astro.url.searchParams.get('search') || '';
const selectedCategory = Astro.url.searchParams.get('category') || '';
---

<Layout title="Rezepte">
  <div class="container mx-auto px-4 py-8">
    <RecipeListHeader recipeCount={recipes.length} />
    
    <!-- Draft notification box -->
    <div id="draft-notification-box" class="hidden mb-4 bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-800 rounded-lg p-4">
      <div class="flex items-start justify-between">
        <div class="flex-1">
          <h3 class="text-sm font-medium text-yellow-800 dark:text-yellow-200 mb-1">
            Unvollständiger Entwurf vorhanden
          </h3>
          <p class="text-sm text-yellow-700 dark:text-yellow-300" id="draft-notification-text">
            Es gibt einen Entwurf für ein Rezept, der noch nicht gespeichert wurde.
          </p>
        </div>
        <button 
          id="continue-draft-list-btn"
          class="ml-4 px-4 py-2 bg-yellow-500 hover:bg-yellow-600 text-white rounded-md text-sm font-medium transition-colors whitespace-nowrap"
        >
          Entwurf fortsetzen
        </button>
      </div>
    </div>
    
    <SearchBar 
      categories={categories}
      initialSearchQuery={searchQuery}
      initialCategory={selectedCategory}
    />
    
    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6 mt-8">
      {recipes.map(recipe => (
        <RecipeCard recipe={recipe} />
      ))}
    </div>

    {recipes.length === 0 && <EmptyState />}
  </div>
</Layout>

<script>
  // Note: Filter reapplication is handled by SearchBar.astro component
  // This script only handles page-specific functionality

  // Cleanup function to remove any leftover overlays or blocking elements
  function cleanupBlockingElements() {
    // Remove any leftover timer overlays
    document.querySelectorAll('.add-timer-overlay, .expired-timer-overlay, .timer-notification-overlay').forEach(el => {
      if (el instanceof HTMLElement && !el.closest('.modal:not(.hidden)')) {
        el.remove();
      }
    });
    
    // Check for any hidden modals that might be blocking
    document.querySelectorAll('.modal.hidden, [class*="overlay"].hidden').forEach(el => {
      if (el instanceof HTMLElement) {
        const style = window.getComputedStyle(el);
        if (style.pointerEvents !== 'none' && style.zIndex && parseInt(style.zIndex) > 10) {
          el.style.pointerEvents = 'none';
        }
      }
    });
    
    // Reset body overflow in case it's stuck
    if (document.body.style.overflow === 'hidden') {
      // Check if any modal is actually visible
      const visibleModals = document.querySelectorAll('.modal:not(.hidden), [id*="modal"]:not(.hidden)');
      if (visibleModals.length === 0) {
        document.body.style.overflow = '';
      }
    }
    
    // Force pointer-events on body and main container
    document.body.style.pointerEvents = '';
    const container = document.querySelector('.container');
    if (container instanceof HTMLElement) {
      container.style.pointerEvents = '';
    }
  }
  
  // Diagnostic function to check what's blocking clicks
  function diagnoseClickBlocking() {
    const testElement = document.querySelector('.recipe-card');
    if (!testElement) return;
    
    const rect = testElement.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    
    const elementAtPoint = document.elementFromPoint(centerX, centerY);
    if (elementAtPoint) {
      const style = window.getComputedStyle(elementAtPoint);
      if (style.pointerEvents === 'none') {
        console.warn('Click blocking detected: element has pointer-events: none', elementAtPoint);
      }
      if (parseInt(style.zIndex) > 100) {
        console.warn('High z-index element detected:', elementAtPoint, 'z-index:', style.zIndex);
      }
    }
  }

  // Initialize create recipe button when DOM is loaded
  document.addEventListener('DOMContentLoaded', async () => {
    // Cleanup any blocking elements first
    cleanupBlockingElements();
    // Note: Filter reapplication is handled automatically by SearchBar.astro component
    
    // Check for drafts and show notification
    await checkForDrafts();
    
    // Button in RecipeListHeader
    const createBtn = document.getElementById('create-recipe-btn');
    if (createBtn) {
      // The createNewRecipe function is defined in EmptyState.astro
      // We're attaching it to the button in RecipeListHeader
      createBtn.addEventListener('click', async () => {
        try {
          const response = await fetch('/api/recipes?action=create-empty', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            }
          });
          
          if (response.ok) {
            const newRecipe = await response.json();
            // Redirect to the new recipe in edit mode
            window.location.href = `/rezept/${newRecipe.id}?edit=true`;
          } else {
            console.error('Failed to create recipe');
            if (window.showError) {
              window.showError('Fehler beim Erstellen des Rezepts. Bitte versuchen Sie es erneut.');
            } else {
              alert('Fehler beim Erstellen des Rezepts. Bitte versuchen Sie es erneut.');
            }
          }
        } catch (error) {
          console.error('Error creating recipe:', error);
          if (window.showError) {
            window.showError('Fehler beim Erstellen des Rezepts. Bitte versuchen Sie es erneut.');
          } else {
            alert('Fehler beim Erstellen des Rezepts. Bitte versuchen Sie es erneut.');
          }
        }
      });
    }

    // Random recipe button
    const randomRecipeBtn = document.getElementById('random-recipe-btn');
    if (randomRecipeBtn) {
      randomRecipeBtn.addEventListener('click', () => {
        // Get all visible recipe cards (not hidden)
        const visibleCards = Array.from(document.querySelectorAll('.recipe-card:not(.hidden)'));
        
        if (visibleCards.length === 0) {
          if (window.showError) {
            window.showError('Keine Rezepte gefunden. Bitte ändern Sie Ihre Suchkriterien.');
          } else {
            alert('Keine Rezepte gefunden. Bitte ändern Sie Ihre Suchkriterien.');
          }
          return;
        }

        // Pick a random card
        const randomCard = visibleCards[Math.floor(Math.random() * visibleCards.length)] as HTMLElement;
        const recipeId = randomCard.getAttribute('data-recipe-id');
        
        if (recipeId) {
          window.location.href = `/rezept/${recipeId}`;
        }
      });
    }

    // Handle import from shared URL (PWA share target)
    try {
      const params = new URLSearchParams(window.location.search);
      const sharedImportUrl = params.get('importUrl');

      if (sharedImportUrl && window.openImportModal) {
        // Open the import modal
        window.openImportModal();

        // Give the modal a short moment to render, then switch to URL tab and prefill
        setTimeout(() => {
          const importUrlTab = document.getElementById('import-url-tab') as HTMLButtonElement | null;
          const recipeUrlInput = document.getElementById('recipe-url') as HTMLInputElement | null;

          if (importUrlTab) {
            importUrlTab.click();
          }

          if (recipeUrlInput) {
            recipeUrlInput.value = sharedImportUrl;
            // Trigger input event so ImportModal logic updates preview and button state
            recipeUrlInput.dispatchEvent(new Event('input', { bubbles: true }));
          }
        }, 50);
      }
    } catch (e) {
      console.error('Error handling shared import URL:', e);
    }
  });

  // Cleanup on page show (Android back button)
  window.addEventListener('pageshow', (event) => {
    if (event.persisted) {
      // Page restored from cache - cleanup and reinitialize
      cleanupBlockingElements();
      diagnoseClickBlocking();
      
      // Force a small delay to let page settle
      setTimeout(() => {
        cleanupBlockingElements();
        diagnoseClickBlocking();
      }, 100);
    }
  });

  // Also cleanup on popstate (Android back button)
  window.addEventListener('popstate', () => {
    cleanupBlockingElements();
  });
  
  // Check for drafts and show notification
  async function checkForDrafts() {
    try {
      const response = await fetch('/api/drafts');
      if (!response.ok) return;
      
      const drafts = await response.json();
      if (drafts && drafts.length > 0) {
        const draftNotificationBox = document.getElementById('draft-notification-box');
        const draftNotificationText = document.getElementById('draft-notification-text');
        const continueDraftBtn = document.getElementById('continue-draft-list-btn');
        
        if (draftNotificationBox && draftNotificationText) {
          // Show notification with draft info
          if (drafts.length === 1) {
            draftNotificationText.textContent = `Es gibt einen Entwurf für "${drafts[0].title}", der noch nicht gespeichert wurde.`;
          } else {
            draftNotificationText.textContent = `Es gibt ${drafts.length} Entwürfe, die noch nicht gespeichert wurden.`;
          }
          
          draftNotificationBox.classList.remove('hidden');
          
          // Set up continue button
          if (continueDraftBtn) {
            continueDraftBtn.addEventListener('click', () => {
              // Navigate to the first draft (most recent)
              window.location.href = `/rezept/${drafts[0].recipeId}?edit=true`;
            });
          }
        }
      }
    } catch (error) {
      console.error('Error checking for drafts:', error);
    }
  }
</script> 