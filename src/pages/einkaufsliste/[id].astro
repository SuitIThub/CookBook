---
export const prerender = false;
import Layout from '../../layouts/Layout.astro';
import { db } from '../../lib/database';
import type { ShoppingList } from '../../types/recipe';
import GroupingSuggestionModal from '../../components/shopping_list/GroupingSuggestionModal.astro';

const { id } = Astro.params;

if (!id) {
  return Astro.redirect('/einkaufslisten');
}

// Einkaufsliste laden
let shoppingList: ShoppingList | null = null;
try {
  shoppingList = db.getShoppingList(id);
} catch (error) {
  console.error('Error loading shopping list:', error);
}

if (!shoppingList) {
  return Astro.redirect('/einkaufslisten');
}

// Query-Parameter f√ºr Edit-Modus √ºberpr√ºfen
const url = new URL(Astro.request.url);
const isEditMode = url.searchParams.get('edit') === 'true';

const checkedItems = shoppingList.items.filter(item => item.isChecked);
const uncheckedItems = shoppingList.items.filter(item => !item.isChecked);
---

<Layout title={`${shoppingList.title} - Einkaufsliste`}>
  <div class="container-narrow">
    <!-- Header -->
    <div class="mb-6">
      <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4 sm:gap-0 mb-4">
        <div class="flex items-center space-x-3">
          <a href="/einkaufslisten" class="btn btn-ghost btn-sm flex items-center space-x-2">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
            </svg>
            <span>Zur√ºck</span>
          </a>
          <!-- Sync status will be inserted here by JavaScript -->
          <div id="sync-status-container"></div>
        </div>
        <div class="flex flex-col sm:flex-row gap-2 sm:space-x-2 w-full sm:w-auto">
          <button id="add-item-btn" class="btn btn-success flex items-center justify-center space-x-2">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"/>
            </svg>
            <span class="hidden xs:inline">Artikel hinzuf√ºgen</span>
            <span class="xs:hidden">Artikel hinzuf√ºgen</span>
          </button>
          <button id="add-recipe-btn" class="btn btn-blue flex items-center justify-center space-x-2">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.746 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"/>
            </svg>
            <span class="hidden xs:inline">Rezept hinzuf√ºgen</span>
            <span class="xs:hidden">Rezept hinzuf√ºgen</span>
          </button>
          <button id="share-list-btn" class="btn btn-secondary flex items-center justify-center space-x-2">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.367 2.684 3 3 0 00-5.367-2.684z"/>
            </svg>
            <span class="hidden xs:inline">Teilen</span>
            <span class="xs:hidden">Teilen</span>
          </button>
          <a href={`/einkaufsliste/${id}/edit`} class="btn btn-secondary flex items-center justify-center space-x-2">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"/>
            </svg>
            <span class="hidden xs:inline">Bearbeiten</span>
            <span class="xs:hidden">Bearbeiten</span>
          </a>
        </div>
      </div>
      <div>
        <h1 class="heading-primary">{shoppingList.title}</h1>
        {shoppingList.description && (
          <p class="text-muted mt-1">
            {shoppingList.description}
          </p>
        )}
        <p class="text-sm text-muted mt-1">
          {uncheckedItems.length} von {shoppingList.items.length} Artikeln offen
        </p>
      </div>
    </div>

    <!-- Shopping List Recipes -->
    <div id="shopping-recipes-section" class="card" style="display: none;">
      <div class="card-content">
        <h2 class="heading-secondary mb-4">Rezepte</h2>
        <div id="shopping-recipes" class="space-y-3">
          <!-- Recipes will be populated by JavaScript -->
        </div>
      </div>
    </div>

    <!-- Recipe Template -->
    <template id="recipe-template">
      <div class="recipe-item border border-gray-300 dark:border-gray-600 rounded-lg p-4 cursor-pointer hover:shadow-sm transition-all" data-recipe-id="">
        <div class="flex flex-col gap-3">
          <div class="flex items-center justify-between">
            <h3 class="font-medium text-gray-900 dark:text-white recipe-title"></h3>
            <div class="flex items-center space-x-2 ml-4 flex-shrink-0">
              <a href="" class="recipe-link btn btn-sm btn-ghost recipe-action" title="Rezept anzeigen">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/>
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"/>
                </svg>
              </a>
              <button class="remove-recipe btn btn-sm btn-ghost text-gray-400 hover:text-red-500 recipe-action" title="Rezept entfernen">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                </svg>
              </button>
            </div>
          </div>
          <div class="flex-1 min-w-0">
              <p class="text-sm text-muted recipe-info"></p>
              <div class="flex flex-col sm:flex-row sm:items-center gap-2 sm:gap-4 mt-2">
                <div class="flex items-center space-x-2">
                  <label class="text-sm text-gray-600 dark:text-gray-400">Portionen:</label>
                  <div class="flex items-center space-x-1">
                    <button class="portion-decrease btn btn-icon btn-sm recipe-action" title="Portionen verringern">
                      <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 12H4"/>
                      </svg>
                    </button>
                    <input type="number" class="portion-input form-input form-input-sm w-16 text-center recipe-action" min="1" value="1" />
                    <button class="portion-increase btn btn-icon btn-sm recipe-action" title="Portionen erh√∂hen">
                      <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"/>
                      </svg>
                    </button>
                  </div>
                </div>
                <span class="text-sm text-gray-500">Originalportionen: <span class="original-servings"></span></span>
              </div>
              <p class="text-xs text-blue-600 dark:text-blue-400 mt-1 opacity-75">Klicken zum Hervorheben</p>
            </div>
          </div>
        </div>
      </div>
    </template>

    <!-- Hide Checked Items Toggle and Grouping Controls -->
    <div class="card mt-6">
      <div class="card-content">
        <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
          <label class="flex items-center space-x-3 cursor-pointer">
            <input 
              type="checkbox" 
              id="hide-checked-items-toggle"
              class="w-5 h-5 text-primary-500 bg-gray-100 border-gray-300 rounded focus:ring-primary-500 focus:ring-2"
            />
            <span class="text-sm font-medium text-gray-700 dark:text-gray-300">
              Erledigte Artikel ausblenden
            </span>
          </label>
          <div class="flex items-center gap-2">
            <button id="suggest-grouping-btn" class="btn btn-secondary btn-sm flex items-center space-x-2">
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"/>
              </svg>
              <span>Gruppierung vorschlagen</span>
            </button>
            <button id="group-items-btn" class="btn btn-secondary btn-sm flex items-center space-x-2">
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z"/>
              </svg>
              <span>Gruppieren</span>
            </button>
            <button id="ungroup-items-btn" class="btn btn-secondary btn-sm flex items-center space-x-2" style="display: none;">
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7h12m0 0l-4-4m4 4l-4 4m0 6H4m0 0l4 4m-4-4l4-4"/>
              </svg>
              <span>Gruppierung aufheben</span>
            </button>
            <div id="group-selection-controls" class="hidden flex items-center gap-2">
              <button id="confirm-group-btn" class="btn btn-success btn-sm" disabled>
                Gruppierung best√§tigen
              </button>
              <button id="cancel-group-btn" class="btn btn-secondary btn-sm">
                Abbrechen
              </button>
              <span id="selected-count" class="text-sm text-gray-600 dark:text-gray-400">0 ausgew√§hlt</span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Shopping List Items -->
    <div class="card mt-6">
      <div class="card-content">
        <h2 id="items-heading" class="heading-secondary mb-4">
          Einkaufsliste ({shoppingList.items.length} Artikel)
        </h2>
        
        <!-- Search Field -->
        <div class="mb-4">
          <input
            type="text"
            id="shopping-items-search"
            class="w-full px-4 py-2 rounded-lg border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 focus:ring-2 focus:ring-orange-500 dark:focus:ring-orange-400 focus:border-transparent"
            placeholder="Zutaten durchsuchen..."
          />
        </div>
        
        <div class="space-y-2" id="shopping-items">
          <!-- Items will be populated by JavaScript -->
        </div>
      </div>
    </div>
  </div>

  <!-- Add Item Modal -->
  <div id="add-item-modal" class="modal hidden">
    <div class="modal-overlay"></div>
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title">Artikel hinzuf√ºgen</h2>
        <button class="modal-close">&times;</button>
      </div>
      
      <form id="add-item-form" class="modal-body space-y-4">
        <div>
          <label for="item-name" class="form-label">Name</label>
          <input 
            type="text" 
            id="item-name" 
            name="name"
            class="form-input" 
            placeholder="z.B. Milch, Brot, √Ñpfel..."
            required
          />
        </div>
        
        <div class="grid grid-cols-2 gap-4">
          <div>
            <label for="item-amount" class="form-label">Menge (optional)</label>
            <input 
              type="number" 
              id="item-amount" 
              name="amount"
              class="form-input" 
              placeholder="1"
              step="0.1"
              min="0"
            />
          </div>
          <div>
            <label for="item-unit" class="form-label">Einheit (optional)</label>
            <select 
              id="item-unit" 
              name="unit"
              class="form-input" 
            >
              <option value="">Einheit w√§hlen...</option>
            </select>
          </div>
        </div>
        
        <div>
          <label for="item-description" class="form-label">Beschreibung (optional)</label>
          <input 
            type="text" 
            id="item-description" 
            name="description"
            class="form-input" 
            placeholder="z.B. Bio, 1,5% Fett..."
          />
        </div>
      </form>
      
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary modal-close" style="min-width: 100px;">Abbrechen</button>
        <button type="submit" form="add-item-form" class="btn btn-success" style="min-width: 100px;">
          Hinzuf√ºgen
        </button>
      </div>
    </div>
  </div>

  <!-- Add Recipe Modal -->
  <div id="add-recipe-modal" class="modal hidden">
    <div class="modal-overlay"></div>
    <div class="modal-content modal-lg">
      <div class="modal-header">
        <h2 class="modal-title">Rezept hinzuf√ºgen</h2>
        <button class="modal-close">&times;</button>
      </div>
      
      <div class="modal-body">
        <div id="recipe-loading" class="text-center py-8">
          <div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-orange-500"></div>
          <p class="text-muted mt-2">Rezepte werden geladen...</p>
        </div>
        
        <div id="recipe-list" class="hidden">
          <div class="mb-4">
            <input 
              type="text" 
              id="recipe-search" 
              class="form-input" 
              placeholder="Rezepte durchsuchen..."
            />
          </div>
          
          <div class="mb-4 flex items-center justify-between">
            <div class="flex items-center space-x-4">
              <label class="flex items-center space-x-2">
                <input type="checkbox" id="select-all-recipes" class="form-checkbox" />
                <span class="text-sm font-medium">Alle ausw√§hlen</span>
              </label>
              <span id="selected-count" class="text-sm text-muted">0 Rezepte ausgew√§hlt</span>
            </div>
            <button id="add-selected-recipes" class="btn btn-success btn-sm" disabled>
              Ausgew√§hlte hinzuf√ºgen
            </button>
          </div>
          
          <div id="available-recipes" class="space-y-3 max-h-80 overflow-y-auto">
            <!-- Recipes will be populated by JavaScript -->
          </div>
          
          <div id="no-recipes-found" class="hidden text-center py-8">
            <svg class="w-12 h-12 mx-auto text-gray-400 mb-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M9.172 16.172a4 4 0 015.656 0M9 12h6m-6-4h6m2 5.291A7.962 7.962 0 0112 15c-2.34 0-4.467-.881-6.072-2.327a8.002 8.002 0 01-.344-10.854"/>
            </svg>
            <p class="text-muted">Keine Rezepte gefunden</p>
          </div>
        </div>
      </div>
      
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary modal-close">Schlie√üen</button>
      </div>
    </div>
  </div>

  <!-- Grouping Suggestion Modal -->
  <GroupingSuggestionModal />

  <script type="module" define:vars={{ shoppingListId: id, shoppingListData: shoppingList }}>
    // Variables are already defined via define:vars
    let availableUnits = [];
    let unitConversionData = null; // Store unit conversion data for formatting
    
    // Recipe management variables
    let availableRecipes = [];
    let currentlyHighlightedRecipe = null;
    
    // Toggle state for hiding checked items (default: false = show all items)
    let hideCheckedItems = false;
    
    // Search filter state
    let searchFilter = '';
    
    // Grouping state
    let isGroupingMode = false;
    let selectedGroupIds = new Set();

    // Format quantity for display using unit conversion data
    function formatQuantityForDisplay(amount, unit) {
      if (!unit || unit.trim() === '' || !unitConversionData) {
        return { amount: Math.round(amount * 10) / 10, unit: unit || '' };
      }
      
      const normalizedUnit = unit.trim();
      
      // Find display units for this base unit
      const displayUnits = unitConversionData[normalizedUnit];
      if (!displayUnits || displayUnits.length === 0) {
        // No display units available, return as-is
        return { amount: Math.round(amount * 10) / 10, unit: normalizedUnit };
      }
      
      // Sort by factor (largest first)
      const sortedDisplayUnits = [...displayUnits].sort((a, b) => b.factor - a.factor);
      
      // Find the largest unit that fits (amount >= 1 of that unit and < 1000)
      for (const displayUnit of sortedDisplayUnits) {
        // Skip conversion if factor is 1 - no benefit in converting to equivalent unit
        // This prevents base units like "St√ºck" from being converted to other units with factor 1
        if (displayUnit.factor === 1) {
          continue;
        }
        
        const convertedAmount = amount / displayUnit.factor;
        // Use this unit if the converted amount is >= 1 and is a "nice" number (< 1000)
        if (convertedAmount >= 1 && convertedAmount < 1000) {
          // Round to 1 decimal place if needed
          const rounded = Math.round(convertedAmount * 10) / 10;
          return {
            amount: rounded,
            unit: displayUnit.name
          };
        }
      }
      
      // No suitable display unit found, use base unit
      return {
        amount: Math.round(amount * 10) / 10,
        unit: normalizedUnit
      };
    }

    // Load available units and conversion data from API
    async function loadUnits() {
      try {
        const response = await fetch('/api/units');
        if (response.ok) {
          const data = await response.json();
          // API returns { units: [...], conversions: {...} }
          availableUnits = data.units || data; // Support both old and new format
          unitConversionData = data.conversions || null;
          populateUnitDropdown();
        }
      } catch (error) {
        console.error('Error loading units:', error);
      }
    }

    // Populate unit dropdown in add item modal
    function populateUnitDropdown() {
      const unitSelect = document.getElementById('item-unit');
      if (!unitSelect) return;

      // Clear existing options except the first one
      while (unitSelect.children.length > 1) {
        unitSelect.removeChild(unitSelect.lastChild);
      }

      // Add all available units
      availableUnits.forEach(unit => {
        const option = document.createElement('option');
        option.value = unit.name;
        option.textContent = unit.name;
        unitSelect.appendChild(option);
      });
    }

    document.addEventListener('DOMContentLoaded', async () => {
      await loadUnits();
      
      // Search functionality
      const searchInput = document.getElementById('shopping-items-search');
      if (searchInput) {
        searchInput.addEventListener('input', (e) => {
          searchFilter = e.target.value;
          renderShoppingItems();
        });
      }
      
      // Hide checked items toggle functionality
      const hideCheckedToggle = document.getElementById('hide-checked-items-toggle');
      if (hideCheckedToggle) {
        hideCheckedToggle.addEventListener('change', () => {
          hideCheckedItems = hideCheckedToggle.checked;
          renderShoppingItems();
        });
      }
      
      // Grouping functionality
      const groupBtn = document.getElementById('group-items-btn');
      const ungroupBtn = document.getElementById('ungroup-items-btn');
      const confirmGroupBtn = document.getElementById('confirm-group-btn');
      const cancelGroupBtn = document.getElementById('cancel-group-btn');
      
      if (groupBtn) {
        groupBtn.addEventListener('click', () => {
          toggleGroupingMode(true);
        });
      }
      
      if (ungroupBtn) {
        ungroupBtn.addEventListener('click', () => {
          ungroupAll();
        });
      }
      
      if (confirmGroupBtn) {
        confirmGroupBtn.addEventListener('click', () => {
          confirmGrouping();
        });
      }
      
      if (cancelGroupBtn) {
        cancelGroupBtn.addEventListener('click', () => {
          toggleGroupingMode(false);
        });
      }
      
      // Initialize ungroup button visibility
      if (ungroupBtn) {
        ungroupBtn.style.display = hasManualGroups() ? 'flex' : 'none';
      }
      
      // Grouping suggestion functionality
      const suggestGroupingBtn = document.getElementById('suggest-grouping-btn');
      const suggestionModal = document.getElementById('grouping-suggestion-modal');
      let suggestedGroupsData = []; // Store suggested groups data
      
      if (suggestGroupingBtn && suggestionModal) {
        suggestGroupingBtn.addEventListener('click', () => {
          openGroupingSuggestionModal();
        });
        
        // Close modal handlers
        const closeButtons = suggestionModal.querySelectorAll('.modal-close, .modal-overlay');
        closeButtons.forEach(btn => {
          btn.addEventListener('click', () => {
            closeGroupingSuggestionModal();
          });
        });
        
        // Cancel button
        const cancelBtn = document.getElementById('cancel-suggestion-btn');
        if (cancelBtn) {
          cancelBtn.addEventListener('click', () => {
            closeGroupingSuggestionModal();
          });
        }
        
        // Accept all button
        const acceptAllBtn = document.getElementById('accept-all-btn');
        if (acceptAllBtn) {
          acceptAllBtn.addEventListener('click', () => {
            acceptAllSuggestedGroups();
          });
        }
      }
      
      // Function to open grouping suggestion modal
      function openGroupingSuggestionModal() {
        if (!suggestionModal || !window.GroupingSuggestionModal) return;
        
        const loadingEl = document.getElementById('suggestion-loading');
        const contentEl = document.getElementById('suggestion-content');
        const groupsContainer = document.getElementById('suggested-groups');
        const acceptAllBtn = document.getElementById('accept-all-btn');
        
        // Show loading
        loadingEl?.classList.remove('hidden');
        contentEl?.classList.add('hidden');
        suggestionModal.classList.remove('hidden');
        
        // Calculate suggestions
        setTimeout(() => {
          suggestedGroupsData = window.GroupingSuggestionModal.suggestGroups(shoppingListData.items);
          
          // Hide loading, show content
          loadingEl?.classList.add('hidden');
          contentEl?.classList.remove('hidden');
          
          // Render suggestions
          if (groupsContainer && suggestedGroupsData.length > 0) {
            window.GroupingSuggestionModal.renderSuggestedGroups(suggestedGroupsData, groupsContainer);
            if (acceptAllBtn) {
              acceptAllBtn.disabled = false;
            }
          } else {
            groupsContainer.innerHTML = '';
            if (acceptAllBtn) {
              acceptAllBtn.disabled = true;
            }
          }
        }, 100); // Small delay to show loading state
      }
      
      // Function to close grouping suggestion modal
      function closeGroupingSuggestionModal() {
        if (suggestionModal) {
          suggestionModal.classList.add('hidden');
          suggestedGroupsData = [];
        }
      }
      
      // Function to accept all suggested groups
      async function acceptAllSuggestedGroups() {
        // Get groups data from the container (in case suggestedGroupsData was cleared)
        const groupsContainer = document.getElementById('suggested-groups');
        const groupsData = groupsContainer && window.GroupingSuggestionModal?.getGroupsData 
          ? window.GroupingSuggestionModal.getGroupsData(groupsContainer)
          : suggestedGroupsData;
        
        if (!groupsData || groupsData.length === 0) return;
        
        // Get all checked groups
        const checkedGroupIds = new Set();
        document.querySelectorAll('.group-accept-checkbox:checked').forEach(checkbox => {
          checkedGroupIds.add(checkbox.getAttribute('data-group-id'));
        });
        
        if (checkedGroupIds.size === 0) {
          alert('Bitte w√§hlen Sie mindestens eine Gruppierung aus.');
          return;
        }
        
        // Apply all accepted groups
        const updatedItems = [...shoppingListData.items];
        const groupsToApply = groupsData.filter(group => checkedGroupIds.has(group.id));
        
        groupsToApply.forEach((group, index) => {
          // Generate unique group ID with timestamp and index to avoid collisions
          const newGroupId = `manual_${Date.now()}_${index}_${Math.random().toString(36).substr(2, 9)}`;
          
          // Update all items in this group
          group.items.forEach(groupItem => {
            const itemIndex = updatedItems.findIndex(item => item.id === groupItem.id);
            if (itemIndex !== -1) {
              updatedItems[itemIndex] = {
                ...updatedItems[itemIndex],
                manualGroupId: newGroupId
              };
            }
          });
        });
        
        try {
          const response = await fetch(`/api/shopping-lists?id=${shoppingListId}`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              items: updatedItems
            }),
          });
          
          if (response.ok) {
            const updatedList = await response.json();
            shoppingListData.items = updatedList.items;
            
            // Close modal and re-render
            closeGroupingSuggestionModal();
            renderShoppingItems();
            updateHeaderCounters();
            
            // Update ungroup button visibility
            const ungroupBtn = document.getElementById('ungroup-items-btn');
            if (ungroupBtn) {
              ungroupBtn.style.display = hasManualGroups() ? 'flex' : 'none';
            }
            
            const appliedCount = groupsToApply.length;
            alert(`${appliedCount} Gruppierung${appliedCount !== 1 ? 'en' : ''} wurde${appliedCount !== 1 ? 'n' : ''} angewendet!`);
          } else {
            const error = await response.json();
            alert(error.error || 'Fehler beim Anwenden der Gruppierungen');
          }
        } catch (error) {
          console.error('Error applying groups:', error);
          alert('Fehler beim Anwenden der Gruppierungen');
        }
      }
      
      // Share button functionality
      const shareButton = document.getElementById('share-list-btn');
      shareButton?.addEventListener('click', async () => {
        try {
          const shareData = {
            title: shoppingListData.title,
            text: `Einkaufsliste: ${shoppingListData.title}`,
            url: window.location.href
          };

          if (navigator.share && navigator.canShare(shareData)) {
            await navigator.share(shareData);
          } else {
            // Fallback: Copy link to clipboard
            await navigator.clipboard.writeText(window.location.href);
            
            // Show feedback
            const originalText = shareButton.innerHTML;
            shareButton.innerHTML = `
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
              </svg>
              <span>Link kopiert!</span>
            `;
            
            setTimeout(() => {
              shareButton.innerHTML = originalText;
            }, 2000);
          }
        } catch (error) {
          console.error('Error sharing:', error);
        }
      });
      
      // Function to group items by name (ignoring unit differences) and manual groups
      function groupItems(items) {
        const groups = new Map();
        
        // First, group by manualGroupId if present
        const manualGroups = new Map();
        const ungroupedItems = [];
        
        items.forEach(item => {
          if (item.manualGroupId) {
            if (!manualGroups.has(item.manualGroupId)) {
              manualGroups.set(item.manualGroupId, []);
            }
            manualGroups.get(item.manualGroupId).push(item);
          } else {
            ungroupedItems.push(item);
          }
        });
        
        // Process manual groups - combine all items in a manual group
        manualGroups.forEach((groupItems, groupId) => {
          const group = {
            name: groupItems.map(i => i.name).join(', '), // Combined name
            items: groupItems,
            allChecked: groupItems.every(i => i.isChecked),
            anyChecked: groupItems.some(i => i.isChecked),
            descriptions: [...new Set(groupItems.map(i => i.description).filter(Boolean))],
            quantitiesByUnit: new Map(),
            unitCasing: new Map(),
            manualGroupId: groupId,
            isManualGroup: true
          };
          
          // Sum quantities by unit across all items in the manual group
          groupItems.forEach(item => {
            if (item.quantity && item.quantity.unit) {
              const unitKey = item.quantity.unit.toLowerCase();
              if (group.quantitiesByUnit.has(unitKey)) {
                group.quantitiesByUnit.set(
                  unitKey,
                  group.quantitiesByUnit.get(unitKey) + item.quantity.amount
                );
              } else {
                group.quantitiesByUnit.set(unitKey, item.quantity.amount);
                group.unitCasing.set(unitKey, item.quantity.unit);
              }
            }
          });
          
          groups.set(`manual_${groupId}`, group);
        });
        
        // Process ungrouped items - group by name only (case-insensitive)
        ungroupedItems.forEach(item => {
          const key = item.name.toLowerCase();
          
          if (groups.has(key)) {
            const existingGroup = groups.get(key);
            existingGroup.items.push(item);
            existingGroup.allChecked = existingGroup.allChecked && item.isChecked;
            existingGroup.anyChecked = existingGroup.anyChecked || item.isChecked;
            
            // Combine descriptions (if different)
            if (item.description && !existingGroup.descriptions.includes(item.description)) {
              existingGroup.descriptions.push(item.description);
            }
            
            // Sum amounts by unit (only if item has quantity)
            if (item.quantity && item.quantity.unit) {
              const unitKey = item.quantity.unit.toLowerCase();
              if (existingGroup.quantitiesByUnit.has(unitKey)) {
                existingGroup.quantitiesByUnit.set(
                  unitKey,
                  existingGroup.quantitiesByUnit.get(unitKey) + item.quantity.amount
                );
              } else {
                existingGroup.quantitiesByUnit.set(unitKey, item.quantity.amount);
                // Store the original unit casing for display
                existingGroup.unitCasing.set(unitKey, item.quantity.unit);
              }
            }
          } else {
            // Create new group
            const quantitiesByUnit = new Map();
            const unitCasing = new Map();
            if (item.quantity && item.quantity.unit) {
              const unitKey = item.quantity.unit.toLowerCase();
              quantitiesByUnit.set(unitKey, item.quantity.amount);
              unitCasing.set(unitKey, item.quantity.unit);
            }
            
            groups.set(key, {
              name: item.name,
              items: [item],
              allChecked: item.isChecked,
              anyChecked: item.isChecked,
              descriptions: item.description ? [item.description] : [],
              quantitiesByUnit: quantitiesByUnit,
              unitCasing: unitCasing,
              isManualGroup: false
            });
          }
        });
        
        return Array.from(groups.values());
      }
      
      // Function to render shopping items
      function renderShoppingItems() {
        const container = document.getElementById('shopping-items');
        if (!container) return;
        
        let itemsToRender = shoppingListData.items;
        
        // Filter out checked items if toggle is enabled
        if (hideCheckedItems) {
          itemsToRender = itemsToRender.filter(item => !item.isChecked);
        }
        
        const groupedItems = groupItems(itemsToRender);
        
        // Filter groups based on search term
        let filteredGroups = groupedItems;
        if (searchFilter.trim() !== '') {
          const searchTerm = searchFilter.toLowerCase().trim();
          filteredGroups = groupedItems.filter(group => {
            // Check if group name matches
            if (group.name.toLowerCase().includes(searchTerm)) {
              return true;
            }
            
            // Check if any description matches
            if (group.descriptions.some(desc => desc.toLowerCase().includes(searchTerm))) {
              return true;
            }
            
            // Check if any unit name matches
            const unitNames = Array.from(group.unitCasing.values());
            if (unitNames.some(unit => unit.toLowerCase().includes(searchTerm))) {
              return true;
            }
            
            // Check if any individual item name matches (for manual groups)
            if (group.items.some(item => item.name.toLowerCase().includes(searchTerm))) {
              return true;
            }
            
            return false;
          });
        }
        
        if (filteredGroups.length === 0) {
          const emptyMessage = searchFilter.trim() !== '' 
            ? `<p class="text-muted mb-2">Keine Artikel gefunden f√ºr "${searchFilter}"</p>`
            : `<p class="text-muted mb-2">Noch keine Artikel in der Einkaufsliste</p>
               <p class="text-sm text-muted">Klicken Sie auf "Artikel hinzuf√ºgen" um zu beginnen</p>`;
          
          container.innerHTML = `
            <div class="text-center py-8 border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-lg">
              <svg class="w-12 h-12 mx-auto text-gray-400 mb-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M9 5H7a2 2 0 00-2 2v11a2 2 0 002 2h5.586a1 1 0 00.707-.293l5.414-5.414a1 1 0 00.293-.707V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"/>
              </svg>
              ${emptyMessage}
            </div>
          `;
          return;
        }
        
        container.innerHTML = filteredGroups.map((group, index) => {
          const isChecked = group.allChecked;
          const isPartiallyChecked = group.anyChecked && !group.allChecked;
          const itemIds = group.items.map(item => item.id).join(',');
          const recipeIds = [...new Set(group.items.map(item => item.recipeId).filter(Boolean))].join(',');
          const hasMultipleItems = group.items.length > 1;
          const isEvenRow = index % 2 === 0;
          const rowBgClass = isEvenRow ? 'bg-white dark:bg-gray-900' : 'bg-gray-50 dark:bg-gray-800/50';
          
          // Format quantities by unit and filter out zero amounts
          const quantitiesByUnit = Array.from(group.quantitiesByUnit.entries())
            .map(([unitKey, amount]) => {
              const unit = group.unitCasing.get(unitKey);
              // Format for display (convert to larger units if appropriate)
              const formatted = formatQuantityForDisplay(amount, unit);
              const formattedAmount = formatted.amount % 1 === 0 ? 
                formatted.amount.toString() : 
                formatted.amount.toFixed(1).replace(/\.0$/, '');
              return { amount: formattedAmount, unit: formatted.unit, unitKey, numericAmount: amount };
            })
            .filter(({ numericAmount }) => numericAmount !== 0); // Filter out zero amounts
          
          const hasMultipleUnits = quantitiesByUnit.length > 1;
          
          // First unit display (only shown if amount > 0)
          const firstUnitDisplay = quantitiesByUnit.length > 0 ? `
            <span class="${isChecked 
              ? 'text-sm text-green-700 dark:text-green-300 bg-green-100 dark:bg-green-800 px-3 py-1.5 rounded border border-green-200 dark:border-green-700 flex-shrink-0'
              : 'text-sm bg-gray-100 dark:bg-gray-700 text-gray-900 dark:text-white px-3 py-1.5 rounded border border-gray-200 dark:border-gray-600 flex-shrink-0'
            }">
              ${quantitiesByUnit[0].amount} ${quantitiesByUnit[0].unit}
            </span>
          ` : '';
          
          // Additional units display (boxes below, aligned with first unit)
          const additionalUnitsDisplay = hasMultipleUnits ? `
            <div class="flex flex-col gap-1.5 mt-1.5 items-end">
              ${quantitiesByUnit.slice(1).map(({ amount, unit }) => `
                <span class="${isChecked 
                  ? 'text-sm text-green-700 dark:text-green-300 bg-green-100 dark:bg-green-800 px-3 py-1.5 rounded border border-green-200 dark:border-green-700'
                  : 'text-sm bg-gray-100 dark:bg-gray-700 text-gray-900 dark:text-white px-3 py-1.5 rounded border border-gray-200 dark:border-gray-600'
                }">
                  ${amount} ${unit}
                </span>
              `).join('')}
            </div>
          ` : '';
          
          // Create details for individual items if there are multiple
          const itemDetails = hasMultipleItems ? group.items.map((item, index) => {
            const sourceLabel = item.recipeId ? 'üç≥ Rezept' : '‚úã Manuell';
            const sourceClass = item.recipeId ? 'text-blue-600 dark:text-blue-400' : 'text-gray-600 dark:text-gray-400';
            
            let quantityDisplay = '';
            if (item.quantity && item.quantity.amount !== 0) {
              // Format for display (convert to larger units if appropriate)
              const formatted = formatQuantityForDisplay(item.quantity.amount, item.quantity.unit);
              const itemAmount = formatted.amount % 1 === 0 ? 
                formatted.amount.toString() : 
                formatted.amount.toFixed(1).replace(/\.0$/, '');
              quantityDisplay = `<span class="text-gray-700 dark:text-gray-300 font-mono">${itemAmount} ${formatted.unit}</span>`;
            }
            
            return `
              <div class="detail-item flex justify-between items-center py-1 px-2 text-sm transition-colors" data-item-id="${item.id}">
                <div class="flex items-center space-x-2">
                  <span class="${sourceClass} text-xs font-medium">${sourceLabel}</span>
                  ${item.description ? `<span class="text-gray-500">‚Ä¢ ${item.description}</span>` : ''}
                </div>
                ${quantityDisplay}
              </div>
            `;
          }).join('') : '';
          
          const groupId = group.manualGroupId || `group_${itemIds}`;
          const isSelected = selectedGroupIds.has(groupId);
          
          return `
            <div class="shopping-item-group ${rowBgClass} ${isSelected ? 'ring-2 ring-blue-500' : ''} border-b border-gray-200 dark:border-gray-700 last:border-b-0" data-item-ids="${itemIds}" data-recipe-ids="${recipeIds}" data-group-id="${groupId}">
              <div class="shopping-item p-3 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg transition-colors ${hasMultipleItems ? 'cursor-pointer' : ''}" ${hasMultipleItems ? 'data-expandable="true"' : ''}>
                <!-- Main Row: Selection Checkbox (in grouping mode), Item Checkbox, Title, Description, Actions, and First Unit -->
                <div class="flex items-center gap-2 sm:gap-3 flex-wrap">
                  ${isGroupingMode ? `
                    <input 
                      type="checkbox" 
                      class="group-selection-checkbox w-5 h-5 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500 focus:ring-2 flex-shrink-0"
                      data-group-id="${groupId}"
                      ${isSelected ? 'checked' : ''}
                    />
                  ` : ''}
                  <input 
                    type="checkbox" 
                    class="item-checkbox w-5 h-5 text-green-600 bg-gray-100 border-gray-300 rounded focus:ring-green-500 focus:ring-2 ${isPartiallyChecked ? 'opacity-50' : ''} ${isGroupingMode ? 'opacity-50 cursor-not-allowed' : ''} flex-shrink-0"
                    ${isChecked ? 'checked' : ''}
                    ${isGroupingMode ? 'disabled' : ''}
                    title="${isPartiallyChecked ? 'Teilweise erledigt' : isGroupingMode ? 'Gruppierungsmodus aktiv' : ''}"
                  />
                  <span class="font-medium transition-colors flex-shrink-0 ${
                    isChecked 
                      ? 'text-green-800 dark:text-green-300 line-through' 
                      : 'text-gray-900 dark:text-white'
                  }">
                    ${group.name}
                    ${hasMultipleItems ? `<span class="text-xs text-gray-500 ml-1">(${group.items.length}x)</span>` : ''}
                    ${group.isManualGroup ? `<span class="text-xs text-blue-600 dark:text-blue-400 ml-1">(Manuell gruppiert)</span>` : ''}
                  </span>
                  ${group.descriptions.length > 0 ? `
                    <p class="text-sm transition-colors flex-shrink-0 ${
                      isChecked 
                        ? 'text-green-700 dark:text-green-300 line-through' 
                        : 'text-muted'
                    }">
                      ${group.descriptions.join(', ')}
                    </p>
                  ` : ''}
                  <div class="flex items-center gap-2 flex-shrink-0 ml-auto">
                    ${recipeIds ? `
                      <button class="recipe-highlight-btn w-5 h-5 text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200 transition-colors flex-shrink-0" 
                              data-recipe-ids="${recipeIds}" 
                              title="Rezept hervorheben">
                        <svg class="w-full h-full" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.746 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"/>
                        </svg>
                      </button>
                    ` : ''}
                    ${hasMultipleItems ? `
                      <svg class="expand-icon w-4 h-4 text-gray-400 transition-transform duration-200 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/>
                      </svg>
                    ` : ''}
                    ${firstUnitDisplay}
                  </div>
                </div>
                ${additionalUnitsDisplay}
              </div>
              ${hasMultipleItems ? `
                <div class="item-details hidden mt-2 ml-8 mr-4 bg-gray-50 dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700">
                  <div class="p-3">
                    <div class="text-xs font-medium text-gray-500 dark:text-gray-400 mb-2 uppercase tracking-wide">Einzelne Mengen:</div>
                    ${itemDetails}
                  </div>
                </div>
              ` : ''}
            </div>
          `;
        }).join('');
        
        // Re-attach event listeners
        attachCheckboxListeners();
        attachExpandListeners();
        attachRecipeHighlightListeners();
        attachGroupSelectionListeners();
        
        // Restore highlights if any recipe was selected
        if (currentlyHighlightedRecipe) {
          highlightRecipeIngredients(currentlyHighlightedRecipe);
        }
      }
      
      // Function to attach group selection listeners
      function attachGroupSelectionListeners() {
        document.querySelectorAll('.group-selection-checkbox').forEach(checkbox => {
          checkbox.addEventListener('change', (e) => {
            const groupId = e.target.getAttribute('data-group-id');
            const groupElement = e.target.closest('.shopping-item-group');
            
            if (e.target.checked) {
              selectedGroupIds.add(groupId);
              if (groupElement) {
                groupElement.classList.add('ring-2', 'ring-blue-500');
              }
            } else {
              selectedGroupIds.delete(groupId);
              if (groupElement) {
                groupElement.classList.remove('ring-2', 'ring-blue-500');
              }
            }
            
            updateGroupSelectionUI();
          });
        });
      }
      
      // Function to update group selection UI
      function updateGroupSelectionUI() {
        const selectedCount = selectedGroupIds.size;
        const selectedCountElement = document.getElementById('selected-count');
        const confirmBtn = document.getElementById('confirm-group-btn');
        
        if (selectedCountElement) {
          selectedCountElement.textContent = `${selectedCount} ausgew√§hlt`;
        }
        
        if (confirmBtn) {
          confirmBtn.disabled = selectedCount < 2;
        }
      }
      
      // Function to toggle grouping mode
      function toggleGroupingMode(enable) {
        isGroupingMode = enable;
        selectedGroupIds.clear();
        
        const groupBtn = document.getElementById('group-items-btn');
        const ungroupBtn = document.getElementById('ungroup-items-btn');
        const selectionControls = document.getElementById('group-selection-controls');
        
        if (groupBtn) {
          groupBtn.style.display = enable ? 'none' : 'flex';
        }
        if (ungroupBtn) {
          ungroupBtn.style.display = enable ? 'none' : (hasManualGroups() ? 'flex' : 'none');
        }
        if (selectionControls) {
          selectionControls.classList.toggle('hidden', !enable);
        }
        
        // Add/remove grouping mode class to body
        document.body.classList.toggle('grouping-mode', enable);
        
        renderShoppingItems();
      }
      
      // Function to check if there are manual groups
      function hasManualGroups() {
        return shoppingListData.items.some(item => item.manualGroupId);
      }
      
      // Function to confirm grouping
      async function confirmGrouping() {
        if (selectedGroupIds.size < 2) {
          alert('Bitte w√§hlen Sie mindestens 2 Gruppen aus.');
          return;
        }
        
        // Generate a new group ID
        const newGroupId = `manual_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        
        // Get all item IDs from selected groups
        const selectedItemIds = new Set();
        selectedGroupIds.forEach(groupId => {
          const groupElement = document.querySelector(`[data-group-id="${groupId}"]`);
          if (groupElement) {
            const itemIdsAttr = groupElement.getAttribute('data-item-ids');
            if (itemIdsAttr) {
              itemIdsAttr.split(',').forEach(id => selectedItemIds.add(id));
            }
          }
        });
        
        // Update items with the new manualGroupId
        const updatedItems = shoppingListData.items.map(item => {
          if (selectedItemIds.has(item.id)) {
            return { ...item, manualGroupId: newGroupId };
          }
          return item;
        });
        
        try {
          const response = await fetch(`/api/shopping-lists?id=${shoppingListId}`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              items: updatedItems
            }),
          });
          
          if (response.ok) {
            const updatedList = await response.json();
            shoppingListData.items = updatedList.items;
            
            // Exit grouping mode and re-render
            toggleGroupingMode(false);
            renderShoppingItems();
            updateHeaderCounters();
          } else {
            const error = await response.json();
            alert(error.error || 'Fehler beim Gruppieren der Artikel');
          }
        } catch (error) {
          console.error('Error grouping items:', error);
          alert('Fehler beim Gruppieren der Artikel');
        }
      }
      
      // Function to ungroup all items
      async function ungroupAll() {
        if (!hasManualGroups()) {
          return;
        }
        
        if (!confirm('M√∂chten Sie wirklich alle manuellen Gruppierungen aufheben?')) {
          return;
        }
        
        // Remove manualGroupId from all items
        const updatedItems = shoppingListData.items.map(item => {
          const { manualGroupId, ...itemWithoutGroupId } = item;
          return itemWithoutGroupId;
        });
        
        try {
          const response = await fetch(`/api/shopping-lists?id=${shoppingListId}`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              items: updatedItems
            }),
          });
          
          if (response.ok) {
            const updatedList = await response.json();
            shoppingListData.items = updatedList.items;
            
            // Re-render
            renderShoppingItems();
            updateHeaderCounters();
            
            // Update ungroup button visibility
            const ungroupBtn = document.getElementById('ungroup-items-btn');
            if (ungroupBtn) {
              ungroupBtn.style.display = 'none';
            }
          } else {
            const error = await response.json();
            alert(error.error || 'Fehler beim Aufheben der Gruppierungen');
          }
        } catch (error) {
          console.error('Error ungrouping items:', error);
          alert('Fehler beim Aufheben der Gruppierungen');
        }
      }
      
             // Function to attach expand/collapse listeners
       function attachExpandListeners() {
         document.querySelectorAll('[data-expandable="true"]').forEach(item => {
           item.addEventListener('click', (e) => {
             // Don't expand if clicking on checkbox or in grouping mode
             if (e.target.closest('.item-checkbox') || e.target.closest('.group-selection-checkbox') || isGroupingMode) {
               return;
             }
             
             const group = item.closest('.shopping-item-group');
             const details = group.querySelector('.item-details');
             const expandIcon = item.querySelector('.expand-icon');
             
             if (details && expandIcon) {
               const isExpanded = !details.classList.contains('hidden');
               
               if (isExpanded) {
                 // Collapse
                 details.classList.add('hidden');
                 expandIcon.style.transform = 'rotate(0deg)';
               } else {
                 // Expand
                 details.classList.remove('hidden');
                 expandIcon.style.transform = 'rotate(180deg)';
               }
             }
           });
         });
       }
       
       // Function to attach recipe highlight listeners
       function attachRecipeHighlightListeners() {
         document.querySelectorAll('.recipe-highlight-btn').forEach(btn => {
           btn.addEventListener('click', (e) => {
             e.stopPropagation(); // Prevent expanding/collapsing
             
             const recipeIds = btn.getAttribute('data-recipe-ids');
             if (recipeIds) {
               // For items linked to multiple recipes, use the first one
               const recipeId = recipeIds.split(',')[0];
               toggleRecipeHighlight(recipeId);
             }
           });
         });
       }
       
       // Function to attach checkbox event listeners
       function attachCheckboxListeners() {
         document.querySelectorAll('.item-checkbox').forEach(checkbox => {
          checkbox.addEventListener('change', async (e) => {
          // Don't handle item checkbox changes in grouping mode
          if (isGroupingMode) {
            e.preventDefault();
            e.stopPropagation();
            return;
          }
          
          const target = e.target;
          const itemElement = target.closest('.shopping-item-group');
          const itemIdsAttr = itemElement.getAttribute('data-item-ids');
          if (!itemIdsAttr) {
            console.error('No data-item-ids found on element:', itemElement);
            return;
          }
          const itemIds = itemIdsAttr.split(',');
          const isChecked = target.checked;

          try {
            // Update all items in the group
            const updatedItems = shoppingListData.items.map(item => 
              itemIds.includes(item.id) ? { ...item, isChecked } : item
            );

            const response = await fetch(`/api/shopping-lists?id=${shoppingListId}`, {
              method: 'PUT',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                items: updatedItems
              }),
            });

            if (response.ok) {
              // Update local data
              shoppingListData.items = updatedItems;
              
              // Re-render the items to show updated grouping
              renderShoppingItems();
              
              // Update header counter
              updateHeaderCounters();
            } else {
              // Revert checkbox if API call failed
              target.checked = !isChecked;
              
              const error = await response.json();
              console.error('Error updating item:', error);
              alert('Fehler beim Aktualisieren des Artikels');
            }
          } catch (error) {
            console.error('Error updating item:', error);
            
            // Revert checkbox if API call failed
            target.checked = !isChecked;
            
            alert('Fehler beim Aktualisieren des Artikels');
          }
        });
      });
      }
      
      // Initial render
      renderShoppingItems();



      // Function to update header counters
      function updateHeaderCounters() {
        const uncheckedCount = shoppingListData.items.filter(item => !item.isChecked).length;
        const totalCount = shoppingListData.items.length;
        
        // Update counter in header
        const counterElement = document.querySelector('p.text-sm.text-muted');
        if (counterElement) {
          counterElement.textContent = `${uncheckedCount} von ${totalCount} Artikeln offen`;
        }
        
        // Update main heading counter for items section only
        const itemsHeadingElement = document.getElementById('items-heading');
        if (itemsHeadingElement) {
          itemsHeadingElement.textContent = `Einkaufsliste (${totalCount} Artikel)`;
        }
      }

      // Add item modal handling
      const addItemBtn = document.getElementById('add-item-btn');
      const addItemModal = document.getElementById('add-item-modal');
      const addItemForm = document.getElementById('add-item-form');
      const closeButtons = addItemModal?.querySelectorAll('.modal-close');

      addItemBtn?.addEventListener('click', () => {
        addItemModal?.classList.remove('hidden');
        document.getElementById('item-name')?.focus();
      });

      closeButtons?.forEach(btn => {
        btn.addEventListener('click', () => {
          addItemModal?.classList.add('hidden');
          addItemForm?.reset();
        });
      });

      addItemModal?.querySelector('.modal-overlay')?.addEventListener('click', () => {
        addItemModal?.classList.add('hidden');
        addItemForm?.reset();
      });

      addItemForm?.addEventListener('submit', async (e) => {
        e.preventDefault();
        
        const formData = new FormData(addItemForm);
        const name = formData.get('name');
        const amountValue = formData.get('amount');
        const unitValue = formData.get('unit');
        const description = formData.get('description');

        if (!name.trim()) {
          alert('Bitte geben Sie einen Namen f√ºr den Artikel ein.');
          return;
        }

        // Make amount and unit optional - only include quantity if both are provided
        const amount = amountValue && !isNaN(parseFloat(amountValue)) ? parseFloat(amountValue) : null;
        const unit = unitValue && unitValue.trim() ? unitValue.trim() : null;
        
        // Only include quantity if both amount and unit are provided (no defaults)
        const item = {
          name: name.trim(),
          description: description.trim() || undefined,
          isChecked: false
        };
        
        if (amount !== null && unit !== null) {
          item.quantity = { amount, unit };
        }

        try {
          const response = await fetch(`/api/shopping-lists?id=${shoppingListId}`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              action: 'add-item',
              item
            }),
          });

          if (response.ok) {
            const updatedList = await response.json();
            shoppingListData.items = updatedList.items;
            
            // Re-render the items to show new item
            renderShoppingItems();
            updateHeaderCounters();
            
            // Close modal and reset form
            addItemModal?.classList.add('hidden');
            addItemForm?.reset();
          } else {
            const error = await response.json();
            alert(error.error || 'Fehler beim Hinzuf√ºgen des Artikels');
          }
        } catch (error) {
          console.error('Error adding item:', error);
          alert('Fehler beim Hinzuf√ºgen des Artikels');
        }
      });

      // Helper functions for recipe data structure
      function getRecipeIngredients(recipe) {
        const ingredients = [];
        
        function extractIngredientsFromGroup(group) {
          if (group.ingredients) {
            group.ingredients.forEach(item => {
              if (item.ingredients) {
                // It's a nested group
                extractIngredientsFromGroup(item);
              } else if (item.name) {
                // It's an ingredient
                ingredients.push(item);
              }
            });
          }
        }
        
        if (recipe.ingredientGroups) {
          recipe.ingredientGroups.forEach(group => extractIngredientsFromGroup(group));
        }
        
        return ingredients;
      }

      function getRecipeIngredientCount(recipe) {
        return getRecipeIngredients(recipe).length;
      }

      function toggleRecipeHighlight(recipeId) {
        console.log('toggleRecipeHighlight called with recipeId:', recipeId);
        
        // Clear existing highlights
        clearRecipeHighlights();
        
        if (currentlyHighlightedRecipe === recipeId) {
          console.log('Same recipe clicked, clearing highlight');
          // If same recipe clicked, just clear highlights
          currentlyHighlightedRecipe = null;
          return;
        }
        
        // Set new highlight
        currentlyHighlightedRecipe = recipeId;
        console.log('Setting new highlight for recipe:', recipeId);
        highlightRecipeIngredients(recipeId);
      }

      function clearRecipeHighlights() {
        console.log('Clearing all recipe highlights');
        // Remove all highlights from shopping item groups
        document.querySelectorAll('.shopping-item-group').forEach(group => {
          group.classList.remove('highlighted');
          
          // Collapse any expanded groups
          const expandableItem = group.querySelector('[data-expandable="true"]');
          if (expandableItem) {
            const details = group.querySelector('.item-details');
            const expandIcon = group.querySelector('.expand-icon');
            
            if (details && expandIcon) {
              // Collapse the group
              details.classList.add('hidden');
              expandIcon.style.transform = 'rotate(0deg)';
            }
          }
        });
        
        // Remove highlights from individual detail items
        document.querySelectorAll('.detail-item-highlighted').forEach(item => {
          item.classList.remove('detail-item-highlighted');
        });
        
        // Remove active state from recipe cards
        document.querySelectorAll('.recipe-item').forEach(card => {
          card.classList.remove('active');
        });
      }

      function highlightRecipeIngredients(recipeId) {
        console.log('Highlighting ingredients for recipe:', recipeId);
        // Find all shopping item groups that belong to this recipe
        document.querySelectorAll('.shopping-item-group').forEach(group => {
          const recipeIds = group.getAttribute('data-recipe-ids');
          console.log('Group recipe IDs:', recipeIds);
          if (recipeIds && recipeIds.split(',').includes(recipeId)) {
            console.log('Found matching group:', group);
            group.classList.add('highlighted');
            
            // Auto-expand groups that have multiple items
            const expandableItem = group.querySelector('[data-expandable="true"]');
            if (expandableItem) {
              const details = group.querySelector('.item-details');
              const expandIcon = group.querySelector('.expand-icon');
              
              if (details && expandIcon) {
                // Expand the group
                details.classList.remove('hidden');
                expandIcon.style.transform = 'rotate(180deg)';
                
                // Highlight individual items from this recipe in the details
                highlightIndividualItems(group, recipeId);
              }
            }
          }
        });
        
        // Mark recipe card as active
        document.querySelectorAll('.recipe-item').forEach(card => {
          const cardRecipeId = card.getAttribute('data-recipe-id');
          console.log('Checking recipe card:', cardRecipeId);
          if (cardRecipeId === recipeId) {
            console.log('Found matching card, adding active class');
            card.classList.add('active');
          }
        });
      }
      
      function highlightIndividualItems(group, recipeId) {
        console.log('Highlighting individual items in group for recipe:', recipeId);
        // Highlight individual detail items that belong to this recipe
        const details = group.querySelector('.item-details');
        if (details) {
          const detailItems = details.querySelectorAll('.detail-item');
          
          detailItems.forEach(detailItem => {
            const itemId = detailItem.getAttribute('data-item-id');
            const item = shoppingListData.items.find(item => item.id === itemId);
            
            if (item && item.recipeId === recipeId) {
              console.log('Found matching detail item:', itemId);
              detailItem.classList.add('detail-item-highlighted');
            }
          });
        }
      }

      // Load recipes for modal
      async function loadRecipes() {
        try {
          const response = await fetch('/api/recipes');
          if (response.ok) {
            availableRecipes = await response.json();
            populateRecipeModal();
          }
        } catch (error) {
          console.error('Error loading recipes:', error);
        }
      }

      // Populate recipe modal
      function populateRecipeModal() {
        const recipeLoading = document.getElementById('recipe-loading');
        const recipeList = document.getElementById('recipe-list');
        const availableRecipesContainer = document.getElementById('available-recipes');
        const noRecipesFound = document.getElementById('no-recipes-found');
        
        recipeLoading?.classList.add('hidden');
        recipeList?.classList.remove('hidden');
        
        if (availableRecipes.length === 0) {
          availableRecipesContainer.innerHTML = '';
          noRecipesFound?.classList.remove('hidden');
          return;
        }
        
        noRecipesFound?.classList.add('hidden');
        renderAvailableRecipes(availableRecipes);
      }

      // Render available recipes
      function renderAvailableRecipes(recipes) {
        const container = document.getElementById('available-recipes');
        if (!container) return;
        
        // Get already added recipe IDs
        const addedRecipeIds = new Set(shoppingListData.recipes?.map(r => r.id) || []);
        
        container.innerHTML = recipes.map(recipe => {
          const isAlreadyAdded = addedRecipeIds.has(recipe.id);
          const cardClasses = isAlreadyAdded 
            ? 'recipe-card border border-gray-200 dark:border-gray-700 rounded-lg p-4 bg-gray-100 dark:bg-gray-800 opacity-50 cursor-not-allowed transition-colors'
            : 'recipe-card border border-gray-300 dark:border-gray-600 rounded-lg p-4 hover:border-orange-500 cursor-pointer transition-colors';
          
          return `
            <div class="${cardClasses}" data-recipe-id="${recipe.id}">
              <div class="flex items-start space-x-3">
                ${!isAlreadyAdded ? `
                  <input type="checkbox" class="recipe-checkbox mt-1 w-5 h-5 text-orange-600 bg-gray-100 border-gray-300 rounded focus:ring-orange-500 focus:ring-2" data-recipe-id="${recipe.id}" />
                ` : `
                  <div class="mt-1 w-5 h-5 bg-gray-300 dark:bg-gray-600 rounded flex items-center justify-center">
                    <svg class="w-3 h-3 text-gray-500" fill="currentColor" viewBox="0 0 24 24">
                      <path d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                    </svg>
                  </div>
                `}
                ${recipe.images && recipe.images.length > 0 
                  ? `<img src="${recipe.images[0].url}" alt="${recipe.title}" class="w-16 h-16 object-cover rounded-lg ${isAlreadyAdded ? 'grayscale' : ''}">`
                  : `<div class="w-16 h-16 bg-gray-200 dark:bg-gray-700 rounded-lg flex items-center justify-center">
                       <svg class="w-8 h-8 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                         <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"/>
                       </svg>
                     </div>`
                }
                <div class="flex-1 min-w-0">
                  <h3 class="font-medium ${isAlreadyAdded ? 'text-gray-500 dark:text-gray-400' : 'text-gray-900 dark:text-white'} truncate">
                    ${recipe.title}
                    ${isAlreadyAdded ? '<span class="text-xs ml-2 bg-green-100 dark:bg-green-800 text-green-800 dark:text-green-200 px-2 py-0.5 rounded">Bereits hinzugef√ºgt</span>' : ''}
                  </h3>
                  <p class="text-sm text-muted mt-1">${getRecipeIngredientCount(recipe)} Zutaten</p>
                  ${recipe.description ? `<p class="text-sm text-muted mt-1 line-clamp-2">${recipe.description}</p>` : ''}
                </div>
              </div>
            </div>
          `;
        }).join('');
        
        // Attach change handlers for checkboxes
        container.querySelectorAll('.recipe-checkbox').forEach(checkbox => {
          checkbox.addEventListener('change', updateSelectedCount);
        });
        
        // Update selected count
        updateSelectedCount();
      }

      // Update selected count and button state
      function updateSelectedCount() {
        const selectedCheckboxes = document.querySelectorAll('.recipe-checkbox:checked');
        const selectedCount = selectedCheckboxes.length;
        const selectedCountElement = document.getElementById('selected-count');
        const addSelectedButton = document.getElementById('add-selected-recipes');
        const selectAllCheckbox = document.getElementById('select-all-recipes');
        
        // Update count display
        if (selectedCountElement) {
          selectedCountElement.textContent = `${selectedCount} Rezept${selectedCount !== 1 ? 'e' : ''} ausgew√§hlt`;
        }
        
        // Update add button state
        if (addSelectedButton) {
          addSelectedButton.disabled = selectedCount === 0;
        }
        
        // Update select all checkbox state
        const allCheckboxes = document.querySelectorAll('.recipe-checkbox');
        if (selectAllCheckbox && allCheckboxes.length > 0) {
          selectAllCheckbox.checked = selectedCount === allCheckboxes.length;
          selectAllCheckbox.indeterminate = selectedCount > 0 && selectedCount < allCheckboxes.length;
        }
      }

      // Search recipes
      const recipeSearch = document.getElementById('recipe-search');
      recipeSearch?.addEventListener('input', (e) => {
        const searchTerm = e.target.value.toLowerCase();
        const filteredRecipes = availableRecipes.filter(recipe => 
          recipe.title.toLowerCase().includes(searchTerm) ||
          recipe.description?.toLowerCase().includes(searchTerm) ||
          getRecipeIngredients(recipe).some(ing => ing.name.toLowerCase().includes(searchTerm))
        );
        renderAvailableRecipes(filteredRecipes);
      });

      // Add multiple recipes to shopping list
      async function addMultipleRecipesToShoppingList(recipeIds) {
        try {
          // Add recipes one by one (we could optimize this later with a batch API)
          for (const recipeId of recipeIds) {
            const response = await fetch(`/api/shopping-lists?id=${shoppingListId}`, {
              method: 'PUT',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                action: 'add-recipe',
                recipeId: recipeId
              }),
            });

            if (!response.ok) {
              const error = await response.json();
              throw new Error(error.error || `Fehler beim Hinzuf√ºgen von Rezept ${recipeId}`);
            }
          }

          // Reload the shopping list to get all updates
          const response = await fetch(`/api/shopping-lists?id=${shoppingListId}`);
          if (response.ok) {
            const updatedList = await response.json();
            shoppingListData.items = updatedList.items;
            shoppingListData.recipes = updatedList.recipes || [];
            
            // Re-render everything
            renderShoppingItems();
            renderShoppingRecipes();
            updateHeaderCounters();
            
            // Re-render recipe modal to show updated state
            renderAvailableRecipes(availableRecipes);
            
            // Show success message
            const recipeCount = recipeIds.length;
            alert(`${recipeCount} Rezept${recipeCount !== 1 ? 'e wurden' : ' wurde'} zur Einkaufsliste hinzugef√ºgt!`);
          }
        } catch (error) {
          console.error('Error adding recipes:', error);
          alert('Fehler beim Hinzuf√ºgen der Rezepte: ' + error.message);
        }
      }

      // Add single recipe to shopping list (legacy function for compatibility)
      async function addRecipeToShoppingList(recipeId) {
        await addMultipleRecipesToShoppingList([recipeId]);
      }

      // Initial render of recipes
      renderShoppingRecipes();
      
      // Function to render shopping recipes
      function renderShoppingRecipes() {
        const section = document.getElementById('shopping-recipes-section');
        const container = document.getElementById('shopping-recipes');
        
        if (!section || !container) return;
        
        if (!shoppingListData.recipes || shoppingListData.recipes.length === 0) {
          section.style.display = 'none';
          return;
        }
        
        section.style.display = 'block';
        
        // Get the template
        const template = document.getElementById('recipe-template');
        if (!template) {
          console.error('Recipe template not found');
          return;
        }
        
        // Clear the container
        container.innerHTML = '';
        
        // Add each recipe
        shoppingListData.recipes.forEach(recipe => {
          // Clone the template
          const clone = template.content.cloneNode(true);
          const recipeElement = clone.querySelector('.recipe-item');
          
          // Set recipe ID
          recipeElement.setAttribute('data-recipe-id', recipe.id);
          
          // Set title
          const titleElement = clone.querySelector('.recipe-title');
          if (titleElement) {
            titleElement.textContent = recipe.title;
          }
          
                    // Set info text
           const infoElement = clone.querySelector('.recipe-info');
           if (infoElement) {
             const recipeItemCount = shoppingListData.items.filter(item => item.recipeId === recipe.id).length;
             infoElement.textContent = `${recipeItemCount} Zutaten in der Liste`;
           }
          
          // Set servings
          const servingsInput = clone.querySelector('.portion-input');
          if (servingsInput) {
            servingsInput.value = recipe.currentServings || recipe.servings;
            servingsInput.setAttribute('data-recipe-id', recipe.id);
          }
          
          // Set original servings
          const originalServingsElement = clone.querySelector('.original-servings');
          if (originalServingsElement) {
            originalServingsElement.textContent = recipe.servings;
          }
          
          // Set recipe link
          const recipeLink = clone.querySelector('.recipe-link');
          if (recipeLink) {
            recipeLink.href = `/rezept/${recipe.id}`;
          }
          
          // Add event listeners
          const decreaseBtn = clone.querySelector('.portion-decrease');
          const increaseBtn = clone.querySelector('.portion-increase');
          const portionInput = clone.querySelector('.portion-input');
          const removeBtn = clone.querySelector('.remove-recipe');
          
          if (decreaseBtn && portionInput) {
            decreaseBtn.addEventListener('click', () => {
              const currentValue = parseInt(portionInput.value);
              if (currentValue > 1) {
                portionInput.value = currentValue - 1;
                updateRecipePortions(portionInput);
              }
            });
          }
          
          if (increaseBtn && portionInput) {
            increaseBtn.addEventListener('click', () => {
              const currentValue = parseInt(portionInput.value);
              portionInput.value = currentValue + 1;
              updateRecipePortions(portionInput);
            });
          }
          
          if (portionInput) {
            portionInput.addEventListener('change', (e) => {
              updateRecipePortions(e.target);
            });
          }
          
          if (removeBtn) {
            removeBtn.addEventListener('click', async (e) => {
              e.stopPropagation();
              if (confirm('M√∂chten Sie dieses Rezept wirklich aus der Einkaufsliste entfernen?')) {
                await removeRecipeFromShoppingList(recipe.id);
              }
            });
          }
          
          // Add click handler for recipe highlighting
          recipeElement.addEventListener('click', (e) => {
            // Don't trigger if clicking on a button or input
            if (!e.target.closest('.recipe-action')) {
              toggleRecipeHighlight(recipe.id);
            }
          });
          
          container.appendChild(clone);
        });
      }
      
      // Function to update recipe portions and scale ingredients
      async function updateRecipePortions(input) {
        const recipeId = input.getAttribute('data-recipe-id');
        const newServings = parseInt(input.value);
        
        if (!recipeId || !newServings || newServings < 1) {
          console.error('Invalid input for portion update');
          return;
        }
        
        console.log('Updating portions for recipe:', recipeId, 'to', newServings);
        
        try {
          const response = await fetch(`/api/shopping-lists/${shoppingListData.id}/recipes/${recipeId}/servings`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              servings: newServings
            })
          });
          
          if (response.ok) {
            const updatedList = await response.json();
            
            // Update local data by copying properties instead of reassignment
            Object.assign(shoppingListData, updatedList);
            
            // Re-render items to show updated quantities
            renderShoppingItems();
            renderShoppingRecipes();
            
            console.log('Successfully updated portions');
          } else {
            console.error('Failed to update portions:', response.statusText);
            
            // Reset to original value
            const recipe = shoppingListData.recipes.find(r => r.id === recipeId);
            if (recipe) {
              input.value = recipe.currentServings || recipe.servings;
            }
          }
        } catch (error) {
          console.error('Error updating portions:', error);
          
          // Reset to original value
          const recipe = shoppingListData.recipes.find(r => r.id === recipeId);
          if (recipe) {
            input.value = recipe.currentServings || recipe.servings;
          }
        }
      }
      
      // Setup Server-Sent Events for real-time updates
      let eventSource = null;
      let reconnectTimer = null;
      let isOnline = navigator.onLine;
      
      function connectSSE() {
        if (eventSource) {
          eventSource.close();
        }
        
        try {
          eventSource = new EventSource(`/api/shopping-lists/stream?listId=${shoppingListId}`);
          
          eventSource.onopen = () => {
            console.log('‚úÖ Real-time sync connected');
            // Clear any reconnect timer
            if (reconnectTimer) {
              clearTimeout(reconnectTimer);
              reconnectTimer = null;
            }
            // Show online indicator
            showSyncStatus('online');
          };
          
          eventSource.onmessage = (event) => {
            try {
              const data = JSON.parse(event.data);
              
              if (data.type === 'connected') {
                console.log('Connected to shopping list updates');
              } else if (data.type === 'update' && data.data) {
                // Update received from another client
                console.log('üì± Real-time update received');
                updateFromServer(data.data);
                showSyncStatus('synced');
              }
            } catch (error) {
              console.error('Error parsing SSE message:', error);
            }
          };
          
          eventSource.onerror = (error) => {
            console.log('‚ùå Real-time sync disconnected');
            showSyncStatus('offline');
            
            // Attempt to reconnect after delay
            if (!reconnectTimer) {
              reconnectTimer = setTimeout(() => {
                if (isOnline) {
                  console.log('üîÑ Attempting to reconnect...');
                  connectSSE();
                }
              }, 3000);
            }
          };
          
        } catch (error) {
          console.error('Error setting up SSE:', error);
          showSyncStatus('offline');
        }
      }
      
      function updateFromServer(updatedList) {
        if (!updatedList) return;
        
        // Only update if data is different
        const currentItemsJson = JSON.stringify(shoppingListData.items || []);
        const newItemsJson = JSON.stringify(updatedList.items || []);
        const currentRecipesJson = JSON.stringify(shoppingListData.recipes || []);
        const newRecipesJson = JSON.stringify(updatedList.recipes || []);
        
        if (currentItemsJson !== newItemsJson || currentRecipesJson !== newRecipesJson) {
          // Update properties individually to avoid reassignment
          if (updatedList.items) {
            shoppingListData.items = updatedList.items;
          }
          if (updatedList.recipes) {
            shoppingListData.recipes = updatedList.recipes;
          }
          
          // Re-render the UI
          renderShoppingItems();
          renderShoppingRecipes();
        }
      }
      
      function showSyncStatus(status) {
        let indicator;
        
        // Remove any existing sync status indicators
        document.querySelectorAll('.sync-status').forEach(el => el.remove());
        
        // Create new indicator based on status
        if (status === 'online') {
          indicator = '<span class="sync-status text-xs text-green-600 dark:text-green-400 flex items-center space-x-1"><span class="w-2 h-2 bg-green-500 rounded-full"></span><span>Live</span></span>';
        } else if (status === 'synced') {
          indicator = '<span class="sync-status text-xs text-blue-600 dark:text-blue-400 flex items-center space-x-1"><span class="w-2 h-2 bg-blue-500 rounded-full animate-pulse"></span><span>Synchronisiert</span></span>';
          // Hide synced indicator after 2 seconds and restore live indicator
          setTimeout(() => {
            document.querySelector('.sync-status')?.remove();
            showSyncStatus('online');
          }, 2000);
        } else {
          indicator = '<span class="sync-status text-xs text-red-600 dark:text-red-400 flex items-center space-x-1"><span class="w-2 h-2 bg-red-500 rounded-full"></span><span>Offline</span></span>';
        }
        
        // Insert the indicator into the container
        const container = document.getElementById('sync-status-container');
        if (container) {
          container.innerHTML = indicator;
        }
      }
      
      // Handle online/offline status
      window.addEventListener('online', () => {
        isOnline = true;
        connectSSE();
      });
      
      window.addEventListener('offline', () => {
        isOnline = false;
        showSyncStatus('offline');
        if (eventSource) {
          eventSource.close();
          eventSource = null;
        }
      });
      
      // Setup SSE connection
      if (isOnline) {
        connectSSE();
      }
      
      // Cleanup on page unload
      window.addEventListener('beforeunload', () => {
        if (eventSource) {
          eventSource.close();
        }
        if (reconnectTimer) {
          clearTimeout(reconnectTimer);
        }
      });

      // Function to remove a recipe from the shopping list
      async function removeRecipeFromShoppingList(recipeId) {
        try {
          const response = await fetch(`/api/shopping-lists/${shoppingListData.id}/recipes`, {
            method: 'DELETE',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              recipeId: recipeId
            })
          });
          
          if (response.ok) {
            // Update local data
            shoppingListData.recipes = shoppingListData.recipes.filter(r => r.id !== recipeId);
            shoppingListData.items = shoppingListData.items.filter(item => item.recipeId !== recipeId);
            
            // Clear highlights if this recipe was highlighted
            if (currentlyHighlightedRecipe === recipeId) {
              clearRecipeHighlights();
              currentlyHighlightedRecipe = null;
            }
            
            // Re-render the UI
            renderShoppingItems();
            renderShoppingRecipes();
          } else {
            console.error('Failed to remove recipe:', response.statusText);
            alert('Fehler beim Entfernen des Rezepts');
          }
        } catch (error) {
          console.error('Error removing recipe:', error);
          alert('Fehler beim Entfernen des Rezepts');
        }
      }

      // Add recipe modal handling
      const addRecipeBtn = document.getElementById('add-recipe-btn');
      const addRecipeModal = document.getElementById('add-recipe-modal');
      const selectAllRecipes = document.getElementById('select-all-recipes');
      const addSelectedRecipesBtn = document.getElementById('add-selected-recipes');

      // Open recipe modal and load recipes
      addRecipeBtn?.addEventListener('click', () => {
        addRecipeModal?.classList.remove('hidden');
        loadRecipes();
      });

      // Close recipe modal
      addRecipeModal?.querySelector('.modal-close')?.addEventListener('click', () => {
        addRecipeModal?.classList.add('hidden');
      });

      addRecipeModal?.querySelector('.modal-overlay')?.addEventListener('click', () => {
        addRecipeModal?.classList.add('hidden');
      });

      // Handle select all recipes
      selectAllRecipes?.addEventListener('change', (e) => {
        const checkboxes = document.querySelectorAll('.recipe-checkbox');
        checkboxes.forEach(checkbox => {
          checkbox.checked = e.target.checked;
        });
        updateSelectedCount();
      });

      // Handle add selected recipes
      addSelectedRecipesBtn?.addEventListener('click', async () => {
        const selectedRecipes = Array.from(document.querySelectorAll('.recipe-checkbox:checked'))
          .map(checkbox => checkbox.getAttribute('data-recipe-id'))
          .filter(Boolean);

        if (selectedRecipes.length > 0) {
          await addMultipleRecipesToShoppingList(selectedRecipes);
          addRecipeModal?.classList.add('hidden');
        }
      });
    });
  </script>
</Layout> 