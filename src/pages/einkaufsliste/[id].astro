---
export const prerender = false;
import Layout from '../../layouts/Layout.astro';
import { db } from '../../lib/database';
import type { ShoppingList } from '../../types/recipe';

const { id } = Astro.params;

if (!id) {
  return Astro.redirect('/einkaufslisten');
}

// Einkaufsliste laden
let shoppingList: ShoppingList | null = null;
try {
  shoppingList = db.getShoppingList(id);
} catch (error) {
  console.error('Error loading shopping list:', error);
}

if (!shoppingList) {
  return Astro.redirect('/einkaufslisten');
}

// Query-Parameter für Edit-Modus überprüfen
const url = new URL(Astro.request.url);
const isEditMode = url.searchParams.get('edit') === 'true';

const checkedItems = shoppingList.items.filter(item => item.isChecked);
const uncheckedItems = shoppingList.items.filter(item => !item.isChecked);
---

<Layout title={`${shoppingList.title} - Einkaufsliste`}>
  <div class="container-narrow">
    <!-- Header -->
    <div class="mb-6">
      <div class="flex justify-between items-center mb-4">
        <div class="flex items-center space-x-3">
          <a href="/einkaufslisten" class="btn btn-ghost btn-sm flex items-center space-x-2">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
            </svg>
            <span>Zurück</span>
          </a>
          <!-- Sync status will be inserted here by JavaScript -->
          <div id="sync-status-container"></div>
        </div>
        <div class="flex space-x-2">
          <button id="add-item-btn" class="btn btn-success flex items-center space-x-2">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"/>
            </svg>
            <span>Artikel hinzufügen</span>
          </button>
          <button id="add-recipe-btn" class="btn btn-blue flex items-center space-x-2">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.746 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"/>
            </svg>
            <span>Rezept hinzufügen</span>
          </button>
          <a href={`/einkaufsliste/${id}/edit`} class="btn btn-secondary flex items-center space-x-2">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"/>
            </svg>
            <span>Bearbeiten</span>
          </a>
        </div>
      </div>
      <div>
        <h1 class="heading-primary">{shoppingList.title}</h1>
        {shoppingList.description && (
          <p class="text-muted mt-1">
            {shoppingList.description}
          </p>
        )}
        <p class="text-sm text-muted mt-1">
          {uncheckedItems.length} von {shoppingList.items.length} Artikeln offen
        </p>
      </div>
    </div>

    <!-- Shopping List Recipes -->
    <div id="shopping-recipes-section" class="card" style="display: none;">
      <div class="card-content">
        <h2 class="heading-secondary mb-4">Rezepte</h2>
        <div id="shopping-recipes" class="space-y-3">
          <!-- Recipes will be populated by JavaScript -->
        </div>
      </div>
    </div>

            <!-- Shopping List Items -->
    <div class="card mt-6">
      <div class="card-content">
        <h2 id="items-heading" class="heading-secondary mb-4">
          Einkaufsliste ({shoppingList.items.length} Artikel)
        </h2>
        
        <div class="space-y-2" id="shopping-items">
          <!-- Items will be populated by JavaScript -->
        </div>
      </div>
    </div>
  </div>

  <!-- Add Item Modal -->
  <div id="add-item-modal" class="modal hidden">
    <div class="modal-overlay"></div>
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title">Artikel hinzufügen</h2>
        <button class="modal-close">&times;</button>
      </div>
      
      <form id="add-item-form" class="modal-body space-y-4">
        <div>
          <label for="item-name" class="form-label">Name</label>
          <input 
            type="text" 
            id="item-name" 
            name="name"
            class="form-input" 
            placeholder="z.B. Milch, Brot, Äpfel..."
            required
          />
        </div>
        
        <div class="grid grid-cols-2 gap-4">
          <div>
            <label for="item-amount" class="form-label">Menge</label>
            <input 
              type="number" 
              id="item-amount" 
              name="amount"
              class="form-input" 
              placeholder="1"
              step="0.1"
              min="0"
              required
            />
          </div>
          <div>
            <label for="item-unit" class="form-label">Einheit</label>
            <select 
              id="item-unit" 
              name="unit"
              class="form-input" 
              required
            >
              <option value="">Einheit wählen...</option>
            </select>
          </div>
        </div>
        
        <div>
          <label for="item-description" class="form-label">Beschreibung (optional)</label>
          <input 
            type="text" 
            id="item-description" 
            name="description"
            class="form-input" 
            placeholder="z.B. Bio, 1,5% Fett..."
          />
        </div>
      </form>
      
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary modal-close" style="min-width: 100px;">Abbrechen</button>
        <button type="submit" form="add-item-form" class="btn btn-success" style="min-width: 100px;">
          Hinzufügen
        </button>
      </div>
    </div>
  </div>

  <!-- Add Recipe Modal -->
  <div id="add-recipe-modal" class="modal hidden">
    <div class="modal-overlay"></div>
    <div class="modal-content modal-lg">
      <div class="modal-header">
        <h2 class="modal-title">Rezept hinzufügen</h2>
        <button class="modal-close">&times;</button>
      </div>
      
      <div class="modal-body">
        <div id="recipe-loading" class="text-center py-8">
          <div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-orange-500"></div>
          <p class="text-muted mt-2">Rezepte werden geladen...</p>
        </div>
        
        <div id="recipe-list" class="hidden">
          <div class="mb-4">
            <input 
              type="text" 
              id="recipe-search" 
              class="form-input" 
              placeholder="Rezepte durchsuchen..."
            />
          </div>
          
          <div class="mb-4 flex items-center justify-between">
            <div class="flex items-center space-x-4">
              <label class="flex items-center space-x-2">
                <input type="checkbox" id="select-all-recipes" class="form-checkbox" />
                <span class="text-sm font-medium">Alle auswählen</span>
              </label>
              <span id="selected-count" class="text-sm text-muted">0 Rezepte ausgewählt</span>
            </div>
            <button id="add-selected-recipes" class="btn btn-success btn-sm" disabled>
              Ausgewählte hinzufügen
            </button>
          </div>
          
          <div id="available-recipes" class="space-y-3 max-h-80 overflow-y-auto">
            <!-- Recipes will be populated by JavaScript -->
          </div>
          
          <div id="no-recipes-found" class="hidden text-center py-8">
            <svg class="w-12 h-12 mx-auto text-gray-400 mb-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M9.172 16.172a4 4 0 015.656 0M9 12h6m-6-4h6m2 5.291A7.962 7.962 0 0112 15c-2.34 0-4.467-.881-6.072-2.327a8.002 8.002 0 01-.344-10.854"/>
            </svg>
            <p class="text-muted">Keine Rezepte gefunden</p>
          </div>
        </div>
      </div>
      
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary modal-close">Schließen</button>
      </div>
    </div>
  </div>

  <script define:vars={{ shoppingListId: id, shoppingListData: shoppingList }}>
    // Variables are already defined via define:vars
    let availableUnits = [];
    
    // Recipe management variables
    let availableRecipes = [];
    let currentlyHighlightedRecipe = null;

    // Load available units
    async function loadUnits() {
      try {
        const response = await fetch('/api/units');
        if (response.ok) {
          availableUnits = await response.json();
          populateUnitDropdown();
        }
      } catch (error) {
        console.error('Error loading units:', error);
      }
    }

    // Populate unit dropdown in add item modal
    function populateUnitDropdown() {
      const unitSelect = document.getElementById('item-unit');
      if (!unitSelect) return;

      // Clear existing options except the first one
      while (unitSelect.children.length > 1) {
        unitSelect.removeChild(unitSelect.lastChild);
      }

      // Add all available units
      availableUnits.forEach(unit => {
        const option = document.createElement('option');
        option.value = unit.name;
        option.textContent = unit.name;
        unitSelect.appendChild(option);
      });
    }

    document.addEventListener('DOMContentLoaded', async () => {
      await loadUnits();
      
      // Function to group items by name and unit
      function groupItems(items) {
        const groups = new Map();
        
        items.forEach(item => {
          const key = `${item.name.toLowerCase()}_${item.quantity.unit.toLowerCase()}`;
          
          if (groups.has(key)) {
            const existingGroup = groups.get(key);
            existingGroup.items.push(item);
            existingGroup.totalAmount += item.quantity.amount;
            existingGroup.allChecked = existingGroup.allChecked && item.isChecked;
            existingGroup.anyChecked = existingGroup.anyChecked || item.isChecked;
            
            // Combine descriptions (if different)
            if (item.description && !existingGroup.descriptions.includes(item.description)) {
              existingGroup.descriptions.push(item.description);
            }
          } else {
            groups.set(key, {
              name: item.name,
              unit: item.quantity.unit,
              totalAmount: item.quantity.amount,
              items: [item],
              allChecked: item.isChecked,
              anyChecked: item.isChecked,
              descriptions: item.description ? [item.description] : []
            });
          }
        });
        
        return Array.from(groups.values());
      }
      
      // Function to render shopping items
      function renderShoppingItems() {
        const container = document.getElementById('shopping-items');
        if (!container) return;
        
        const groupedItems = groupItems(shoppingListData.items);
        
        if (groupedItems.length === 0) {
          container.innerHTML = `
            <div class="text-center py-8 border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-lg">
              <svg class="w-12 h-12 mx-auto text-gray-400 mb-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M9 5H7a2 2 0 00-2 2v11a2 2 0 002 2h5.586a1 1 0 00.707-.293l5.414-5.414a1 1 0 00.293-.707V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"/>
              </svg>
              <p class="text-muted mb-2">Noch keine Artikel in der Einkaufsliste</p>
              <p class="text-sm text-muted">Klicken Sie auf "Artikel hinzufügen" um zu beginnen</p>
            </div>
          `;
          return;
        }
        
        container.innerHTML = groupedItems.map(group => {
          const isChecked = group.allChecked;
          const isPartiallyChecked = group.anyChecked && !group.allChecked;
          const itemIds = group.items.map(item => item.id).join(',');
          const recipeIds = [...new Set(group.items.map(item => item.recipeId).filter(Boolean))].join(',');
          const hasMultipleItems = group.items.length > 1;
          
          // Format amount (remove decimals if it's a whole number)
          const formattedAmount = group.totalAmount % 1 === 0 ? 
            group.totalAmount.toString() : 
            group.totalAmount.toFixed(1).replace(/\.0$/, '');
          
          // Create details for individual items if there are multiple
          const itemDetails = hasMultipleItems ? group.items.map((item, index) => {
            const itemAmount = item.quantity.amount % 1 === 0 ? 
              item.quantity.amount.toString() : 
              item.quantity.amount.toFixed(1).replace(/\.0$/, '');
            
            const sourceLabel = item.recipeId ? '🍳 Rezept' : '✋ Manuell';
            const sourceClass = item.recipeId ? 'text-blue-600 dark:text-blue-400' : 'text-gray-600 dark:text-gray-400';
            
            return `
              <div class="detail-item flex justify-between items-center py-1 px-2 text-sm transition-colors" data-item-id="${item.id}">
                <div class="flex items-center space-x-2">
                  <span class="${sourceClass} text-xs font-medium">${sourceLabel}</span>
                  ${item.description ? `<span class="text-gray-500">• ${item.description}</span>` : ''}
                </div>
                <span class="text-gray-700 dark:text-gray-300 font-mono">${itemAmount} ${item.quantity.unit}</span>
              </div>
            `;
          }).join('') : '';
          
          return `
            <div class="shopping-item-group" data-item-ids="${itemIds}" data-recipe-ids="${recipeIds}">
              <div class="shopping-item flex items-center space-x-3 p-3 hover:bg-gray-50 dark:hover:bg-gray-800 rounded-lg transition-colors ${hasMultipleItems ? 'cursor-pointer' : ''}" ${hasMultipleItems ? 'data-expandable="true"' : ''}>
                <input 
                  type="checkbox" 
                  class="item-checkbox w-5 h-5 text-green-600 bg-gray-100 border-gray-300 rounded focus:ring-green-500 focus:ring-2 ${isPartiallyChecked ? 'opacity-50' : ''}"
                  ${isChecked ? 'checked' : ''}
                  title="${isPartiallyChecked ? 'Teilweise erledigt' : ''}"
                />
                <div class="flex-1 min-w-0">
                  <div class="flex-between">
                    <div class="flex items-center space-x-2">
                      <span class="font-medium transition-colors ${
                        isChecked 
                          ? 'text-green-800 dark:text-green-300 line-through' 
                          : 'text-gray-900 dark:text-white'
                      }">
                        ${group.name}
                        ${hasMultipleItems ? `<span class="text-xs text-gray-500 ml-1">(${group.items.length}x)</span>` : ''}
                      </span>
                      ${recipeIds ? `
                        <button class="recipe-highlight-btn w-5 h-5 text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200 transition-colors" 
                                data-recipe-ids="${recipeIds}" 
                                title="Rezept hervorheben">
                          <svg class="w-full h-full" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.746 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"/>
                          </svg>
                        </button>
                      ` : ''}
                      ${hasMultipleItems ? `
                        <svg class="expand-icon w-4 h-4 text-gray-400 transition-transform duration-200" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/>
                        </svg>
                      ` : ''}
                    </div>
                    <span class="${isChecked 
                      ? 'text-sm text-green-700 dark:text-green-300 bg-green-100 dark:bg-green-800 px-2 py-1 rounded'
                      : 'quantity-badge'
                    }">
                      ${formattedAmount} ${group.unit}
                    </span>
                  </div>
                  ${group.descriptions.length > 0 ? `
                    <p class="text-sm mt-1 transition-colors ${
                      isChecked 
                        ? 'text-green-700 dark:text-green-300 line-through' 
                        : 'text-muted'
                    }">
                      ${group.descriptions.join(', ')}
                    </p>
                  ` : ''}
                </div>
              </div>
              ${hasMultipleItems ? `
                <div class="item-details hidden mt-2 ml-8 mr-4 bg-gray-50 dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700">
                  <div class="p-3">
                    <div class="text-xs font-medium text-gray-500 dark:text-gray-400 mb-2 uppercase tracking-wide">Einzelne Mengen:</div>
                    ${itemDetails}
                  </div>
                </div>
              ` : ''}
            </div>
          `;
        }).join('');
        
        // Re-attach event listeners
        attachCheckboxListeners();
        attachExpandListeners();
        attachRecipeHighlightListeners();
        
        // Restore highlights if any recipe was selected
        if (currentlyHighlightedRecipe) {
          highlightRecipeIngredients(currentlyHighlightedRecipe);
        }
      }
      
             // Function to attach expand/collapse listeners
       function attachExpandListeners() {
         document.querySelectorAll('[data-expandable="true"]').forEach(item => {
           item.addEventListener('click', (e) => {
             // Don't expand if clicking on checkbox
             if (e.target.closest('.item-checkbox')) {
               return;
             }
             
             const group = item.closest('.shopping-item-group');
             const details = group.querySelector('.item-details');
             const expandIcon = item.querySelector('.expand-icon');
             
             if (details && expandIcon) {
               const isExpanded = !details.classList.contains('hidden');
               
               if (isExpanded) {
                 // Collapse
                 details.classList.add('hidden');
                 expandIcon.style.transform = 'rotate(0deg)';
               } else {
                 // Expand
                 details.classList.remove('hidden');
                 expandIcon.style.transform = 'rotate(180deg)';
               }
             }
           });
         });
       }
       
       // Function to attach recipe highlight listeners
       function attachRecipeHighlightListeners() {
         document.querySelectorAll('.recipe-highlight-btn').forEach(btn => {
           btn.addEventListener('click', (e) => {
             e.stopPropagation(); // Prevent expanding/collapsing
             
             const recipeIds = btn.getAttribute('data-recipe-ids');
             if (recipeIds) {
               // For items linked to multiple recipes, use the first one
               const recipeId = recipeIds.split(',')[0];
               toggleRecipeHighlight(recipeId);
             }
           });
         });
       }
       
       // Function to attach checkbox event listeners
       function attachCheckboxListeners() {
         document.querySelectorAll('.item-checkbox').forEach(checkbox => {
          checkbox.addEventListener('change', async (e) => {
          const target = e.target;
          const itemElement = target.closest('.shopping-item-group');
          const itemIdsAttr = itemElement.getAttribute('data-item-ids');
          if (!itemIdsAttr) {
            console.error('No data-item-ids found on element:', itemElement);
            return;
          }
          const itemIds = itemIdsAttr.split(',');
          const isChecked = target.checked;

          try {
            // Update all items in the group
            const updatedItems = shoppingListData.items.map(item => 
              itemIds.includes(item.id) ? { ...item, isChecked } : item
            );

            const response = await fetch(`/api/shopping-lists?id=${shoppingListId}`, {
              method: 'PUT',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                items: updatedItems
              }),
            });

            if (response.ok) {
              // Update local data
              shoppingListData.items = updatedItems;
              
              // Re-render the items to show updated grouping
              renderShoppingItems();
              
              // Update header counter
              updateHeaderCounters();
            } else {
              // Revert checkbox if API call failed
              target.checked = !isChecked;
              
              const error = await response.json();
              console.error('Error updating item:', error);
              alert('Fehler beim Aktualisieren des Artikels');
            }
          } catch (error) {
            console.error('Error updating item:', error);
            
            // Revert checkbox if API call failed
            target.checked = !isChecked;
            
            alert('Fehler beim Aktualisieren des Artikels');
          }
        });
      });
      }
      
      // Initial render
      renderShoppingItems();



      // Function to update header counters
      function updateHeaderCounters() {
        const uncheckedCount = shoppingListData.items.filter(item => !item.isChecked).length;
        const totalCount = shoppingListData.items.length;
        
        // Update counter in header
        const counterElement = document.querySelector('p.text-sm.text-muted');
        if (counterElement) {
          counterElement.textContent = `${uncheckedCount} von ${totalCount} Artikeln offen`;
        }
        
        // Update main heading counter for items section only
        const itemsHeadingElement = document.getElementById('items-heading');
        if (itemsHeadingElement) {
          itemsHeadingElement.textContent = `Einkaufsliste (${totalCount} Artikel)`;
        }
      }

      // Add item modal handling
      const addItemBtn = document.getElementById('add-item-btn');
      const addItemModal = document.getElementById('add-item-modal');
      const addItemForm = document.getElementById('add-item-form');
      const closeButtons = addItemModal?.querySelectorAll('.modal-close');

      addItemBtn?.addEventListener('click', () => {
        addItemModal?.classList.remove('hidden');
        document.getElementById('item-name')?.focus();
      });

      closeButtons?.forEach(btn => {
        btn.addEventListener('click', () => {
          addItemModal?.classList.add('hidden');
          addItemForm?.reset();
        });
      });

      addItemModal?.querySelector('.modal-overlay')?.addEventListener('click', () => {
        addItemModal?.classList.add('hidden');
        addItemForm?.reset();
      });

      addItemForm?.addEventListener('submit', async (e) => {
        e.preventDefault();
        
        const formData = new FormData(addItemForm);
        const name = formData.get('name');
        const amount = parseFloat(formData.get('amount'));
        const unit = formData.get('unit');
        const description = formData.get('description');

        if (!name.trim() || !amount || !unit.trim()) {
          alert('Bitte füllen Sie alle Pflichtfelder aus.');
          return;
        }

        try {
          const response = await fetch(`/api/shopping-lists?id=${shoppingListId}`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              action: 'add-item',
              item: {
                name: name.trim(),
                quantity: { amount, unit: unit.trim() },
                description: description.trim() || undefined,
                isChecked: false
              }
            }),
          });

          if (response.ok) {
            const updatedList = await response.json();
            shoppingListData.items = updatedList.items;
            
            // Re-render the items to show new item
            renderShoppingItems();
            updateHeaderCounters();
            
            // Close modal and reset form
            addItemModal?.classList.add('hidden');
            addItemForm?.reset();
          } else {
            const error = await response.json();
            alert(error.error || 'Fehler beim Hinzufügen des Artikels');
          }
        } catch (error) {
          console.error('Error adding item:', error);
          alert('Fehler beim Hinzufügen des Artikels');
        }
      });

      // Helper functions for recipe data structure
      function getRecipeIngredients(recipe) {
        const ingredients = [];
        
        function extractIngredientsFromGroup(group) {
          if (group.ingredients) {
            group.ingredients.forEach(item => {
              if (item.ingredients) {
                // It's a nested group
                extractIngredientsFromGroup(item);
              } else if (item.name) {
                // It's an ingredient
                ingredients.push(item);
              }
            });
          }
        }
        
        if (recipe.ingredientGroups) {
          recipe.ingredientGroups.forEach(group => extractIngredientsFromGroup(group));
        }
        
        return ingredients;
      }

      function getRecipeIngredientCount(recipe) {
        return getRecipeIngredients(recipe).length;
      }

      function toggleRecipeHighlight(recipeId) {
        // Clear existing highlights
        clearRecipeHighlights();
        
        if (currentlyHighlightedRecipe === recipeId) {
          // If same recipe clicked, just clear highlights
          currentlyHighlightedRecipe = null;
          return;
        }
        
        // Set new highlight
        currentlyHighlightedRecipe = recipeId;
        highlightRecipeIngredients(recipeId);
      }

      function clearRecipeHighlights() {
        // Remove all highlights from shopping item groups
        document.querySelectorAll('.shopping-item-group').forEach(group => {
          group.classList.remove('highlighted');
          
          // Collapse any expanded groups
          const expandableItem = group.querySelector('[data-expandable="true"]');
          if (expandableItem) {
            const details = group.querySelector('.item-details');
            const expandIcon = group.querySelector('.expand-icon');
            
            if (details && expandIcon) {
              // Collapse the group
              details.classList.add('hidden');
              expandIcon.style.transform = 'rotate(0deg)';
            }
          }
        });
        
        // Remove highlights from individual detail items
        document.querySelectorAll('.detail-item-highlighted').forEach(item => {
          item.classList.remove('detail-item-highlighted');
        });
        
        // Remove active state from recipe cards
        document.querySelectorAll('.recipe-item').forEach(card => {
          card.classList.remove('active');
        });
      }

      function highlightRecipeIngredients(recipeId) {
        // Find all shopping item groups that belong to this recipe
        document.querySelectorAll('.shopping-item-group').forEach(group => {
          const recipeIds = group.getAttribute('data-recipe-ids');
          if (recipeIds && recipeIds.split(',').includes(recipeId)) {
            group.classList.add('highlighted');
            
            // Auto-expand groups that have multiple items
            const expandableItem = group.querySelector('[data-expandable="true"]');
            if (expandableItem) {
              const details = group.querySelector('.item-details');
              const expandIcon = group.querySelector('.expand-icon');
              
              if (details && expandIcon) {
                // Expand the group
                details.classList.remove('hidden');
                expandIcon.style.transform = 'rotate(180deg)';
                
                // Highlight individual items from this recipe in the details
                highlightIndividualItems(group, recipeId);
              }
            }
          }
        });
        
        // Mark recipe card as active by finding it by title
        const recipe = shoppingListData.recipes?.find(r => r.id === recipeId);
        if (recipe) {
          document.querySelectorAll('.recipe-item').forEach(card => {
            const cardTitle = card.querySelector('h3')?.textContent?.trim();
            if (cardTitle === recipe.title) {
              card.classList.add('active');
            }
          });
        }
      }
      
      function highlightIndividualItems(group, recipeId) {
        // Highlight individual detail items that belong to this recipe
        const details = group.querySelector('.item-details');
        if (details) {
          const detailItems = details.querySelectorAll('.detail-item');
          
          detailItems.forEach(detailItem => {
            const itemId = detailItem.getAttribute('data-item-id');
            const item = shoppingListData.items.find(item => item.id === itemId);
            
            if (item && item.recipeId === recipeId) {
              detailItem.classList.add('detail-item-highlighted');
            }
          });
        }
      }

      // Load recipes for modal
      async function loadRecipes() {
        try {
          const response = await fetch('/api/recipes');
          if (response.ok) {
            availableRecipes = await response.json();
            populateRecipeModal();
          }
        } catch (error) {
          console.error('Error loading recipes:', error);
        }
      }

      // Populate recipe modal
      function populateRecipeModal() {
        const recipeLoading = document.getElementById('recipe-loading');
        const recipeList = document.getElementById('recipe-list');
        const availableRecipesContainer = document.getElementById('available-recipes');
        const noRecipesFound = document.getElementById('no-recipes-found');
        
        recipeLoading?.classList.add('hidden');
        recipeList?.classList.remove('hidden');
        
        if (availableRecipes.length === 0) {
          availableRecipesContainer.innerHTML = '';
          noRecipesFound?.classList.remove('hidden');
          return;
        }
        
        noRecipesFound?.classList.add('hidden');
        renderAvailableRecipes(availableRecipes);
      }

      // Render available recipes
      function renderAvailableRecipes(recipes) {
        const container = document.getElementById('available-recipes');
        if (!container) return;
        
        // Get already added recipe IDs
        const addedRecipeIds = new Set(shoppingListData.recipes?.map(r => r.id) || []);
        
        container.innerHTML = recipes.map(recipe => {
          const isAlreadyAdded = addedRecipeIds.has(recipe.id);
          const cardClasses = isAlreadyAdded 
            ? 'recipe-card border border-gray-200 dark:border-gray-700 rounded-lg p-4 bg-gray-100 dark:bg-gray-800 opacity-50 cursor-not-allowed transition-colors'
            : 'recipe-card border border-gray-300 dark:border-gray-600 rounded-lg p-4 hover:border-orange-500 cursor-pointer transition-colors';
          
          return `
            <div class="${cardClasses}" data-recipe-id="${recipe.id}">
              <div class="flex items-start space-x-3">
                ${!isAlreadyAdded ? `
                  <input type="checkbox" class="recipe-checkbox mt-1 w-5 h-5 text-orange-600 bg-gray-100 border-gray-300 rounded focus:ring-orange-500 focus:ring-2" data-recipe-id="${recipe.id}" />
                ` : `
                  <div class="mt-1 w-5 h-5 bg-gray-300 dark:bg-gray-600 rounded flex items-center justify-center">
                    <svg class="w-3 h-3 text-gray-500" fill="currentColor" viewBox="0 0 24 24">
                      <path d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                    </svg>
                  </div>
                `}
                ${recipe.images && recipe.images.length > 0 
                  ? `<img src="${recipe.images[0].url}" alt="${recipe.title}" class="w-16 h-16 object-cover rounded-lg ${isAlreadyAdded ? 'grayscale' : ''}">`
                  : `<div class="w-16 h-16 bg-gray-200 dark:bg-gray-700 rounded-lg flex items-center justify-center">
                       <svg class="w-8 h-8 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                         <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"/>
                       </svg>
                     </div>`
                }
                <div class="flex-1 min-w-0">
                  <h3 class="font-medium ${isAlreadyAdded ? 'text-gray-500 dark:text-gray-400' : 'text-gray-900 dark:text-white'} truncate">
                    ${recipe.title}
                    ${isAlreadyAdded ? '<span class="text-xs ml-2 bg-green-100 dark:bg-green-800 text-green-800 dark:text-green-200 px-2 py-0.5 rounded">Bereits hinzugefügt</span>' : ''}
                  </h3>
                  <p class="text-sm text-muted mt-1">${getRecipeIngredientCount(recipe)} Zutaten</p>
                  ${recipe.description ? `<p class="text-sm text-muted mt-1 line-clamp-2">${recipe.description}</p>` : ''}
                </div>
              </div>
            </div>
          `;
        }).join('');
        
        // Attach change handlers for checkboxes
        container.querySelectorAll('.recipe-checkbox').forEach(checkbox => {
          checkbox.addEventListener('change', updateSelectedCount);
        });
        
        // Update selected count
        updateSelectedCount();
      }

      // Update selected count and button state
      function updateSelectedCount() {
        const selectedCheckboxes = document.querySelectorAll('.recipe-checkbox:checked');
        const selectedCount = selectedCheckboxes.length;
        const selectedCountElement = document.getElementById('selected-count');
        const addSelectedButton = document.getElementById('add-selected-recipes');
        const selectAllCheckbox = document.getElementById('select-all-recipes');
        
        // Update count display
        if (selectedCountElement) {
          selectedCountElement.textContent = `${selectedCount} Rezept${selectedCount !== 1 ? 'e' : ''} ausgewählt`;
        }
        
        // Update add button state
        if (addSelectedButton) {
          addSelectedButton.disabled = selectedCount === 0;
        }
        
        // Update select all checkbox state
        const allCheckboxes = document.querySelectorAll('.recipe-checkbox');
        if (selectAllCheckbox && allCheckboxes.length > 0) {
          selectAllCheckbox.checked = selectedCount === allCheckboxes.length;
          selectAllCheckbox.indeterminate = selectedCount > 0 && selectedCount < allCheckboxes.length;
        }
      }

      // Search recipes
      const recipeSearch = document.getElementById('recipe-search');
      recipeSearch?.addEventListener('input', (e) => {
        const searchTerm = e.target.value.toLowerCase();
        const filteredRecipes = availableRecipes.filter(recipe => 
          recipe.title.toLowerCase().includes(searchTerm) ||
          recipe.description?.toLowerCase().includes(searchTerm) ||
          getRecipeIngredients(recipe).some(ing => ing.name.toLowerCase().includes(searchTerm))
        );
        renderAvailableRecipes(filteredRecipes);
      });

      // Add multiple recipes to shopping list
      async function addMultipleRecipesToShoppingList(recipeIds) {
        try {
          // Add recipes one by one (we could optimize this later with a batch API)
          for (const recipeId of recipeIds) {
            const response = await fetch(`/api/shopping-lists?id=${shoppingListId}`, {
              method: 'PUT',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                action: 'add-recipe',
                recipeId: recipeId
              }),
            });

            if (!response.ok) {
              const error = await response.json();
              throw new Error(error.error || `Fehler beim Hinzufügen von Rezept ${recipeId}`);
            }
          }

          // Reload the shopping list to get all updates
          const response = await fetch(`/api/shopping-lists?id=${shoppingListId}`);
          if (response.ok) {
            const updatedList = await response.json();
            shoppingListData.items = updatedList.items;
            shoppingListData.recipes = updatedList.recipes || [];
            
            // Re-render everything
            renderShoppingItems();
            renderShoppingRecipes();
            updateHeaderCounters();
            
            // Re-render recipe modal to show updated state
            renderAvailableRecipes(availableRecipes);
            
            // Show success message
            const recipeCount = recipeIds.length;
            alert(`${recipeCount} Rezept${recipeCount !== 1 ? 'e wurden' : ' wurde'} zur Einkaufsliste hinzugefügt!`);
          }
        } catch (error) {
          console.error('Error adding recipes:', error);
          alert('Fehler beim Hinzufügen der Rezepte: ' + error.message);
        }
      }

      // Add single recipe to shopping list (legacy function for compatibility)
      async function addRecipeToShoppingList(recipeId) {
        await addMultipleRecipesToShoppingList([recipeId]);
      }

      // Render shopping recipes
      function renderShoppingRecipes() {
        const recipesSection = document.getElementById('shopping-recipes-section');
        const recipesContainer = document.getElementById('shopping-recipes');
        
        if (!shoppingListData.recipes || shoppingListData.recipes.length === 0) {
          recipesSection?.style.setProperty('display', 'none');
          return;
        }
        
        recipesSection?.style.setProperty('display', 'block');
        
        if (!recipesContainer) return;
        
        recipesContainer.innerHTML = shoppingListData.recipes.map(recipe => {
          // Count items from this recipe in the shopping list
          const recipeItemCount = shoppingListData.items.filter(item => item.recipeId === recipe.id).length;
          
          return `
          <div class="recipe-item border border-gray-300 dark:border-gray-600 rounded-lg p-4 cursor-pointer hover:shadow-sm transition-all" title="Klicken um Zutaten hervorzuheben">
            <div class="flex items-start justify-between">
              <div class="flex items-start space-x-3 flex-1 min-w-0">
                                 ${recipe.images && recipe.images.length > 0 
                   ? `<img src="${recipe.images[0].url}" alt="${recipe.title}" class="w-12 h-12 object-cover rounded-lg">`
                  : `<div class="w-12 h-12 bg-gray-200 dark:bg-gray-700 rounded-lg flex items-center justify-center">
                       <svg class="w-6 h-6 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                         <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.746 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"/>
                       </svg>
                     </div>`
                }
                <div class="flex-1 min-w-0">
                  <h3 class="font-medium text-gray-900 dark:text-white truncate">${recipe.title}</h3>
                  <p class="text-sm text-muted">${recipeItemCount} Zutaten in der Liste</p>
                  <p class="text-xs text-blue-600 dark:text-blue-400 mt-1 opacity-75">Klicken zum Hervorheben</p>
                </div>
              </div>
              <div class="flex items-center space-x-2">
                <a href="/rezept/${recipe.id}" class="btn btn-sm btn-ghost" title="Rezept anzeigen">
                  <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/>
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"/>
                  </svg>
                </a>
                <span class="btn btn-sm btn-ghost text-gray-400 cursor-not-allowed" title="Rezepte können nur im Bearbeitungsmodus entfernt werden">
                  <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M18.364 18.364A9 9 0 005.636 5.636m12.728 12.728L5.636 5.636m12.728 12.728L18.364 5.636M5.636 18.364l12.728-12.728"/>
                  </svg>
                </span>
              </div>
            </div>
          </div>
        `;
        }).join('');
        
        // Note: Recipe removal is disabled in view mode - only available in edit mode

        // Attach click handlers for recipe highlighting
        recipesContainer.querySelectorAll('.recipe-item').forEach(recipeCard => {
          recipeCard.addEventListener('click', (e) => {
            // Don't trigger if clicking on action buttons
            if (e.target.closest('button') || e.target.closest('a')) {
              return;
            }
            
            // Find recipe ID from the recipe data
            const recipeTitle = recipeCard.querySelector('h3')?.textContent?.trim();
            const recipe = shoppingListData.recipes?.find(r => r.title === recipeTitle);
            const recipeId = recipe?.id;
            
            if (recipeId) {
              toggleRecipeHighlight(recipeId);
            }
          });
        });
      }

      // Remove recipe from shopping list
      async function removeRecipeFromShoppingList(recipeId) {
        // Wait for modal functions to be available
        let attempts = 0;
        while (!window.showDeleteConfirm && attempts < 10) {
          await new Promise(resolve => setTimeout(resolve, 200));
          attempts++;
        }

        let confirmed = false;
        if (window.showDeleteConfirm) {
          confirmed = await window.showDeleteConfirm('Sollen die Zutaten dieses Rezepts aus der Einkaufsliste entfernt werden?');
        } else {
          confirmed = confirm('Sollen die Zutaten dieses Rezepts aus der Einkaufsliste entfernt werden?');
        }
        
        if (!confirmed) {
          return;
        }
        
        try {
          const response = await fetch(`/api/shopping-lists?id=${shoppingListId}`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              action: 'remove-recipe',
              recipeId: recipeId
            }),
          });

          if (response.ok) {
            const updatedList = await response.json();
            shoppingListData.items = updatedList.items;
            shoppingListData.recipes = updatedList.recipes || [];
            
            // Re-render items and recipes
            renderShoppingItems();
            renderShoppingRecipes();
            updateHeaderCounters();
          } else {
            const error = await response.json();
            alert(error.error || 'Fehler beim Entfernen des Rezepts');
          }
        } catch (error) {
          console.error('Error removing recipe:', error);
          alert('Fehler beim Entfernen des Rezepts');
        }
      }

      // Add recipe modal handling
      const addRecipeBtn = document.getElementById('add-recipe-btn');
      const addRecipeModal = document.getElementById('add-recipe-modal');
      const addRecipeCloseButtons = addRecipeModal?.querySelectorAll('.modal-close');

      addRecipeBtn?.addEventListener('click', async () => {
        addRecipeModal?.classList.remove('hidden');
        
        // Load recipes if not already loaded
        if (availableRecipes.length === 0) {
          await loadRecipes();
        }
      });

      addRecipeCloseButtons?.forEach(btn => {
        btn.addEventListener('click', () => {
          addRecipeModal?.classList.add('hidden');
          document.getElementById('recipe-search').value = '';
          renderAvailableRecipes(availableRecipes);
          clearAllSelections();
        });
      });

      addRecipeModal?.querySelector('.modal-overlay')?.addEventListener('click', () => {
        addRecipeModal?.classList.add('hidden');
        document.getElementById('recipe-search').value = '';
        renderAvailableRecipes(availableRecipes);
        clearAllSelections();
      });

      // Handle select all checkbox
      const selectAllCheckbox = document.getElementById('select-all-recipes');
      selectAllCheckbox?.addEventListener('change', (e) => {
        const checkboxes = document.querySelectorAll('.recipe-checkbox');
        checkboxes.forEach(checkbox => {
          checkbox.checked = e.target.checked;
        });
        updateSelectedCount();
      });

      // Handle add selected recipes button
      const addSelectedButton = document.getElementById('add-selected-recipes');
      addSelectedButton?.addEventListener('click', async () => {
        const selectedCheckboxes = document.querySelectorAll('.recipe-checkbox:checked');
        const selectedRecipeIds = Array.from(selectedCheckboxes).map(checkbox => 
          checkbox.getAttribute('data-recipe-id')
        );
        
        if (selectedRecipeIds.length > 0) {
          await addMultipleRecipesToShoppingList(selectedRecipeIds);
          clearAllSelections();
        }
      });

      // Helper function to clear all selections
      function clearAllSelections() {
        document.querySelectorAll('.recipe-checkbox').forEach(checkbox => {
          checkbox.checked = false;
        });
        const selectAllCheckbox = document.getElementById('select-all-recipes');
        if (selectAllCheckbox) {
          selectAllCheckbox.checked = false;
          selectAllCheckbox.indeterminate = false;
        }
        updateSelectedCount();
      }

      // Initial render of recipes
      renderShoppingRecipes();
      
      // Setup Server-Sent Events for real-time updates
      let eventSource = null;
      let reconnectTimer = null;
      let isOnline = navigator.onLine;
      
      function connectSSE() {
        if (eventSource) {
          eventSource.close();
        }
        
        try {
          eventSource = new EventSource(`/api/shopping-lists/stream?listId=${shoppingListId}`);
          
          eventSource.onopen = () => {
            console.log('✅ Real-time sync connected');
            // Clear any reconnect timer
            if (reconnectTimer) {
              clearTimeout(reconnectTimer);
              reconnectTimer = null;
            }
            // Show online indicator
            showSyncStatus('online');
          };
          
          eventSource.onmessage = (event) => {
            try {
              const data = JSON.parse(event.data);
              
              if (data.type === 'connected') {
                console.log('Connected to shopping list updates');
              } else if (data.type === 'update') {
                // Update received from another client
                console.log('📱 Real-time update received');
                updateFromServer(data.data);
                showSyncStatus('synced');
              }
            } catch (error) {
              console.error('Error parsing SSE message:', error);
            }
          };
          
          eventSource.onerror = (error) => {
            console.log('❌ Real-time sync disconnected');
            showSyncStatus('offline');
            
            // Attempt to reconnect after delay
            if (!reconnectTimer) {
              reconnectTimer = setTimeout(() => {
                if (isOnline) {
                  console.log('🔄 Attempting to reconnect...');
                  connectSSE();
                }
              }, 3000);
            }
          };
          
        } catch (error) {
          console.error('Error setting up SSE:', error);
          showSyncStatus('offline');
        }
      }
      
      function updateFromServer(updatedList) {
        // Only update if data is different
        const currentItemsJson = JSON.stringify(shoppingListData.items);
        const newItemsJson = JSON.stringify(updatedList.items);
        const currentRecipesJson = JSON.stringify(shoppingListData.recipes);
        const newRecipesJson = JSON.stringify(updatedList.recipes);
        
        if (currentItemsJson !== newItemsJson || currentRecipesJson !== newRecipesJson) {
          shoppingListData.items = updatedList.items;
          shoppingListData.recipes = updatedList.recipes || [];
          
          // Re-render everything
          renderShoppingItems();
          renderShoppingRecipes();
          updateHeaderCounters();
        }
      }
      
      function showSyncStatus(status) {
        let indicator;
        
        // Remove any existing sync status indicators
        document.querySelectorAll('.sync-status').forEach(el => el.remove());
        
        // Create new indicator based on status
        if (status === 'online') {
          indicator = '<span class="sync-status text-xs text-green-600 dark:text-green-400 flex items-center space-x-1"><span class="w-2 h-2 bg-green-500 rounded-full"></span><span>Live</span></span>';
        } else if (status === 'synced') {
          indicator = '<span class="sync-status text-xs text-blue-600 dark:text-blue-400 flex items-center space-x-1"><span class="w-2 h-2 bg-blue-500 rounded-full animate-pulse"></span><span>Synchronisiert</span></span>';
          // Hide synced indicator after 2 seconds and restore live indicator
          setTimeout(() => {
            document.querySelector('.sync-status')?.remove();
            showSyncStatus('online');
          }, 2000);
        } else {
          indicator = '<span class="sync-status text-xs text-red-600 dark:text-red-400 flex items-center space-x-1"><span class="w-2 h-2 bg-red-500 rounded-full"></span><span>Offline</span></span>';
        }
        
        // Insert the indicator into the container
        const container = document.getElementById('sync-status-container');
        if (container) {
          container.innerHTML = indicator;
        }
      }
      
      // Handle online/offline status
      window.addEventListener('online', () => {
        isOnline = true;
        connectSSE();
      });
      
      window.addEventListener('offline', () => {
        isOnline = false;
        showSyncStatus('offline');
        if (eventSource) {
          eventSource.close();
          eventSource = null;
        }
      });
      
      // Setup SSE connection
      if (isOnline) {
        connectSSE();
      }
      
      // Cleanup on page unload
      window.addEventListener('beforeunload', () => {
        if (eventSource) {
          eventSource.close();
        }
        if (reconnectTimer) {
          clearTimeout(reconnectTimer);
        }
      });
    });
  </script>
</Layout> 