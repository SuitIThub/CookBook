---
export const prerender = false;
import Layout from '../../layouts/Layout.astro';
import { db } from '../../lib/database';
import type { ShoppingList } from '../../types/recipe';
import GroupingSuggestionModal from '../../components/shopping_list/GroupingSuggestionModal.astro';
import ViewNotesModal from '../../components/modals/ViewNotesModal.astro';
import AddNoteModal from '../../components/modals/AddNoteModal.astro';
import ImageGalleryModal from '../../components/modals/ImageGalleryModal.astro';

const { id } = Astro.params;

if (!id) {
  return Astro.redirect('/einkaufslisten');
}

// Einkaufsliste laden
let shoppingList: ShoppingList | null = null;
try {
  shoppingList = db.getShoppingList(id);
} catch (error) {
  console.error('Error loading shopping list:', error);
}

if (!shoppingList) {
  return Astro.redirect('/einkaufslisten');
}

// Für normale Listen: prüfen ob die Sammelliste Einträge hat (für Transfer-Hinweis)
let permanentListSummary: { itemCount: number; recipeCount: number } | null = null;
if (!shoppingList.isPermanent) {
  const permanentList = db.getPermanentShoppingList();
  if (permanentList && (permanentList.items.length > 0 || (permanentList.recipes?.length ?? 0) > 0)) {
    permanentListSummary = {
      itemCount: permanentList.items.length,
      recipeCount: permanentList.recipes?.length ?? 0
    };
  }
}

// Für normale Listen: prüfen, ob globale Vorlage Einträge hat und ob der Hinweis schon gezeigt wurde
let globalTemplateSummary: { itemCount: number; recipeCount: number } | null = null;
if (!shoppingList.isPermanent && !shoppingList.hasSeenGlobalTemplatePrompt) {
  const globalTemplate = db.getGlobalTemplateShoppingList();
  if (globalTemplate && (globalTemplate.items.length > 0 || (globalTemplate.recipes?.length ?? 0) > 0)) {
    globalTemplateSummary = {
      itemCount: globalTemplate.items.length,
      recipeCount: globalTemplate.recipes?.length ?? 0
    };
  }
}

// Query-Parameter für Edit-Modus überprüfen
const url = new URL(Astro.request.url);
const isEditMode = url.searchParams.get('edit') === 'true';

const checkedItems = shoppingList.items.filter(item => item.isChecked);
const uncheckedItems = shoppingList.items.filter(item => !item.isChecked);
---

<Layout title={`${shoppingList.title} - Einkaufsliste`}>
  <div class="container-narrow">
    <!-- Header -->
    <div class="mb-6">
      <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4 sm:gap-0 mb-4">
        <div class="flex items-center space-x-3">
          <a href="/einkaufslisten" class="btn btn-ghost btn-sm flex items-center space-x-2">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
            </svg>
            <span>Zurück</span>
          </a>
          <!-- Sync status will be inserted here by JavaScript -->
          <div id="sync-status-container"></div>
        </div>
        <div class="flex flex-col sm:flex-row gap-2 sm:space-x-2 w-full sm:w-auto">
          <button id="add-item-btn" class="btn btn-success flex items-center justify-center space-x-2">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"/>
            </svg>
            <span class="hidden xs:inline">Artikel hinzufügen</span>
            <span class="xs:hidden">Artikel hinzufügen</span>
          </button>
          <button id="add-recipe-btn" class="btn btn-blue flex items-center justify-center space-x-2">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.746 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"/>
            </svg>
            <span class="hidden xs:inline">Rezept hinzufügen</span>
            <span class="xs:hidden">Rezept hinzufügen</span>
          </button>
          <button id="share-list-btn" class="btn btn-secondary flex items-center justify-center space-x-2">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.367 2.684 3 3 0 00-5.367-2.684z"/>
            </svg>
            <span class="hidden xs:inline">Teilen</span>
            <span class="xs:hidden">Teilen</span>
          </button>
          <a href={`/einkaufsliste/${id}/edit`} class="btn btn-secondary flex items-center justify-center space-x-2">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"/>
            </svg>
            <span class="hidden xs:inline">Bearbeiten</span>
            <span class="xs:hidden">Bearbeiten</span>
          </a>
          {shoppingList.isPermanent && (
            <button type="button" id="apply-permanent-to-list-btn" class="btn btn-primary flex items-center justify-center space-x-2" title={shoppingList.permanentType === 2 ? 'Inhalt zu einer Einkaufsliste hinzufügen (Kopie)' : 'Inhalt in eine Einkaufsliste übernehmen (wird hier entfernt)'}>
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7h12m0 0l-4-4m4 4l-4 4m0 6H4m0 0l4 4m-4-4l4-4"/>
              </svg>
              <span class="hidden xs:inline">{shoppingList.permanentType === 2 ? 'Zu Liste hinzufügen' : 'In Liste übernehmen'}</span>
              <span class="xs:hidden">{shoppingList.permanentType === 2 ? 'Zu Liste' : 'Übernehmen'}</span>
            </button>
          )}
        </div>
      </div>
      <div>
        <h1 class="heading-primary">{shoppingList.title}</h1>
        {shoppingList.description && (
          <p class="text-muted mt-1">
            {shoppingList.description}
          </p>
        )}
        <p class="text-sm text-muted mt-1">
          {uncheckedItems.length} von {shoppingList.items.length} Artikeln offen
        </p>
      </div>
    </div>

    <!-- Transfer from permanent list banner (only for normal lists when permanent has content) -->
    {permanentListSummary && (
      <div id="transfer-from-permanent-banner" class="mb-4 p-4 rounded-lg border border-primary-200 dark:border-primary-700 bg-primary-50 dark:bg-primary-900/20">
        <p class="text-sm text-gray-700 dark:text-gray-300 mb-3">
          Auf Ihrer <strong>Sammelliste</strong> befinden sich {permanentListSummary.itemCount} Artikel und {permanentListSummary.recipeCount} Rezept{permanentListSummary.recipeCount !== 1 ? 'e' : ''}. Möchten Sie diese in diese Einkaufsliste übernehmen?
        </p>
        <div class="flex flex-wrap gap-2">
          <button type="button" id="transfer-from-permanent-btn" class="btn btn-primary btn-sm">
            In diese Liste übernehmen
          </button>
          <button type="button" id="dismiss-transfer-banner-btn" class="btn btn-ghost btn-sm text-muted">
            Später
          </button>
        </div>
      </div>
    )}

    <!-- Shopping List Recipes -->
    <div id="shopping-recipes-section" class="card" style="display: none;">
      <div class="card-content">
        <h2 class="heading-secondary mb-4">Rezepte</h2>
        <div id="shopping-recipes" class="space-y-3">
          <!-- Recipes will be populated by JavaScript -->
        </div>
      </div>
    </div>

    <!-- Recipe Template -->
    <template id="recipe-template">
      <div class="recipe-item border border-gray-300 dark:border-gray-600 rounded-lg p-4 cursor-pointer hover:shadow-sm transition-all" data-recipe-id="">
        <div class="flex flex-col gap-3">
          <div class="flex items-center justify-between">
            <h3 class="font-medium text-gray-900 dark:text-white recipe-title"></h3>
            <div class="flex items-center space-x-2 ml-4 flex-shrink-0">
              <a href="" class="recipe-link btn btn-sm btn-ghost recipe-action" title="Rezept anzeigen">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/>
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"/>
                </svg>
              </a>
              <button class="remove-recipe btn btn-sm btn-ghost text-gray-400 hover:text-red-500 recipe-action" title="Rezept entfernen">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                </svg>
              </button>
            </div>
          </div>
          <div class="flex-1 min-w-0">
              <p class="text-sm text-muted recipe-info"></p>
              <div class="flex flex-col sm:flex-row sm:items-center gap-2 sm:gap-4 mt-2">
                <div class="flex items-center space-x-2">
                  <label class="text-sm text-gray-600 dark:text-gray-400">Portionen:</label>
                  <div class="flex items-center space-x-1">
                    <button class="portion-decrease btn btn-icon btn-sm recipe-action" title="Portionen verringern">
                      <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 12H4"/>
                      </svg>
                    </button>
                    <input type="number" class="portion-input form-input form-input-sm w-16 text-center recipe-action" min="1" value="1" />
                    <button class="portion-increase btn btn-icon btn-sm recipe-action" title="Portionen erhöhen">
                      <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"/>
                      </svg>
                    </button>
                  </div>
                </div>
                <span class="text-sm text-gray-500">Originalportionen: <span class="original-servings"></span></span>
              </div>
              <p class="text-xs text-blue-600 dark:text-blue-400 mt-1 opacity-75">Klicken zum Hervorheben</p>
            </div>
          </div>
        </div>
      </div>
    </template>

    <!-- Hide Checked Items Toggle and Grouping Controls (hidden for permanent list: items cannot be checked) -->
    <div class="card mt-6">
      <div class="card-content">
        <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
          {!shoppingList.isPermanent && (
          <label class="flex items-center space-x-3 cursor-pointer">
            <input 
              type="checkbox" 
              id="hide-checked-items-toggle"
              class="w-5 h-5 text-primary-500 bg-gray-100 border-gray-300 rounded focus:ring-primary-500 focus:ring-2"
            />
            <span class="text-sm font-medium text-gray-700 dark:text-gray-300">
              Erledigte Artikel ausblenden
            </span>
          </label>
          )}
          {shoppingList.isPermanent && <div />}
          <div class="flex items-center gap-2">
            <button id="suggest-grouping-btn" class="btn btn-secondary btn-sm flex items-center space-x-2">
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"/>
              </svg>
              <span>Gruppierung vorschlagen</span>
            </button>
            <button id="group-items-btn" class="btn btn-secondary btn-sm flex items-center space-x-2">
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z"/>
              </svg>
              <span>Gruppieren</span>
            </button>
            <button id="ungroup-items-btn" class="btn btn-secondary btn-sm flex items-center space-x-2" style="display: none;">
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7h12m0 0l-4-4m4 4l-4 4m0 6H4m0 0l4 4m-4-4l4-4"/>
              </svg>
              <span>Gruppierung aufheben</span>
            </button>
            <div id="group-selection-controls" class="hidden flex items-center gap-2">
              <button id="confirm-group-btn" class="btn btn-success btn-sm" disabled>
                Gruppierung bestätigen
              </button>
              <button id="cancel-group-btn" class="btn btn-secondary btn-sm">
                Abbrechen
              </button>
              <span id="selected-count" class="text-sm text-gray-600 dark:text-gray-400">0 ausgewählt</span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Shopping List Items -->
    <div class="card mt-6">
      <div class="card-content">
        <h2 id="items-heading" class="heading-secondary mb-4">
          Einkaufsliste ({shoppingList.items.length} Artikel)
        </h2>
        
        <!-- Search Field -->
        <div class="mb-4">
          <input
            type="text"
            id="shopping-items-search"
            class="w-full px-4 py-2 rounded-lg border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 focus:ring-2 focus:ring-orange-500 dark:focus:ring-orange-400 focus:border-transparent"
            placeholder="Zutaten durchsuchen..."
          />
        </div>
        
        <div class="space-y-2" id="shopping-items">
          <!-- Items will be populated by JavaScript -->
        </div>
      </div>
    </div>
  </div>

  <!-- Add Item Modal -->
  <div id="add-item-modal" class="modal hidden">
    <div class="modal-overlay"></div>
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title">Artikel hinzufügen</h2>
        <button class="modal-close">&times;</button>
      </div>
      
      <form id="add-item-form" class="modal-body space-y-4">
        <div>
          <label for="item-name" class="form-label">Name</label>
          <input 
            type="text" 
            id="item-name" 
            name="name"
            class="form-input" 
            placeholder="z.B. Milch, Brot, Äpfel..."
            required
          />
        </div>
        
        <div class="grid grid-cols-2 gap-4">
          <div>
            <label for="item-amount" class="form-label">Menge (optional)</label>
            <input 
              type="number" 
              id="item-amount" 
              name="amount"
              class="form-input" 
              placeholder="1"
              step="0.1"
              min="0"
            />
          </div>
          <div>
            <label for="item-unit" class="form-label">Einheit (optional)</label>
            <select 
              id="item-unit" 
              name="unit"
              class="form-input" 
            >
              <option value="">Einheit wählen...</option>
            </select>
          </div>
        </div>
        
        <div>
          <label for="item-description" class="form-label">Beschreibung (optional)</label>
          <input 
            type="text" 
            id="item-description" 
            name="description"
            class="form-input" 
            placeholder="z.B. Bio, 1,5% Fett..."
          />
        </div>
      </form>
      
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary modal-close" style="min-width: 100px;">Abbrechen</button>
        <button type="submit" form="add-item-form" class="btn btn-success" style="min-width: 100px;">
          Hinzufügen
        </button>
      </div>
    </div>
  </div>

  <!-- Add Recipe Modal -->
  <div id="add-recipe-modal" class="modal hidden">
    <div class="modal-overlay"></div>
    <div class="modal-content modal-lg">
      <div class="modal-header">
        <h2 class="modal-title">Rezept hinzufügen</h2>
        <button class="modal-close">&times;</button>
      </div>
      
      <div class="modal-body">
        <div id="recipe-loading" class="text-center py-8">
          <div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-orange-500"></div>
          <p class="text-muted mt-2">Rezepte werden geladen...</p>
        </div>
        
        <div id="recipe-list" class="hidden">
          <div class="mb-4">
            <input 
              type="text" 
              id="recipe-search" 
              class="form-input" 
              placeholder="Rezepte durchsuchen..."
            />
          </div>
          
          <div class="mb-4 flex items-center justify-between">
            <div class="flex items-center space-x-4">
              <label class="flex items-center space-x-2">
                <input type="checkbox" id="select-all-recipes" class="form-checkbox" />
                <span class="text-sm font-medium">Alle auswählen</span>
              </label>
              <span id="selected-recipes-count" class="text-sm text-muted">0 Rezepte ausgewählt</span>
            </div>
            <button id="add-selected-recipes" class="btn btn-success btn-sm" disabled>
              Ausgewählte hinzufügen
            </button>
          </div>
          
          <div id="available-recipes" class="space-y-3 max-h-80 overflow-y-auto">
            <!-- Recipes will be populated by JavaScript -->
          </div>
          
          <div id="no-recipes-found" class="hidden text-center py-8">
            <svg class="w-12 h-12 mx-auto text-gray-400 mb-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M9.172 16.172a4 4 0 015.656 0M9 12h6m-6-4h6m2 5.291A7.962 7.962 0 0112 15c-2.34 0-4.467-.881-6.072-2.327a8.002 8.002 0 01-.344-10.854"/>
            </svg>
            <p class="text-muted">Keine Rezepte gefunden</p>
          </div>
        </div>
      </div>
      
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary modal-close">Schließen</button>
      </div>
    </div>
  </div>

  <!-- Grouping Suggestion Modal -->
  <GroupingSuggestionModal />

  <ViewNotesModal />
  <AddNoteModal />
  <ImageGalleryModal />

  <!-- Global template (second permanent list) apply modal -->
  <div id="global-template-modal" class="modal hidden">
    <div class="modal-overlay"></div>
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title">Wiederverwendbare Einkaufsliste anwenden?</h2>
        <button type="button" class="modal-close">&times;</button>
      </div>
      <div class="modal-body space-y-4">
        <p class="text-sm text-gray-700 dark:text-gray-300">
          Es gibt eine permanente Einkaufsliste mit {globalTemplateSummary?.itemCount ?? 0} Artikeln und {globalTemplateSummary?.recipeCount ?? 0} Rezept{(globalTemplateSummary?.recipeCount ?? 0) !== 1 ? 'en' : ''}.
          Sollen diese Einträge zu dieser neuen Einkaufsliste hinzugefügt werden?
        </p>
        <p class="text-xs text-gray-500 dark:text-gray-400">
          Die Einträge bleiben auf der Vorlage erhalten und können auch bei zukünftigen Einkaufslisten erneut verwendet werden.
        </p>
        <div class="flex gap-2">
          <button type="button" id="apply-global-template-yes" class="btn btn-primary">Ja, hinzufügen</button>
          <button type="button" id="apply-global-template-no" class="btn btn-secondary">Nein, danke</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Apply this permanent list to a chosen normal list (manual action from permanent list page) -->
  <div id="apply-permanent-to-list-modal" class="modal hidden">
    <div class="modal-overlay"></div>
    <div class="modal-content">
      <div class="modal-header">
        <h2 id="apply-permanent-to-list-modal-title" class="modal-title">Ziel-Einkaufsliste wählen</h2>
        <button type="button" class="modal-close">&times;</button>
      </div>
      <div class="modal-body">
        <div id="apply-permanent-to-list-loading" class="text-center py-6 text-muted">
          Listen werden geladen…
        </div>
        <div id="apply-permanent-to-list-list" class="space-y-2 max-h-60 overflow-y-auto hidden">
          <!-- Filled by script -->
        </div>
        <p id="apply-permanent-to-list-empty" class="text-sm text-muted hidden">
          Keine andere Einkaufsliste vorhanden. Erstellen Sie zuerst eine normale Einkaufsliste.
        </p>
      </div>
    </div>
  </div>

  <!-- Add portions for duplicate recipes (when transferring from permanent list) -->
  <div id="add-portions-transfer-modal" class="modal hidden">
    <div class="modal-overlay"></div>
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title">Rezepte bereits in der Liste</h2>
        <button type="button" class="modal-close">&times;</button>
      </div>
      <div class="modal-body">
        <p class="text-sm text-gray-700 dark:text-gray-300 mb-3">
          Die folgenden Rezepte sind bereits in dieser Einkaufsliste. Sollen die Portionen addiert werden?
        </p>
        <ul id="add-portions-recipe-list" class="list-disc list-inside text-sm text-gray-600 dark:text-gray-400 mb-4">
          <!-- Filled by script -->
        </ul>
        <div class="flex gap-2">
          <button type="button" id="add-portions-yes-btn" class="btn btn-primary">Ja, Portionen addieren</button>
          <button type="button" id="add-portions-no-btn" class="btn btn-secondary">Nein</button>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/tinymce@6/tinymce.min.js" referrerpolicy="origin"></script>
  <script type="module" define:vars={{ shoppingListId: id, shoppingListData: shoppingList, isPermanentList: shoppingList.isPermanent ?? false, permanentType: shoppingList.permanentType ?? 0, permanentListSummary: permanentListSummary, globalTemplateSummary: globalTemplateSummary }}>
    // Variables are already defined via define:vars
    let availableUnits = [];
    let unitConversionData = null; // Store unit conversion data for formatting
    
    // Recipe management variables
    let availableRecipes = [];
    let currentlyHighlightedRecipe = null;
    const selectedRecipeIds = new Set();
    
    // Toggle state for hiding checked items (default: false = show all items)
    let hideCheckedItems = false;
    
    // Search filter state
    let searchFilter = '';
    
    // Grouping state
    let isGroupingMode = false;
    let selectedGroupIds = new Set();

    // Format quantity for display using unit conversion data
    function formatQuantityForDisplay(amount, unit) {
      if (!unit || unit.trim() === '' || !unitConversionData) {
        return { amount: Math.round(amount * 10) / 10, unit: unit || '' };
      }
      
      const normalizedUnit = unit.trim();
      
      // Find display units for this base unit
      const displayUnits = unitConversionData[normalizedUnit];
      if (!displayUnits || displayUnits.length === 0) {
        // No display units available, return as-is
        return { amount: Math.round(amount * 10) / 10, unit: normalizedUnit };
      }
      
      // Sort by factor (largest first)
      const sortedDisplayUnits = [...displayUnits].sort((a, b) => b.factor - a.factor);
      
      // Find the largest unit that fits (amount >= 1 of that unit and < 1000)
      for (const displayUnit of sortedDisplayUnits) {
        // Skip conversion if factor is 1 - no benefit in converting to equivalent unit
        // This prevents base units like "Stück" from being converted to other units with factor 1
        if (displayUnit.factor === 1) {
          continue;
        }
        
        const convertedAmount = amount / displayUnit.factor;
        // Use this unit if the converted amount is >= 1 and is a "nice" number (< 1000)
        if (convertedAmount >= 1 && convertedAmount < 1000) {
          // Round to 1 decimal place if needed
          const rounded = Math.round(convertedAmount * 10) / 10;
          return {
            amount: rounded,
            unit: displayUnit.name
          };
        }
      }
      
      // No suitable display unit found, use base unit
      return {
        amount: Math.round(amount * 10) / 10,
        unit: normalizedUnit
      };
    }

    // Load available units and conversion data from API
    async function loadUnits() {
      try {
        const response = await fetch('/api/units');
        if (response.ok) {
          const data = await response.json();
          // API returns { units: [...], conversions: {...} }
          availableUnits = data.units || data; // Support both old and new format
          unitConversionData = data.conversions || null;
          populateUnitDropdown();
        }
      } catch (error) {
        console.error('Error loading units:', error);
      }
    }

    // Populate unit dropdown in add item modal
    function populateUnitDropdown() {
      const unitSelect = document.getElementById('item-unit');
      if (!unitSelect) return;

      // Clear existing options except the first one
      while (unitSelect.children.length > 1) {
        unitSelect.removeChild(unitSelect.lastChild);
      }

      // Add all available units
      availableUnits.forEach(unit => {
        const option = document.createElement('option');
        option.value = unit.name;
        option.textContent = unit.name;
        unitSelect.appendChild(option);
      });
    }

    document.addEventListener('DOMContentLoaded', async () => {
      await loadUnits();
      
      // Search functionality
      const searchInput = document.getElementById('shopping-items-search');
      if (searchInput) {
        searchInput.addEventListener('input', (e) => {
          searchFilter = e.target.value;
          renderShoppingItems();
        });
      }
      
      // Hide checked items toggle functionality
      const hideCheckedToggle = document.getElementById('hide-checked-items-toggle');
      if (hideCheckedToggle) {
        hideCheckedToggle.addEventListener('change', () => {
          hideCheckedItems = hideCheckedToggle.checked;
          renderShoppingItems();
        });
      }
      
      // Grouping functionality
      const groupBtn = document.getElementById('group-items-btn');
      const ungroupBtn = document.getElementById('ungroup-items-btn');
      const confirmGroupBtn = document.getElementById('confirm-group-btn');
      const cancelGroupBtn = document.getElementById('cancel-group-btn');
      
      if (groupBtn) {
        groupBtn.addEventListener('click', () => {
          toggleGroupingMode(true);
        });
      }
      
      if (ungroupBtn) {
        ungroupBtn.addEventListener('click', () => {
          ungroupAll();
        });
      }
      
      if (confirmGroupBtn) {
        confirmGroupBtn.addEventListener('click', () => {
          confirmGrouping();
        });
      }
      
      if (cancelGroupBtn) {
        cancelGroupBtn.addEventListener('click', () => {
          toggleGroupingMode(false);
        });
      }
      
      // Initialize ungroup button visibility
      if (ungroupBtn) {
        ungroupBtn.style.display = hasManualGroups() ? 'flex' : 'none';
      }
      
      // Grouping suggestion functionality
      const suggestGroupingBtn = document.getElementById('suggest-grouping-btn');
      const suggestionModal = document.getElementById('grouping-suggestion-modal');
      let suggestedGroupsData = []; // Store suggested groups data
      
      if (suggestGroupingBtn && suggestionModal) {
        suggestGroupingBtn.addEventListener('click', () => {
          openGroupingSuggestionModal();
        });
        
        // Close modal handlers
        const closeButtons = suggestionModal.querySelectorAll('.modal-close, .modal-overlay');
        closeButtons.forEach(btn => {
          btn.addEventListener('click', () => {
            closeGroupingSuggestionModal();
          });
        });
        
        // Cancel button
        const cancelBtn = document.getElementById('cancel-suggestion-btn');
        if (cancelBtn) {
          cancelBtn.addEventListener('click', () => {
            closeGroupingSuggestionModal();
          });
        }
        
        // Accept all button
        const acceptAllBtn = document.getElementById('accept-all-btn');
        if (acceptAllBtn) {
          acceptAllBtn.addEventListener('click', () => {
            acceptAllSuggestedGroups();
          });
        }
      }
      
      // Function to open grouping suggestion modal
      function openGroupingSuggestionModal() {
        if (!suggestionModal || !window.GroupingSuggestionModal) return;
        
        const loadingEl = document.getElementById('suggestion-loading');
        const contentEl = document.getElementById('suggestion-content');
        const groupsContainer = document.getElementById('suggested-groups');
        const acceptAllBtn = document.getElementById('accept-all-btn');
        
        // Show loading
        loadingEl?.classList.remove('hidden');
        contentEl?.classList.add('hidden');
        suggestionModal.classList.remove('hidden');
        
        // Calculate suggestions
        setTimeout(() => {
          suggestedGroupsData = window.GroupingSuggestionModal.suggestGroups(shoppingListData.items);
          
          // Hide loading, show content
          loadingEl?.classList.add('hidden');
          contentEl?.classList.remove('hidden');
          
          // Render suggestions
          if (groupsContainer && suggestedGroupsData.length > 0) {
            window.GroupingSuggestionModal.renderSuggestedGroups(suggestedGroupsData, groupsContainer);
            if (acceptAllBtn) {
              acceptAllBtn.disabled = false;
            }
          } else {
            groupsContainer.innerHTML = '';
            if (acceptAllBtn) {
              acceptAllBtn.disabled = true;
            }
          }
        }, 100); // Small delay to show loading state
      }
      
      // Function to close grouping suggestion modal
      function closeGroupingSuggestionModal() {
        if (suggestionModal) {
          suggestionModal.classList.add('hidden');
          suggestedGroupsData = [];
        }
      }
      
      // Function to accept all suggested groups
      async function acceptAllSuggestedGroups() {
        // Get groups data from the container (in case suggestedGroupsData was cleared)
        const groupsContainer = document.getElementById('suggested-groups');
        const groupsData = groupsContainer && window.GroupingSuggestionModal?.getGroupsData 
          ? window.GroupingSuggestionModal.getGroupsData(groupsContainer)
          : suggestedGroupsData;
        
        if (!groupsData || groupsData.length === 0) return;
        
        // Get all checked groups
        const checkedGroupIds = new Set();
        document.querySelectorAll('.group-accept-checkbox:checked').forEach(checkbox => {
          checkedGroupIds.add(checkbox.getAttribute('data-group-id'));
        });
        
        if (checkedGroupIds.size === 0) {
          alert('Bitte wählen Sie mindestens eine Gruppierung aus.');
          return;
        }
        
        // Apply all accepted groups
        const updatedItems = [...shoppingListData.items];
        const groupsToApply = groupsData.filter(group => checkedGroupIds.has(group.id));
        
        groupsToApply.forEach((group, index) => {
          // Generate unique group ID with timestamp and index to avoid collisions
          const newGroupId = `manual_${Date.now()}_${index}_${Math.random().toString(36).substr(2, 9)}`;
          
          // Update all items in this group
          group.items.forEach(groupItem => {
            const itemIndex = updatedItems.findIndex(item => item.id === groupItem.id);
            if (itemIndex !== -1) {
              updatedItems[itemIndex] = {
                ...updatedItems[itemIndex],
                manualGroupId: newGroupId
              };
            }
          });
        });
        
        try {
          const response = await fetch(`/api/shopping-lists?id=${shoppingListId}`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              items: updatedItems
            }),
          });
          
          if (response.ok) {
            const updatedList = await response.json();
            shoppingListData.items = updatedList.items;
            
            // Close modal and re-render
            closeGroupingSuggestionModal();
            renderShoppingItems();
            updateHeaderCounters();
            
            // Update ungroup button visibility
            const ungroupBtn = document.getElementById('ungroup-items-btn');
            if (ungroupBtn) {
              ungroupBtn.style.display = hasManualGroups() ? 'flex' : 'none';
            }
            
            const appliedCount = groupsToApply.length;
            alert(`${appliedCount} Gruppierung${appliedCount !== 1 ? 'en' : ''} wurde${appliedCount !== 1 ? 'n' : ''} angewendet!`);
          } else {
            const error = await response.json();
            alert(error.error || 'Fehler beim Anwenden der Gruppierungen');
          }
        } catch (error) {
          console.error('Error applying groups:', error);
          alert('Fehler beim Anwenden der Gruppierungen');
        }
      }
      
      // Share button functionality
      const shareButton = document.getElementById('share-list-btn');
      shareButton?.addEventListener('click', async () => {
        try {
          const shareData = {
            title: shoppingListData.title,
            text: `Einkaufsliste: ${shoppingListData.title}`,
            url: window.location.href
          };

          if (navigator.share && navigator.canShare(shareData)) {
            await navigator.share(shareData);
          } else {
            // Fallback: Copy link to clipboard
            await navigator.clipboard.writeText(window.location.href);
            
            // Show feedback
            const originalText = shareButton.innerHTML;
            shareButton.innerHTML = `
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
              </svg>
              <span>Link kopiert!</span>
            `;
            
            setTimeout(() => {
              shareButton.innerHTML = originalText;
            }, 2000);
          }
        } catch (error) {
          console.error('Error sharing:', error);
        }
      });

      // Global template (second permanent list) modal on first open of a normal list
      const globalTemplateModal = document.getElementById('global-template-modal');
      const applyGlobalTemplateYesBtn = document.getElementById('apply-global-template-yes');
      const applyGlobalTemplateNoBtn = document.getElementById('apply-global-template-no');

      async function markGlobalTemplatePromptSeen() {
        try {
          await fetch(`/api/shopping-lists?id=${shoppingListId}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ hasSeenGlobalTemplatePrompt: true })
          });
        } catch (e) {
          console.error('Failed to mark global template prompt as seen', e);
        }
      }

      if (!isPermanentList && globalTemplateSummary) {
        globalTemplateModal?.classList.remove('hidden');
      }

      applyGlobalTemplateYesBtn?.addEventListener('click', async () => {
        try {
          const response = await fetch(`/api/shopping-lists/${shoppingListId}/apply-global-template`, {
            method: 'POST'
          });
          await markGlobalTemplatePromptSeen();
          globalTemplateModal?.classList.add('hidden');
          if (!response.ok) {
            const err = await response.json();
            alert(err.error || 'Fehler beim Anwenden der Vorlage');
            return;
          }
          if (typeof window.showInfo === 'function') {
            window.showInfo('Vorlagen-Einkaufsliste wurde übernommen.');
          }
          window.location.reload();
        } catch (e) {
          console.error('Failed to apply global template', e);
          alert('Fehler beim Anwenden der Vorlage');
        }
      });

      const closeGlobalTemplateModal = async () => {
        globalTemplateModal?.classList.add('hidden');
        await markGlobalTemplatePromptSeen();
      };

      applyGlobalTemplateNoBtn?.addEventListener('click', closeGlobalTemplateModal);
      globalTemplateModal?.querySelector('.modal-close')?.addEventListener('click', closeGlobalTemplateModal);
      globalTemplateModal?.querySelector('.modal-overlay')?.addEventListener('click', closeGlobalTemplateModal);

      // Transfer from permanent list (Sammelliste)
      const transferBanner = document.getElementById('transfer-from-permanent-banner');
      const transferBtn = document.getElementById('transfer-from-permanent-btn');
      const dismissTransferBtn = document.getElementById('dismiss-transfer-banner-btn');
      const addPortionsModal = document.getElementById('add-portions-transfer-modal');
      const addPortionsRecipeList = document.getElementById('add-portions-recipe-list');
      const addPortionsYesBtn = document.getElementById('add-portions-yes-btn');
      const addPortionsNoBtn = document.getElementById('add-portions-no-btn');

      dismissTransferBtn?.addEventListener('click', () => {
        transferBanner?.classList.add('hidden');
      });

      let pendingDuplicateRecipeIds = [];
      let transferTargetListId = shoppingListId; // target list for transfer (current page when from banner; chosen list when from "apply to list" on permanent page)
      transferBtn?.addEventListener('click', async () => {
        if (!shoppingListId) return;
        transferTargetListId = shoppingListId;
        try {
          const response = await fetch(`/api/shopping-lists/${shoppingListId}/transfer-from-permanent`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({})
          });
          if (!response.ok) {
            const err = await response.json();
            alert(err.error || 'Übernahme fehlgeschlagen');
            return;
          }
          const result = await response.json();
          if (result.duplicateRecipeIds && result.duplicateRecipeIds.length > 0) {
            pendingDuplicateRecipeIds = result.duplicateRecipeIds;
            const titles = (shoppingListData.recipes || [])
              .filter(r => pendingDuplicateRecipeIds.includes(r.id))
              .map(r => r.title);
            if (addPortionsRecipeList) {
              addPortionsRecipeList.innerHTML = titles.map(t => `<li>${t}</li>`).join('');
            }
            addPortionsModal?.classList.remove('hidden');
            transferBanner?.classList.add('hidden');
          } else {
            if (typeof window.showInfo === 'function') {
              window.showInfo('Einträge von der Sammelliste wurden übernommen.');
            } else {
              alert('Einträge von der Sammelliste wurden übernommen.');
            }
            window.location.reload();
          }
        } catch (e) {
          console.error('Transfer from permanent list failed', e);
          alert('Übernahme fehlgeschlagen.');
        }
      });

      addPortionsYesBtn?.addEventListener('click', async () => {
        if (!transferTargetListId || pendingDuplicateRecipeIds.length === 0) return;
        try {
          const response = await fetch(`/api/shopping-lists/${transferTargetListId}/transfer-from-permanent`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ addPortionsForRecipeIds: pendingDuplicateRecipeIds })
          });
          addPortionsModal?.classList.add('hidden');
          if (response.ok) {
            if (typeof window.showInfo === 'function') {
              window.showInfo('Portionen wurden addiert. Einträge von der Sammelliste wurden übernommen.');
            } else {
              alert('Portionen wurden addiert.');
            }
            window.location.reload();
          } else {
            alert('Fehler beim Addieren der Portionen.');
          }
        } catch (e) {
          addPortionsModal?.classList.add('hidden');
          console.error('Add portions failed', e);
          alert('Fehler beim Addieren der Portionen.');
        }
      });

      addPortionsNoBtn?.addEventListener('click', () => {
        addPortionsModal?.classList.add('hidden');
        if (typeof window.showInfo === 'function') {
          window.showInfo('Übernahme abgeschlossen. Die genannten Rezepte bleiben auf der Sammelliste.');
        }
        window.location.reload();
      });

      addPortionsModal?.querySelector('.modal-close')?.addEventListener('click', () => {
        addPortionsModal?.classList.add('hidden');
        window.location.reload();
      });
      addPortionsModal?.querySelector('.modal-overlay')?.addEventListener('click', () => {
        addPortionsModal?.classList.add('hidden');
        window.location.reload();
      });

      // Apply this permanent list to a chosen normal list (button on permanent list page)
      const PERMANENT_LIST_IDS = ['permanent-shopping-list', 'global-template-shopping-list'];
      const applyPermanentToListBtn = document.getElementById('apply-permanent-to-list-btn');
      const applyPermanentToListModal = document.getElementById('apply-permanent-to-list-modal');
      const applyPermanentToListTitle = document.getElementById('apply-permanent-to-list-modal-title');
      const applyPermanentToListLoading = document.getElementById('apply-permanent-to-list-loading');
      const applyPermanentToListList = document.getElementById('apply-permanent-to-list-list');
      const applyPermanentToListEmpty = document.getElementById('apply-permanent-to-list-empty');

      applyPermanentToListBtn?.addEventListener('click', async () => {
        if (!applyPermanentToListModal) return;
        applyPermanentToListModal.classList.remove('hidden');
        applyPermanentToListLoading?.classList.remove('hidden');
        applyPermanentToListList?.classList.add('hidden');
        applyPermanentToListEmpty?.classList.add('hidden');
        if (applyPermanentToListTitle) {
          applyPermanentToListTitle.textContent = permanentType === 2
            ? 'Zu welcher Einkaufsliste hinzufügen?'
            : 'In welche Einkaufsliste übernehmen?';
        }
        try {
          const response = await fetch('/api/shopping-lists');
          const allLists = await response.json();
          const normalLists = allLists.filter(l => !l.isPermanent && l.id !== shoppingListId && !PERMANENT_LIST_IDS.includes(l.id));
          applyPermanentToListLoading?.classList.add('hidden');
          if (normalLists.length === 0) {
            applyPermanentToListEmpty?.classList.remove('hidden');
            return;
          }
          applyPermanentToListList?.classList.remove('hidden');
          applyPermanentToListList.innerHTML = normalLists.map(list => {
            const itemCount = list.items?.length ?? 0;
            const recipeCount = list.recipes?.length ?? 0;
            const label = `${list.title} (${itemCount} Artikel${recipeCount ? `, ${recipeCount} Rezept${recipeCount !== 1 ? 'e' : ''}` : ''})`;
            return `<button type="button" class="apply-to-list-choice w-full btn btn-secondary text-left justify-start py-3" data-list-id="${list.id}">${label}</button>`;
          }).join('');
          applyPermanentToListList.querySelectorAll('.apply-to-list-choice').forEach(btn => {
            btn.addEventListener('click', async () => {
              const targetId = btn.getAttribute('data-list-id');
              if (!targetId) return;
              applyPermanentToListModal.classList.add('hidden');
              if (permanentType === 2) {
                try {
                  const res = await fetch(`/api/shopping-lists/${targetId}/apply-global-template`, { method: 'POST' });
                  if (!res.ok) {
                    const err = await res.json();
                    alert(err.error || 'Hinzufügen fehlgeschlagen.');
                    return;
                  }
                  if (typeof window.showInfo === 'function') {
                    window.showInfo('Inhalt wurde zur Einkaufsliste hinzugefügt.');
                  } else {
                    alert('Inhalt wurde zur Einkaufsliste hinzugefügt.');
                  }
                  window.location.reload();
                } catch (e) {
                  console.error('Apply global template failed', e);
                  alert('Hinzufügen fehlgeschlagen.');
                }
                return;
              }
              transferTargetListId = targetId;
              try {
                const res = await fetch(`/api/shopping-lists/${targetId}/transfer-from-permanent`, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({})
                });
                if (!res.ok) {
                  const err = await res.json();
                  alert(err.error || 'Übernahme fehlgeschlagen.');
                  return;
                }
                const result = await res.json();
                if (result.duplicateRecipeIds && result.duplicateRecipeIds.length > 0) {
                  pendingDuplicateRecipeIds = result.duplicateRecipeIds;
                  const titles = (shoppingListData.recipes || [])
                    .filter(r => pendingDuplicateRecipeIds.includes(r.id))
                    .map(r => r.title);
                  if (addPortionsRecipeList) {
                    addPortionsRecipeList.innerHTML = titles.map(t => `<li>${t}</li>`).join('');
                  }
                  addPortionsModal?.classList.remove('hidden');
                } else {
                  if (typeof window.showInfo === 'function') {
                    window.showInfo('Einträge wurden in die Einkaufsliste übernommen.');
                  } else {
                    alert('Einträge wurden übernommen.');
                  }
                  window.location.reload();
                }
              } catch (e) {
                console.error('Transfer from permanent list failed', e);
                alert('Übernahme fehlgeschlagen.');
              }
            });
          });
        } catch (e) {
          console.error('Failed to load lists', e);
          applyPermanentToListLoading?.classList.add('hidden');
          applyPermanentToListEmpty?.classList.remove('hidden');
        }
      });

      applyPermanentToListModal?.querySelector('.modal-close')?.addEventListener('click', () => {
        applyPermanentToListModal?.classList.add('hidden');
      });
      applyPermanentToListModal?.querySelector('.modal-overlay')?.addEventListener('click', () => {
        applyPermanentToListModal?.classList.add('hidden');
      });
      
      // Function to group items by name (ignoring unit differences) and manual groups
      function groupItems(items) {
        const groups = new Map();
        
        // First, group by manualGroupId if present
        const manualGroups = new Map();
        const ungroupedItems = [];
        
        items.forEach(item => {
          if (item.manualGroupId) {
            if (!manualGroups.has(item.manualGroupId)) {
              manualGroups.set(item.manualGroupId, []);
            }
            manualGroups.get(item.manualGroupId).push(item);
          } else {
            ungroupedItems.push(item);
          }
        });
        
        // Process manual groups - combine all items in a manual group
        manualGroups.forEach((groupItems, groupId) => {
          const group = {
            name: groupItems.map(i => i.name).join(', '), // Combined name
            items: groupItems,
            allChecked: groupItems.every(i => i.isChecked),
            anyChecked: groupItems.some(i => i.isChecked),
            descriptions: [...new Set(groupItems.map(i => i.description).filter(Boolean))],
            quantitiesByUnit: new Map(),
            unitCasing: new Map(),
            manualGroupId: groupId,
            isManualGroup: true
          };
          
          // Sum quantities by unit across all items in the manual group
          groupItems.forEach(item => {
            if (item.quantity && item.quantity.unit) {
              const unitKey = item.quantity.unit.toLowerCase();
              if (group.quantitiesByUnit.has(unitKey)) {
                group.quantitiesByUnit.set(
                  unitKey,
                  group.quantitiesByUnit.get(unitKey) + item.quantity.amount
                );
              } else {
                group.quantitiesByUnit.set(unitKey, item.quantity.amount);
                group.unitCasing.set(unitKey, item.quantity.unit);
              }
            }
          });
          
          groups.set(`manual_${groupId}`, group);
        });
        
        // Process ungrouped items - group by name only (case-insensitive)
        ungroupedItems.forEach(item => {
          const key = item.name.toLowerCase();
          
          if (groups.has(key)) {
            const existingGroup = groups.get(key);
            existingGroup.items.push(item);
            existingGroup.allChecked = existingGroup.allChecked && item.isChecked;
            existingGroup.anyChecked = existingGroup.anyChecked || item.isChecked;
            
            // Combine descriptions (if different)
            if (item.description && !existingGroup.descriptions.includes(item.description)) {
              existingGroup.descriptions.push(item.description);
            }
            
            // Sum amounts by unit (only if item has quantity)
            if (item.quantity && item.quantity.unit) {
              const unitKey = item.quantity.unit.toLowerCase();
              if (existingGroup.quantitiesByUnit.has(unitKey)) {
                existingGroup.quantitiesByUnit.set(
                  unitKey,
                  existingGroup.quantitiesByUnit.get(unitKey) + item.quantity.amount
                );
              } else {
                existingGroup.quantitiesByUnit.set(unitKey, item.quantity.amount);
                // Store the original unit casing for display
                existingGroup.unitCasing.set(unitKey, item.quantity.unit);
              }
            }
          } else {
            // Create new group
            const quantitiesByUnit = new Map();
            const unitCasing = new Map();
            if (item.quantity && item.quantity.unit) {
              const unitKey = item.quantity.unit.toLowerCase();
              quantitiesByUnit.set(unitKey, item.quantity.amount);
              unitCasing.set(unitKey, item.quantity.unit);
            }
            
            groups.set(key, {
              name: item.name,
              items: [item],
              allChecked: item.isChecked,
              anyChecked: item.isChecked,
              descriptions: item.description ? [item.description] : [],
              quantitiesByUnit: quantitiesByUnit,
              unitCasing: unitCasing,
              isManualGroup: false
            });
          }
        });
        
        return Array.from(groups.values());
      }
      
      // Function to render shopping items
      function renderShoppingItems() {
        const container = document.getElementById('shopping-items');
        if (!container) return;
        
        let itemsToRender = shoppingListData.items;
        
        // Filter out checked items if toggle is enabled
        if (hideCheckedItems) {
          itemsToRender = itemsToRender.filter(item => !item.isChecked);
        }
        
        const groupedItems = groupItems(itemsToRender);
        
        // Filter groups based on search term
        let filteredGroups = groupedItems;
        if (searchFilter.trim() !== '') {
          const searchTerm = searchFilter.toLowerCase().trim();
          filteredGroups = groupedItems.filter(group => {
            // Check if group name matches
            if (group.name.toLowerCase().includes(searchTerm)) {
              return true;
            }
            
            // Check if any description matches
            if (group.descriptions.some(desc => desc.toLowerCase().includes(searchTerm))) {
              return true;
            }
            
            // Check if any unit name matches
            const unitNames = Array.from(group.unitCasing.values());
            if (unitNames.some(unit => unit.toLowerCase().includes(searchTerm))) {
              return true;
            }
            
            // Check if any individual item name matches (for manual groups)
            if (group.items.some(item => item.name.toLowerCase().includes(searchTerm))) {
              return true;
            }
            
            return false;
          });
        }
        
        if (filteredGroups.length === 0) {
          const emptyMessage = searchFilter.trim() !== '' 
            ? `<p class="text-muted mb-2">Keine Artikel gefunden für "${searchFilter}"</p>`
            : `<p class="text-muted mb-2">Noch keine Artikel in der Einkaufsliste</p>
               <p class="text-sm text-muted">Klicken Sie auf "Artikel hinzufügen" um zu beginnen</p>`;
          
          container.innerHTML = `
            <div class="text-center py-8 border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-lg">
              <svg class="w-12 h-12 mx-auto text-gray-400 mb-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M9 5H7a2 2 0 00-2 2v11a2 2 0 002 2h5.586a1 1 0 00.707-.293l5.414-5.414a1 1 0 00.293-.707V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"/>
              </svg>
              ${emptyMessage}
            </div>
          `;
          return;
        }
        
        container.innerHTML = filteredGroups.map((group, index) => {
          const isChecked = group.allChecked;
          const isPartiallyChecked = group.anyChecked && !group.allChecked;
          const itemIds = group.items.map(item => item.id).join(',');
          const recipeIds = [...new Set(group.items.map(item => item.recipeId).filter(Boolean))].join(',');
          const hasMultipleItems = group.items.length > 1;
          const isEvenRow = index % 2 === 0;
          const rowBgClass = isEvenRow ? 'bg-white dark:bg-gray-900' : 'bg-gray-50 dark:bg-gray-800/50';
          
          // Format quantities by unit and filter out zero amounts
          const quantitiesByUnit = Array.from(group.quantitiesByUnit.entries())
            .map(([unitKey, amount]) => {
              const unit = group.unitCasing.get(unitKey);
              // Format for display (convert to larger units if appropriate)
              const formatted = formatQuantityForDisplay(amount, unit);
              const formattedAmount = formatted.amount % 1 === 0 ? 
                formatted.amount.toString() : 
                formatted.amount.toFixed(1).replace(/\.0$/, '');
              return { amount: formattedAmount, unit: formatted.unit, unitKey, numericAmount: amount };
            })
            .filter(({ numericAmount }) => numericAmount !== 0); // Filter out zero amounts
          
          const hasMultipleUnits = quantitiesByUnit.length > 1;
          const groupHasNote = group.items.some(item => item.note && item.note.trim() !== '');
          
          // First unit display (only shown if amount > 0)
          const firstUnitDisplay = quantitiesByUnit.length > 0 ? `
            <span class="${isChecked 
              ? 'text-sm text-green-700 dark:text-green-300 bg-green-100 dark:bg-green-800 px-3 py-1.5 rounded border border-green-200 dark:border-green-700 flex-shrink-0'
              : 'text-sm bg-gray-100 dark:bg-gray-700 text-gray-900 dark:text-white px-3 py-1.5 rounded border border-gray-200 dark:border-gray-600 flex-shrink-0'
            }">
              ${quantitiesByUnit[0].amount} ${quantitiesByUnit[0].unit}
            </span>
          ` : '';
          
          // Info icon (when any item in group has a note) - opens view-notes modal
          const noteInfoIcon = groupHasNote ? `
            <button type="button" class="item-note-info w-5 h-5 flex-shrink-0 text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200 transition-colors flex items-center justify-center rounded" data-item-ids="${itemIds}" title="Notizen anzeigen" aria-label="Notizen anzeigen">
              <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
              </svg>
            </button>
          ` : '';
          
          // Add-note "+" button (shown on hover desktop; long-press mobile)
          const addNotePlusBtn = `
            <button type="button" class="item-add-note-plus add-note-plus-btn w-6 h-6 flex-shrink-0 flex items-center justify-center rounded text-gray-500 hover:text-orange-500 dark:hover:text-orange-400 hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors text-lg leading-none md:opacity-0 md:group-hover:opacity-100" data-item-ids="${itemIds}" title="Notiz hinzufügen" aria-label="Notiz hinzufügen">+</button>
          `;
          
          // Additional units display (boxes below, aligned with first unit)
          const additionalUnitsDisplay = hasMultipleUnits ? `
            <div class="flex flex-col gap-1.5 mt-1.5 items-end">
              ${quantitiesByUnit.slice(1).map(({ amount, unit }) => `
                <span class="${isChecked 
                  ? 'text-sm text-green-700 dark:text-green-300 bg-green-100 dark:bg-green-800 px-3 py-1.5 rounded border border-green-200 dark:border-green-700'
                  : 'text-sm bg-gray-100 dark:bg-gray-700 text-gray-900 dark:text-white px-3 py-1.5 rounded border border-gray-200 dark:border-gray-600'
                }">
                  ${amount} ${unit}
                </span>
              `).join('')}
            </div>
          ` : '';
          
          // Create details for individual items if there are multiple (each can have add-note +)
          const itemDetails = hasMultipleItems ? group.items.map((item, index) => {
            const sourceLabel = item.recipeId ? '🍳 Rezept' : '✋ Manuell';
            const sourceClass = item.recipeId ? 'text-blue-600 dark:text-blue-400' : 'text-gray-600 dark:text-gray-400';
            const itemHasNote = item.note && item.note.trim() !== '';
            
            let quantityDisplay = '';
            if (item.quantity && item.quantity.amount !== 0) {
              // Format for display (convert to larger units if appropriate)
              const formatted = formatQuantityForDisplay(item.quantity.amount, item.quantity.unit);
              const itemAmount = formatted.amount % 1 === 0 ? 
                formatted.amount.toString() : 
                formatted.amount.toFixed(1).replace(/\.0$/, '');
              quantityDisplay = `<span class="text-gray-700 dark:text-gray-300 font-mono">${itemAmount} ${formatted.unit}</span>`;
            }
            
            const detailNoteInfo = itemHasNote ? `
              <button type="button" class="detail-item-note-info w-4 h-4 flex-shrink-0 text-blue-600 dark:text-blue-400 hover:text-blue-800 flex items-center justify-center rounded" data-item-ids="${item.id}" title="Notiz anzeigen" aria-label="Notiz anzeigen">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                </svg>
              </button>
            ` : '';
            const detailAddNotePlus = `
              <button type="button" class="detail-item-add-note add-note-plus-btn w-5 h-5 flex-shrink-0 flex items-center justify-center rounded text-gray-400 hover:text-orange-500 dark:hover:text-orange-400 hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors text-sm leading-none opacity-0 group-hover:opacity-100" data-item-ids="${item.id}" title="Notiz hinzufügen" aria-label="Notiz hinzufügen">+</button>
            `;
            
            return `
              <div class="detail-item group flex justify-between items-center py-1 px-2 text-sm transition-colors" data-item-id="${item.id}">
                <div class="flex items-center space-x-2 min-w-0">
                  <span class="${sourceClass} text-xs font-medium">${sourceLabel}</span>
                  ${item.description ? `<span class="text-gray-500 truncate">• ${item.description}</span>` : ''}
                </div>
                <div class="flex items-center gap-1 flex-shrink-0">
                  ${quantityDisplay}
                  ${detailNoteInfo}
                  ${detailAddNotePlus}
                </div>
              </div>
            `;
          }).join('') : '';
          
          const groupId = group.manualGroupId || `group_${itemIds}`;
          const isSelected = selectedGroupIds.has(groupId);
          
          return `
            <div class="shopping-item-group ${rowBgClass} ${isSelected ? 'ring-2 ring-blue-500' : ''} border-b border-gray-200 dark:border-gray-700 last:border-b-0" data-item-ids="${itemIds}" data-recipe-ids="${recipeIds}" data-group-id="${groupId}">
              <div class="shopping-item group p-3 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg transition-colors ${hasMultipleItems ? 'cursor-pointer' : ''}" ${hasMultipleItems ? 'data-expandable="true"' : ''}>
                <!-- Main Row: Selection Checkbox (in grouping mode), Item Checkbox, Title, Description, Actions, Add Note +, Amount, Info -->
                <div class="flex items-center gap-2 sm:gap-3 flex-wrap">
                  ${isGroupingMode ? `
                    <input 
                      type="checkbox" 
                      class="group-selection-checkbox w-5 h-5 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500 focus:ring-2 flex-shrink-0"
                      data-group-id="${groupId}"
                      ${isSelected ? 'checked' : ''}
                    />
                  ` : ''}
                  ${isPermanentList ? `
                    <span class="w-5 h-5 flex-shrink-0 flex items-center justify-center text-gray-400 dark:text-gray-500" title="Auf der Sammelliste können Artikel nicht abgehakt werden">
                      <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"/></svg>
                    </span>
                  ` : `
                  <input 
                    type="checkbox" 
                    class="item-checkbox w-5 h-5 text-green-600 bg-gray-100 border-gray-300 rounded focus:ring-green-500 focus:ring-2 ${isPartiallyChecked ? 'opacity-50' : ''} ${isGroupingMode ? 'opacity-50 cursor-not-allowed' : ''} flex-shrink-0"
                    ${isChecked ? 'checked' : ''}
                    ${isGroupingMode ? 'disabled' : ''}
                    title="${isPartiallyChecked ? 'Teilweise erledigt' : isGroupingMode ? 'Gruppierungsmodus aktiv' : ''}"
                  />
                  `}
                  <span class="font-medium transition-colors flex-shrink-0 ${
                    isChecked 
                      ? 'text-green-800 dark:text-green-300 line-through' 
                      : 'text-gray-900 dark:text-white'
                  }">
                    ${group.name}
                    ${hasMultipleItems ? `<span class="text-xs text-gray-500 ml-1">(${group.items.length}x)</span>` : ''}
                    ${group.isManualGroup ? `<span class="text-xs text-blue-600 dark:text-blue-400 ml-1">(Manuell gruppiert)</span>` : ''}
                  </span>
                  ${group.descriptions.length > 0 ? `
                    <p class="text-sm transition-colors flex-shrink-0 ${
                      isChecked 
                        ? 'text-green-700 dark:text-green-300 line-through' 
                        : 'text-muted'
                    }">
                      ${group.descriptions.join(', ')}
                    </p>
                  ` : ''}
                  <div class="flex items-center gap-1.5 flex-shrink-0 ml-auto">
                    ${recipeIds ? `
                      <button class="recipe-highlight-btn w-5 h-5 text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200 transition-colors flex-shrink-0" 
                              data-recipe-ids="${recipeIds}" 
                              title="Rezept hervorheben">
                        <svg class="w-full h-full" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.746 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"/>
                        </svg>
                      </button>
                    ` : ''}
                    ${hasMultipleItems ? `
                      <svg class="expand-icon w-4 h-4 text-gray-400 transition-transform duration-200 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/>
                      </svg>
                    ` : ''}
                    ${addNotePlusBtn}
                    ${firstUnitDisplay}
                    ${noteInfoIcon}
                  </div>
                </div>
                ${additionalUnitsDisplay}
              </div>
              ${hasMultipleItems ? `
                <div class="item-details hidden mt-2 ml-8 mr-4 bg-gray-50 dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700">
                  <div class="p-3">
                    <div class="text-xs font-medium text-gray-500 dark:text-gray-400 mb-2 uppercase tracking-wide">Einzelne Mengen:</div>
                    ${itemDetails}
                  </div>
                </div>
              ` : ''}
            </div>
          `;
        }).join('');
        
        // Re-attach event listeners
        attachCheckboxListeners();
        attachExpandListeners();
        attachRecipeHighlightListeners();
        attachGroupSelectionListeners();
        attachNoteListeners();
        
        // Restore highlights if any recipe was selected
        if (currentlyHighlightedRecipe) {
          highlightRecipeIngredients(currentlyHighlightedRecipe);
        }
      }
      
      // Function to attach group selection listeners
      function attachGroupSelectionListeners() {
        document.querySelectorAll('.group-selection-checkbox').forEach(checkbox => {
          checkbox.addEventListener('change', (e) => {
            const groupId = e.target.getAttribute('data-group-id');
            const groupElement = e.target.closest('.shopping-item-group');
            
            if (e.target.checked) {
              selectedGroupIds.add(groupId);
              if (groupElement) {
                groupElement.classList.add('ring-2', 'ring-blue-500');
              }
            } else {
              selectedGroupIds.delete(groupId);
              if (groupElement) {
                groupElement.classList.remove('ring-2', 'ring-blue-500');
              }
            }
            
            updateGroupSelectionUI();
          });
        });
      }
      
      // Function to update group selection UI
      function updateGroupSelectionUI() {
        const selectedCount = selectedGroupIds.size;
        const selectedCountElement = document.getElementById('selected-count');
        const confirmBtn = document.getElementById('confirm-group-btn');
        
        if (selectedCountElement) {
          selectedCountElement.textContent = `${selectedCount} ausgewählt`;
        }
        
        if (confirmBtn) {
          confirmBtn.disabled = selectedCount < 2;
        }
      }
      
      // Function to toggle grouping mode
      function toggleGroupingMode(enable) {
        isGroupingMode = enable;
        selectedGroupIds.clear();
        
        const groupBtn = document.getElementById('group-items-btn');
        const ungroupBtn = document.getElementById('ungroup-items-btn');
        const selectionControls = document.getElementById('group-selection-controls');
        
        if (groupBtn) {
          groupBtn.style.display = enable ? 'none' : 'flex';
        }
        if (ungroupBtn) {
          ungroupBtn.style.display = enable ? 'none' : (hasManualGroups() ? 'flex' : 'none');
        }
        if (selectionControls) {
          selectionControls.classList.toggle('hidden', !enable);
        }
        
        // Add/remove grouping mode class to body
        document.body.classList.toggle('grouping-mode', enable);
        
        renderShoppingItems();
      }
      
      // Function to check if there are manual groups
      function hasManualGroups() {
        return shoppingListData.items.some(item => item.manualGroupId);
      }
      
      // Function to confirm grouping
      async function confirmGrouping() {
        if (selectedGroupIds.size < 2) {
          alert('Bitte wählen Sie mindestens 2 Gruppen aus.');
          return;
        }
        
        // Generate a new group ID
        const newGroupId = `manual_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        
        // Get all item IDs from selected groups
        const selectedItemIds = new Set();
        selectedGroupIds.forEach(groupId => {
          const groupElement = document.querySelector(`[data-group-id="${groupId}"]`);
          if (groupElement) {
            const itemIdsAttr = groupElement.getAttribute('data-item-ids');
            if (itemIdsAttr) {
              itemIdsAttr.split(',').forEach(id => selectedItemIds.add(id));
            }
          }
        });
        
        // Update items with the new manualGroupId
        const updatedItems = shoppingListData.items.map(item => {
          if (selectedItemIds.has(item.id)) {
            return { ...item, manualGroupId: newGroupId };
          }
          return item;
        });
        
        try {
          const response = await fetch(`/api/shopping-lists?id=${shoppingListId}`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              items: updatedItems
            }),
          });
          
          if (response.ok) {
            const updatedList = await response.json();
            shoppingListData.items = updatedList.items;
            
            // Exit grouping mode and re-render
            toggleGroupingMode(false);
            renderShoppingItems();
            updateHeaderCounters();
          } else {
            const error = await response.json();
            alert(error.error || 'Fehler beim Gruppieren der Artikel');
          }
        } catch (error) {
          console.error('Error grouping items:', error);
          alert('Fehler beim Gruppieren der Artikel');
        }
      }
      
      // Function to ungroup all items
      async function ungroupAll() {
        if (!hasManualGroups()) {
          return;
        }
        
        if (!confirm('Möchten Sie wirklich alle manuellen Gruppierungen aufheben?')) {
          return;
        }
        
        // Remove manualGroupId from all items
        const updatedItems = shoppingListData.items.map(item => {
          const { manualGroupId, ...itemWithoutGroupId } = item;
          return itemWithoutGroupId;
        });
        
        try {
          const response = await fetch(`/api/shopping-lists?id=${shoppingListId}`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              items: updatedItems
            }),
          });
          
          if (response.ok) {
            const updatedList = await response.json();
            shoppingListData.items = updatedList.items;
            
            // Re-render
            renderShoppingItems();
            updateHeaderCounters();
            
            // Update ungroup button visibility
            const ungroupBtn = document.getElementById('ungroup-items-btn');
            if (ungroupBtn) {
              ungroupBtn.style.display = 'none';
            }
          } else {
            const error = await response.json();
            alert(error.error || 'Fehler beim Aufheben der Gruppierungen');
          }
        } catch (error) {
          console.error('Error ungrouping items:', error);
          alert('Fehler beim Aufheben der Gruppierungen');
        }
      }
      
             // Function to attach expand/collapse listeners
       function attachExpandListeners() {
         document.querySelectorAll('[data-expandable="true"]').forEach(item => {
           item.addEventListener('click', (e) => {
             // Don't expand if clicking on checkbox or in grouping mode
             if (e.target.closest('.item-checkbox') || e.target.closest('.group-selection-checkbox') || isGroupingMode) {
               return;
             }
             
             const group = item.closest('.shopping-item-group');
             const details = group.querySelector('.item-details');
             const expandIcon = item.querySelector('.expand-icon');
             
             if (details && expandIcon) {
               const isExpanded = !details.classList.contains('hidden');
               
               if (isExpanded) {
                 // Collapse
                 details.classList.add('hidden');
                 expandIcon.style.transform = 'rotate(0deg)';
               } else {
                 // Expand
                 details.classList.remove('hidden');
                 expandIcon.style.transform = 'rotate(180deg)';
               }
             }
           });
         });
       }
       
       // Function to attach recipe highlight listeners
       function attachRecipeHighlightListeners() {
         document.querySelectorAll('.recipe-highlight-btn').forEach(btn => {
           btn.addEventListener('click', (e) => {
             e.stopPropagation(); // Prevent expanding/collapsing
             
             const recipeIds = btn.getAttribute('data-recipe-ids');
             if (recipeIds) {
               // For items linked to multiple recipes, use the first one
               const recipeId = recipeIds.split(',')[0];
               toggleRecipeHighlight(recipeId);
             }
           });
         });
       }
       
       // --- Note modals and TinyMCE ---
       let noteTinyMCE = null;
       let addNoteTargetItemIds = null; // single item id or comma-separated for multi
       
       function openViewNotesModal(itemIdsStr) {
         const ids = itemIdsStr.split(',').map(s => s.trim()).filter(Boolean);
         const items = ids.map(id => shoppingListData.items.find(item => item.id === id)).filter(Boolean);
         const viewContent = document.getElementById('view-notes-content');
         if (!viewContent) return;
         viewContent.innerHTML = items.map(item => {
           const productLabel = item.name + (item.description ? ` • ${item.description}` : '');
           const noteHtml = item.note && item.note.trim() !== '' ? item.note : '<p class="text-muted text-sm italic">Keine Notiz</p>';
           return `
             <div class="border-b border-gray-200 dark:border-gray-700 pb-4 last:border-b-0 last:pb-0">
               <div class="font-medium text-gray-900 dark:text-white mb-2">${escapeHtml(productLabel)}</div>
               <div class="prose prose-sm dark:prose-invert max-w-none note-content text-gray-700 dark:text-gray-300">${noteHtml}</div>
             </div>
           `;
         }).join('');
         const modal = document.getElementById('view-notes-modal');
         if (modal) modal.classList.remove('hidden');
         document.body.style.overflow = 'hidden';
       }
       
       function closeViewNotesModal() {
         const modal = document.getElementById('view-notes-modal');
         if (modal) modal.classList.add('hidden');
         document.body.style.overflow = '';
       }
       
       function openAddNoteModal(itemIdsStr) {
         addNoteTargetItemIds = itemIdsStr;
         const ids = itemIdsStr.split(',').map(s => s.trim()).filter(Boolean);
         const items = ids.map(id => shoppingListData.items.find(item => item.id === id)).filter(Boolean);
         if (items.length === 0) return;
         
         const selectorWrap = document.getElementById('add-note-item-selector-wrap');
         const selector = document.getElementById('add-note-item-select');
         const titleEl = document.getElementById('add-note-modal-title');
         if (items.length === 1) {
           if (selectorWrap) selectorWrap.classList.add('hidden');
           if (titleEl) titleEl.textContent = 'Notiz hinzufügen';
           openAddNoteEditor(items[0]);
         } else {
           if (selectorWrap) selectorWrap.classList.remove('hidden');
           if (selector) {
             selector.innerHTML = items.map(item => `
               <option value="${escapeHtml(item.id)}">${escapeHtml(item.name + (item.description ? ' • ' + item.description : ''))}</option>
             `).join('');
             selector.value = items[0].id;
             openAddNoteEditor(items[0]);
             selector.onchange = () => {
               const selected = shoppingListData.items.find(i => i.id === selector.value);
               if (selected) openAddNoteEditor(selected);
             };
           }
           if (titleEl) titleEl.textContent = 'Notiz hinzufügen';
         }
         
         const modal = document.getElementById('add-note-modal');
         if (modal) modal.classList.remove('hidden');
         document.body.style.overflow = 'hidden';
       }
       
       function openAddNoteEditor(item) {
         const existingEditor = typeof tinymce !== 'undefined' && tinymce.get('note-editor-textarea');
         if (existingEditor) {
           existingEditor.setContent(item.note || '');
           return;
         }
         const textarea = document.getElementById('note-editor-textarea');
         if (textarea) textarea.value = item.note || '';
         
         if (typeof tinymce !== 'undefined') {
           requestAnimationFrame(() => {
             const container = document.getElementById('note-editor-container');
             const editorHeight = container ? Math.max(120, Math.round(container.getBoundingClientRect().height)) : 280;
             const isDark = document.documentElement.classList.contains('dark');
             tinymce.init({
             selector: '#note-editor-textarea',
             plugins: 'lists link image code paste',
             toolbar: 'undo redo | bold italic | bullist numlist | link image gallery | code',
             menubar: false,
             height: editorHeight,
             resize: false,
             skin: isDark ? 'oxide-dark' : 'oxide',
             content_css: isDark ? 'dark' : 'default',
             paste_data_images: true,
             images_upload_handler: (blobInfo) => {
               return new Promise((resolve) => {
                 const reader = new FileReader();
                 reader.onload = () => resolve(reader.result);
                 reader.readAsDataURL(blobInfo.blob());
               });
             },
             content_style: isDark
               ? 'body { font-family: inherit; font-size: 14px; background-color: #1f2937; color: #f3f4f6; } body img { max-width: 100%; height: auto; object-fit: contain; }'
               : 'body { font-family: inherit; font-size: 14px; } body img { max-width: 100%; height: auto; object-fit: contain; }',
             setup: (editor) => {
               noteTinyMCE = editor;
               editor.on('init', () => {
                 editor.setContent(item.note || '');
               });
               editor.ui.registry.addButton('gallery', {
                 icon: 'gallery',
                 tooltip: 'Bild aus Galerie (Rezepte / Notizen)',
                 onAction: () => {
                   window.__onGalleryImageSelect = (url) => {
                     if (url) editor.insertContent('<img src="' + url.replace(/"/g, '&quot;') + '" alt="" />');
                     window.__onGalleryImageSelect = null;
                   };
                   if (typeof window.openImageGalleryModal === 'function') window.openImageGalleryModal();
                 }
               });
               editor.ui.registry.addIcon('gallery', '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/><path d="M21 15l-5-5L5 21"/></svg>');
             }
           });
           });
         }
       }
       
       function getCurrentAddNoteItem() {
         const selector = document.getElementById('add-note-item-select');
         const ids = addNoteTargetItemIds ? addNoteTargetItemIds.split(',').map(s => s.trim()) : [];
         if (selector && ids.length > 1) {
           const id = selector.value;
           return shoppingListData.items.find(item => item.id === id);
         }
         if (ids.length === 1) return shoppingListData.items.find(item => item.id === ids[0]);
         return null;
       }
       
       function showAddNoteSaving(show) {
         const overlay = document.getElementById('add-note-saving-overlay');
         const saveBtn = document.getElementById('add-note-save-btn');
         if (overlay) overlay.classList.toggle('hidden', !show);
         if (saveBtn) saveBtn.disabled = show;
         document.querySelectorAll('#add-note-modal .modal-close').forEach(btn => { btn.disabled = show; });
         const ed = typeof tinymce !== 'undefined' ? tinymce.get('note-editor-textarea') : null;
         if (ed) {
           try {
             ed.mode.set(show ? 'readonly' : 'design');
           } catch (_) {}
         }
         const selector = document.getElementById('add-note-item-select');
         if (selector) selector.disabled = show;
       }
       
       async function saveAddNoteModal() {
         const item = getCurrentAddNoteItem();
         if (!item) {
           alert('Kein Artikel ausgewählt. Bitte schließen Sie die Notiz und öffnen Sie sie erneut.');
           return;
         }
         let content = '';
         if (typeof tinymce !== 'undefined') {
           const ed = tinymce.get('note-editor-textarea');
           content = ed ? ed.getContent() : (document.getElementById('note-editor-textarea')?.value || '');
         } else {
           content = document.getElementById('note-editor-textarea')?.value || '';
         }
         const trimmed = (content || '').trim();
         const updatedItems = shoppingListData.items.map(i =>
           i.id === item.id ? { ...i, note: trimmed || undefined } : i
         );
         showAddNoteSaving(true);
         try {
           const response = await fetch(`/api/shopping-lists?id=${shoppingListId}`, {
             method: 'PUT',
             headers: { 'Content-Type': 'application/json' },
             body: JSON.stringify({ items: updatedItems }),
           });
           if (response.ok) {
             const updatedList = await response.json();
             shoppingListData.items = updatedList.items;
             renderShoppingItems();
             closeAddNoteModal();
           } else {
             const err = await response.json().catch(() => ({}));
             alert(err.error || 'Fehler beim Speichern der Notiz');
           }
         } catch (e) {
           console.error('Save note error:', e);
           alert('Fehler beim Speichern der Notiz');
         } finally {
           showAddNoteSaving(false);
         }
       }
       
       function closeAddNoteModal() {
         if (typeof tinymce !== 'undefined' && noteTinyMCE) {
           tinymce.get('note-editor-textarea')?.remove();
           noteTinyMCE = null;
         }
         const modal = document.getElementById('add-note-modal');
         if (modal) modal.classList.add('hidden');
         document.body.style.overflow = '';
         addNoteTargetItemIds = null;
       }
       
       function escapeHtml(text) {
         const div = document.createElement('div');
         div.textContent = text;
         return div.innerHTML;
       }
       
       function attachNoteListeners() {
         document.querySelectorAll('.item-note-info, .detail-item-note-info').forEach(btn => {
           btn.addEventListener('click', (e) => {
             e.stopPropagation();
             const itemIds = btn.getAttribute('data-item-ids');
             if (itemIds) openViewNotesModal(itemIds);
           });
         });
         
         document.querySelectorAll('.add-note-plus-btn').forEach(btn => {
           btn.addEventListener('click', (e) => {
             e.stopPropagation();
             const itemIds = btn.getAttribute('data-item-ids');
             if (itemIds) openAddNoteModal(itemIds);
           });
         });
         
         // Long-press on .shopping-item (main row) to open add-note
         document.querySelectorAll('.shopping-item-group .shopping-item').forEach(row => {
           let longPressTimer = null;
           const handleStart = (e) => {
             if (e.target.closest('.item-checkbox') || e.target.closest('.group-selection-checkbox') || e.target.closest('.add-note-plus-btn') || e.target.closest('.item-note-info') || e.target.closest('.recipe-highlight-btn')) return;
             longPressTimer = setTimeout(() => {
               longPressTimer = null;
               const group = row.closest('.shopping-item-group');
               const itemIds = group?.getAttribute('data-item-ids') || '';
               if (itemIds) openAddNoteModal(itemIds);
             }, 500);
           };
           const handleEnd = () => {
             if (longPressTimer) clearTimeout(longPressTimer);
             longPressTimer = null;
           };
           const handleMove = (e) => {
             if (longPressTimer && e.touches && e.touches[0]) {
               const t = e.touches[0];
               if (Math.abs(t.clientX - (row._lpX||0)) > 15 || Math.abs(t.clientY - (row._lpY||0)) > 15) {
                 clearTimeout(longPressTimer);
                 longPressTimer = null;
               }
             }
           };
           row.addEventListener('touchstart', (e) => {
             if (e.touches[0]) { row._lpX = e.touches[0].clientX; row._lpY = e.touches[0].clientY; }
             handleStart(e);
           }, { passive: true });
           row.addEventListener('touchend', handleEnd, { passive: true });
           row.addEventListener('touchmove', handleMove, { passive: true });
           row.addEventListener('touchcancel', handleEnd, { passive: true });
         });
         
       }
       
       // One-time: modal close (overlay/buttons), save button via delegation, and Escape
       // Module scripts run after DOM is ready, so attach immediately (DOMContentLoaded has already fired)
       document.addEventListener('click', (e) => {
         const closeTarget = e.target.closest?.('[data-close]');
         if (closeTarget) {
           if (closeTarget.getAttribute('data-close') === 'view-notes-modal') {
             closeViewNotesModal();
             e.preventDefault();
           } else if (closeTarget.getAttribute('data-close') === 'add-note-modal') {
             closeAddNoteModal();
             e.preventDefault();
           }
           return;
         }
         if (e.target.closest?.('#add-note-save-btn')) {
           e.preventDefault();
           saveAddNoteModal();
         }
       });
       document.addEventListener('keydown', (e) => {
         if (e.key !== 'Escape') return;
         if (!document.getElementById('view-notes-modal')?.classList.contains('hidden')) {
           closeViewNotesModal();
           e.preventDefault();
         } else if (!document.getElementById('add-note-modal')?.classList.contains('hidden')) {
           closeAddNoteModal();
           e.preventDefault();
         }
       });
       
       // Function to attach checkbox event listeners
       function attachCheckboxListeners() {
         document.querySelectorAll('.item-checkbox').forEach(checkbox => {
          checkbox.addEventListener('change', async (e) => {
          // Don't handle item checkbox changes in grouping mode
          if (isGroupingMode) {
            e.preventDefault();
            e.stopPropagation();
            return;
          }
          
          const target = e.target;
          const itemElement = target.closest('.shopping-item-group');
          const itemIdsAttr = itemElement.getAttribute('data-item-ids');
          if (!itemIdsAttr) {
            console.error('No data-item-ids found on element:', itemElement);
            return;
          }
          const itemIds = itemIdsAttr.split(',');
          const isChecked = target.checked;

          try {
            // Update all items in the group
            const updatedItems = shoppingListData.items.map(item => 
              itemIds.includes(item.id) ? { ...item, isChecked } : item
            );

            const response = await fetch(`/api/shopping-lists?id=${shoppingListId}`, {
              method: 'PUT',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                items: updatedItems
              }),
            });

            if (response.ok) {
              // Update local data
              shoppingListData.items = updatedItems;
              
              // Re-render the items to show updated grouping
              renderShoppingItems();
              
              // Update header counter
              updateHeaderCounters();
            } else {
              // Revert checkbox if API call failed
              target.checked = !isChecked;
              
              const error = await response.json();
              console.error('Error updating item:', error);
              alert('Fehler beim Aktualisieren des Artikels');
            }
          } catch (error) {
            console.error('Error updating item:', error);
            
            // Revert checkbox if API call failed
            target.checked = !isChecked;
            
            alert('Fehler beim Aktualisieren des Artikels');
          }
        });
      });
      }
      
      // Initial render
      renderShoppingItems();



      // Function to update header counters
      function updateHeaderCounters() {
        const uncheckedCount = shoppingListData.items.filter(item => !item.isChecked).length;
        const totalCount = shoppingListData.items.length;
        
        // Update counter in header
        const counterElement = document.querySelector('p.text-sm.text-muted');
        if (counterElement) {
          counterElement.textContent = `${uncheckedCount} von ${totalCount} Artikeln offen`;
        }
        
        // Update main heading counter for items section only
        const itemsHeadingElement = document.getElementById('items-heading');
        if (itemsHeadingElement) {
          itemsHeadingElement.textContent = `Einkaufsliste (${totalCount} Artikel)`;
        }
      }

      // Add item modal handling
      const addItemBtn = document.getElementById('add-item-btn');
      const addItemModal = document.getElementById('add-item-modal');
      const addItemForm = document.getElementById('add-item-form');
      const closeButtons = addItemModal?.querySelectorAll('.modal-close');

      addItemBtn?.addEventListener('click', () => {
        addItemModal?.classList.remove('hidden');
        document.getElementById('item-name')?.focus();
      });

      closeButtons?.forEach(btn => {
        btn.addEventListener('click', () => {
          addItemModal?.classList.add('hidden');
          addItemForm?.reset();
        });
      });

      addItemModal?.querySelector('.modal-overlay')?.addEventListener('click', () => {
        addItemModal?.classList.add('hidden');
        addItemForm?.reset();
      });

      addItemForm?.addEventListener('submit', async (e) => {
        e.preventDefault();
        
        const formData = new FormData(addItemForm);
        const name = formData.get('name');
        const amountValue = formData.get('amount');
        const unitValue = formData.get('unit');
        const description = formData.get('description');

        if (!name.trim()) {
          alert('Bitte geben Sie einen Namen für den Artikel ein.');
          return;
        }

        // Make amount and unit optional - only include quantity if both are provided
        const amount = amountValue && !isNaN(parseFloat(amountValue)) ? parseFloat(amountValue) : null;
        const unit = unitValue && unitValue.trim() ? unitValue.trim() : null;
        
        // Only include quantity if both amount and unit are provided (no defaults)
        const item = {
          name: name.trim(),
          description: description.trim() || undefined,
          isChecked: false
        };
        
        if (amount !== null && unit !== null) {
          item.quantity = { amount, unit };
        }

        try {
          const response = await fetch(`/api/shopping-lists?id=${shoppingListId}`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              action: 'add-item',
              item
            }),
          });

          if (response.ok) {
            const updatedList = await response.json();
            shoppingListData.items = updatedList.items;
            
            // Re-render the items to show new item
            renderShoppingItems();
            updateHeaderCounters();
            
            // Close modal and reset form
            addItemModal?.classList.add('hidden');
            addItemForm?.reset();
          } else {
            const error = await response.json();
            alert(error.error || 'Fehler beim Hinzufügen des Artikels');
          }
        } catch (error) {
          console.error('Error adding item:', error);
          alert('Fehler beim Hinzufügen des Artikels');
        }
      });

      // Helper functions for recipe data structure
      function getRecipeIngredients(recipe) {
        const ingredients = [];
        
        function extractIngredientsFromGroup(group) {
          if (group.ingredients) {
            group.ingredients.forEach(item => {
              if (item.ingredients) {
                // It's a nested group
                extractIngredientsFromGroup(item);
              } else if (item.name) {
                // It's an ingredient
                ingredients.push(item);
              }
            });
          }
        }
        
        if (recipe.ingredientGroups) {
          recipe.ingredientGroups.forEach(group => extractIngredientsFromGroup(group));
        }
        
        return ingredients;
      }

      function getRecipeIngredientCount(recipe) {
        return getRecipeIngredients(recipe).length;
      }

      function toggleRecipeHighlight(recipeId) {
        console.log('toggleRecipeHighlight called with recipeId:', recipeId);
        
        // Clear existing highlights
        clearRecipeHighlights();
        
        if (currentlyHighlightedRecipe === recipeId) {
          console.log('Same recipe clicked, clearing highlight');
          // If same recipe clicked, just clear highlights
          currentlyHighlightedRecipe = null;
          return;
        }
        
        // Set new highlight
        currentlyHighlightedRecipe = recipeId;
        console.log('Setting new highlight for recipe:', recipeId);
        highlightRecipeIngredients(recipeId);
      }

      function clearRecipeHighlights() {
        console.log('Clearing all recipe highlights');
        // Remove all highlights from shopping item groups
        document.querySelectorAll('.shopping-item-group').forEach(group => {
          group.classList.remove('highlighted');
          
          // Collapse any expanded groups
          const expandableItem = group.querySelector('[data-expandable="true"]');
          if (expandableItem) {
            const details = group.querySelector('.item-details');
            const expandIcon = group.querySelector('.expand-icon');
            
            if (details && expandIcon) {
              // Collapse the group
              details.classList.add('hidden');
              expandIcon.style.transform = 'rotate(0deg)';
            }
          }
        });
        
        // Remove highlights from individual detail items
        document.querySelectorAll('.detail-item-highlighted').forEach(item => {
          item.classList.remove('detail-item-highlighted');
        });
        
        // Remove active state from recipe cards
        document.querySelectorAll('.recipe-item').forEach(card => {
          card.classList.remove('active');
        });
      }

      function highlightRecipeIngredients(recipeId) {
        console.log('Highlighting ingredients for recipe:', recipeId);
        // Find all shopping item groups that belong to this recipe
        document.querySelectorAll('.shopping-item-group').forEach(group => {
          const recipeIds = group.getAttribute('data-recipe-ids');
          console.log('Group recipe IDs:', recipeIds);
          if (recipeIds && recipeIds.split(',').includes(recipeId)) {
            console.log('Found matching group:', group);
            group.classList.add('highlighted');
            
            // Auto-expand groups that have multiple items
            const expandableItem = group.querySelector('[data-expandable="true"]');
            if (expandableItem) {
              const details = group.querySelector('.item-details');
              const expandIcon = group.querySelector('.expand-icon');
              
              if (details && expandIcon) {
                // Expand the group
                details.classList.remove('hidden');
                expandIcon.style.transform = 'rotate(180deg)';
                
                // Highlight individual items from this recipe in the details
                highlightIndividualItems(group, recipeId);
              }
            }
          }
        });
        
        // Mark recipe card as active
        document.querySelectorAll('.recipe-item').forEach(card => {
          const cardRecipeId = card.getAttribute('data-recipe-id');
          console.log('Checking recipe card:', cardRecipeId);
          if (cardRecipeId === recipeId) {
            console.log('Found matching card, adding active class');
            card.classList.add('active');
          }
        });
      }
      
      function highlightIndividualItems(group, recipeId) {
        console.log('Highlighting individual items in group for recipe:', recipeId);
        // Highlight individual detail items that belong to this recipe
        const details = group.querySelector('.item-details');
        if (details) {
          const detailItems = details.querySelectorAll('.detail-item');
          
          detailItems.forEach(detailItem => {
            const itemId = detailItem.getAttribute('data-item-id');
            const item = shoppingListData.items.find(item => item.id === itemId);
            
            if (item && item.recipeId === recipeId) {
              console.log('Found matching detail item:', itemId);
              detailItem.classList.add('detail-item-highlighted');
            }
          });
        }
      }

      // Load recipes for modal
      async function loadRecipes() {
        try {
          const response = await fetch('/api/recipes');
          if (response.ok) {
            availableRecipes = await response.json();
            populateRecipeModal();
          }
        } catch (error) {
          console.error('Error loading recipes:', error);
        }
      }

      // Populate recipe modal
      function populateRecipeModal() {
        const recipeLoading = document.getElementById('recipe-loading');
        const recipeList = document.getElementById('recipe-list');
        const availableRecipesContainer = document.getElementById('available-recipes');
        const noRecipesFound = document.getElementById('no-recipes-found');
        
        recipeLoading?.classList.add('hidden');
        recipeList?.classList.remove('hidden');
        
        if (availableRecipes.length === 0) {
          availableRecipesContainer.innerHTML = '';
          noRecipesFound?.classList.remove('hidden');
          return;
        }
        
        noRecipesFound?.classList.add('hidden');
        renderAvailableRecipes(availableRecipes);
      }

      // Render available recipes
      function renderAvailableRecipes(recipes) {
        const container = document.getElementById('available-recipes');
        if (!container) return;
        
        // Build a map of all available recipes by ID (includes variants)
        const recipeMap = new Map();
        (availableRecipes || []).forEach((r) => {
          if (r && r.id) {
            recipeMap.set(r.id, r);
          }
        });

        // Track which exact recipe IDs (originals or variants) are already in the shopping list
        const addedRecipeIds = new Set(
          (shoppingListData.recipes || []).map((r) => r.id)
        );
        
        // Group recipes by their root/original recipe ID so variants are shown together
        const groups = new Map();
        recipes.forEach((recipe) => {
          const rootId = recipe.parentRecipeId || recipe.id;
          if (!groups.has(rootId)) {
            const rootRecipe = recipeMap.get(rootId) || recipe;
            groups.set(rootId, { root: rootRecipe, items: [] });
          }
          groups.get(rootId).items.push(recipe);
        });

        container.innerHTML = Array.from(groups.entries()).map(([rootId, group]) => {
          const rootRecipe = group.root || group.items[0];
          const groupItems = group.items;
          const totalInGroup = groupItems.length;
          const addedInGroup = groupItems.filter((v) => addedRecipeIds.has(v.id)).length;
          const isGroupFullyAdded = totalInGroup > 0 && addedInGroup === totalInGroup;
          const cardClasses = isGroupFullyAdded 
            ? 'recipe-card border border-gray-200 dark:border-gray-700 rounded-lg p-4 bg-gray-100 dark:bg-gray-800 opacity-50 cursor-not-allowed transition-colors'
            : 'recipe-card border border-gray-300 dark:border-gray-600 rounded-lg p-4 hover:border-orange-500 cursor-pointer transition-colors';

          const variantRows = groupItems.map((variantRecipe) => {
            const isOriginal = !variantRecipe.parentRecipeId;
            const label = isOriginal
              ? 'Original'
              : (variantRecipe.variantName || 'Variante');
            const ingredientCount = getRecipeIngredientCount(variantRecipe);

            const isVariantAlreadyAdded = addedRecipeIds.has(variantRecipe.id);
            const isSelected = selectedRecipeIds.has(variantRecipe.id);

            if (isVariantAlreadyAdded) {
              return `
                <div class="flex items-center justify-between text-sm text-gray-600 dark:text-gray-300 mt-1">
                  <div class="flex items-center space-x-2">
                    <div class="w-5 h-5 bg-gray-300 dark:bg-gray-600 rounded flex items-center justify-center">
                      <svg class="w-3 h-3 text-gray-500" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                      </svg>
                    </div>
                    <span>${label}</span>
                  </div>
                  <span class="text-xs text-gray-500 dark:text-gray-400">${ingredientCount} Zutaten</span>
                </div>
              `;
            }

            return `
              <label class="flex items-center justify-between text-sm text-gray-700 dark:text-gray-200 mt-1 cursor-pointer">
                <div class="flex items-center space-x-2">
                  <input 
                    type="checkbox" 
                    class="recipe-checkbox w-4 h-4 text-orange-600 bg-gray-100 border-gray-300 rounded focus:ring-orange-500 focus:ring-2" 
                    data-recipe-id="${variantRecipe.id}" 
                    ${isSelected ? 'checked' : ''}
                  />
                  <span>${label}</span>
                </div>
                <span class="text-xs text-gray-500 dark:text-gray-400">${ingredientCount} Zutaten</span>
              </label>
            `;
          }).join('');

          return `
            <div class="${cardClasses}" data-root-recipe-id="${rootId}">
              <div class="flex items-start space-x-3">
                ${rootRecipe.images && rootRecipe.images.length > 0 
                  ? `<img src="${rootRecipe.images[0].url}" alt="${rootRecipe.title}" class="w-16 h-16 object-cover rounded-lg ${isGroupFullyAdded ? 'grayscale' : ''}">`
                  : `<div class="w-16 h-16 bg-gray-200 dark:bg-gray-700 rounded-lg flex items-center justify-center">
                       <svg class="w-8 h-8 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                         <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"/>
                       </svg>
                     </div>`
                }
                <div class="flex-1 min-w-0">
                  <h3 class="font-medium ${isGroupFullyAdded ? 'text-gray-500 dark:text-gray-400' : 'text-gray-900 dark:text-white'} truncate">
                    ${rootRecipe.title}
                    ${isGroupFullyAdded ? '<span class="text-xs ml-2 bg-green-100 dark:bg-green-800 text-green-800 dark:text-green-200 px-2 py-0.5 rounded">Bereits hinzugefügt</span>' : ''}
                  </h3>
                  ${rootRecipe.description ? `<p class="text-sm text-muted mt-1 line-clamp-2">${rootRecipe.description}</p>` : ''}
                  <div class="mt-2 space-y-1">
                    ${variantRows}
                  </div>
                </div>
              </div>
            </div>
          `;
        }).join('');
        
        // Attach change handlers for checkboxes and ensure their checked state reflects the selection set
        container.querySelectorAll('.recipe-checkbox').forEach((checkbox) => {
          const recipeId = checkbox.getAttribute('data-recipe-id');
          if (recipeId && selectedRecipeIds.has(recipeId)) {
            checkbox.checked = true;
          }

          checkbox.addEventListener('change', (event) => {
            const target = event.target;
            const id = target.getAttribute('data-recipe-id');
            if (!id) return;

            if (target.checked) {
              selectedRecipeIds.add(id);
            } else {
              selectedRecipeIds.delete(id);
            }

            updateSelectedCount();
          });
        });
        
        // Update selected count
        updateSelectedCount();
      }

      // Update selected count and button state
      function updateSelectedCount() {
        const selectedCount = selectedRecipeIds.size;
        const selectedCountElement = document.getElementById('selected-recipes-count');
        const addSelectedButton = document.getElementById('add-selected-recipes');
        const selectAllCheckbox = document.getElementById('select-all-recipes');
        
        // Update count display
        if (selectedCountElement) {
          selectedCountElement.textContent = `${selectedCount} Rezept${selectedCount !== 1 ? 'e' : ''} ausgewählt`;
        }
        
        // Update add button state
        if (addSelectedButton) {
          addSelectedButton.disabled = selectedCount === 0;
        }
        
        // Update select all checkbox state relative to currently visible recipes
        if (selectAllCheckbox) {
          const allCheckboxes = document.querySelectorAll('.recipe-checkbox');
          const totalVisible = allCheckboxes.length;

          if (totalVisible === 0) {
            selectAllCheckbox.checked = false;
            selectAllCheckbox.indeterminate = false;
          } else {
            let selectedVisible = 0;
            allCheckboxes.forEach((checkbox) => {
              const id = checkbox.getAttribute('data-recipe-id');
              if (id && selectedRecipeIds.has(id)) {
                selectedVisible += 1;
              }
            });

            selectAllCheckbox.checked = selectedVisible > 0 && selectedVisible === totalVisible;
            selectAllCheckbox.indeterminate = selectedVisible > 0 && selectedVisible < totalVisible;
          }
        }
      }

      // Search recipes
      const recipeSearch = document.getElementById('recipe-search');
      recipeSearch?.addEventListener('input', (e) => {
        const searchTerm = e.target.value.toLowerCase();
        const filteredRecipes = availableRecipes.filter(recipe => 
          recipe.title.toLowerCase().includes(searchTerm) ||
          recipe.description?.toLowerCase().includes(searchTerm) ||
          getRecipeIngredients(recipe).some(ing => ing.name.toLowerCase().includes(searchTerm))
        );
        renderAvailableRecipes(filteredRecipes);
      });

      // Add multiple recipes to shopping list
      async function addMultipleRecipesToShoppingList(recipeIds) {
        try {
          // Add recipes one by one (we could optimize this later with a batch API)
          for (const recipeId of recipeIds) {
            const response = await fetch(`/api/shopping-lists?id=${shoppingListId}`, {
              method: 'PUT',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                action: 'add-recipe',
                recipeId: recipeId
              }),
            });

            if (!response.ok) {
              const error = await response.json();
              throw new Error(error.error || `Fehler beim Hinzufügen von Rezept ${recipeId}`);
            }
          }

          // Reload the shopping list to get all updates
          const response = await fetch(`/api/shopping-lists?id=${shoppingListId}`);
          if (response.ok) {
            const updatedList = await response.json();
            shoppingListData.items = updatedList.items;
            shoppingListData.recipes = updatedList.recipes || [];
            
            // Re-render everything
            renderShoppingItems();
            renderShoppingRecipes();
            updateHeaderCounters();
            
            // Re-render recipe modal to show updated state
            renderAvailableRecipes(availableRecipes);
            
            // Show success message
            const recipeCount = recipeIds.length;
            alert(`${recipeCount} Rezept${recipeCount !== 1 ? 'e wurden' : ' wurde'} zur Einkaufsliste hinzugefügt!`);
          }
        } catch (error) {
          console.error('Error adding recipes:', error);
          alert('Fehler beim Hinzufügen der Rezepte: ' + error.message);
        }
      }

      // Add single recipe to shopping list (legacy function for compatibility)
      async function addRecipeToShoppingList(recipeId) {
        await addMultipleRecipesToShoppingList([recipeId]);
      }

      // Initial render of recipes
      renderShoppingRecipes();
      
      // Function to render shopping recipes
      function renderShoppingRecipes() {
        const section = document.getElementById('shopping-recipes-section');
        const container = document.getElementById('shopping-recipes');
        
        if (!section || !container) return;
        
        if (!shoppingListData.recipes || shoppingListData.recipes.length === 0) {
          section.style.display = 'none';
          return;
        }
        
        section.style.display = 'block';
        
        // Get the template
        const template = document.getElementById('recipe-template');
        if (!template) {
          console.error('Recipe template not found');
          return;
        }
        
        // Clear the container
        container.innerHTML = '';
        
        // Add each recipe
        shoppingListData.recipes.forEach(recipe => {
          // Clone the template
          const clone = template.content.cloneNode(true);
          const recipeElement = clone.querySelector('.recipe-item');
          
          // Set recipe ID
          recipeElement.setAttribute('data-recipe-id', recipe.id);
          
          // Set title
          const titleElement = clone.querySelector('.recipe-title');
          if (titleElement) {
            titleElement.textContent = recipe.title;
          }
          
                    // Set info text
           const infoElement = clone.querySelector('.recipe-info');
           if (infoElement) {
             const recipeItemCount = shoppingListData.items.filter(item => item.recipeId === recipe.id).length;
             infoElement.textContent = `${recipeItemCount} Zutaten in der Liste`;
           }
          
          // Set servings
          const servingsInput = clone.querySelector('.portion-input');
          if (servingsInput) {
            servingsInput.value = recipe.currentServings || recipe.servings;
            servingsInput.setAttribute('data-recipe-id', recipe.id);
          }
          
          // Set original servings
          const originalServingsElement = clone.querySelector('.original-servings');
          if (originalServingsElement) {
            originalServingsElement.textContent = recipe.servings;
          }
          
          // Set recipe link
          const recipeLink = clone.querySelector('.recipe-link');
          if (recipeLink) {
            recipeLink.href = `/rezept/${recipe.id}`;
          }
          
          // Add event listeners
          const decreaseBtn = clone.querySelector('.portion-decrease');
          const increaseBtn = clone.querySelector('.portion-increase');
          const portionInput = clone.querySelector('.portion-input');
          const removeBtn = clone.querySelector('.remove-recipe');
          
          if (decreaseBtn && portionInput) {
            decreaseBtn.addEventListener('click', () => {
              const currentValue = parseInt(portionInput.value);
              if (currentValue > 1) {
                portionInput.value = currentValue - 1;
                updateRecipePortions(portionInput);
              }
            });
          }
          
          if (increaseBtn && portionInput) {
            increaseBtn.addEventListener('click', () => {
              const currentValue = parseInt(portionInput.value);
              portionInput.value = currentValue + 1;
              updateRecipePortions(portionInput);
            });
          }
          
          if (portionInput) {
            portionInput.addEventListener('change', (e) => {
              updateRecipePortions(e.target);
            });
          }
          
          if (removeBtn) {
            removeBtn.addEventListener('click', async (e) => {
              e.stopPropagation();
              if (confirm('Möchten Sie dieses Rezept wirklich aus der Einkaufsliste entfernen?')) {
                await removeRecipeFromShoppingList(recipe.id);
              }
            });
          }
          
          // Add click handler for recipe highlighting
          recipeElement.addEventListener('click', (e) => {
            // Don't trigger if clicking on a button or input
            if (!e.target.closest('.recipe-action')) {
              toggleRecipeHighlight(recipe.id);
            }
          });
          
          container.appendChild(clone);
        });
      }
      
      // Function to update recipe portions and scale ingredients
      async function updateRecipePortions(input) {
        const recipeId = input.getAttribute('data-recipe-id');
        const newServings = parseInt(input.value);
        
        if (!recipeId || !newServings || newServings < 1) {
          console.error('Invalid input for portion update');
          return;
        }
        
        console.log('Updating portions for recipe:', recipeId, 'to', newServings);
        
        try {
          const response = await fetch(`/api/shopping-lists/${shoppingListData.id}/recipes/${recipeId}/servings`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              servings: newServings
            })
          });
          
          if (response.ok) {
            const updatedList = await response.json();
            
            // Update local data by copying properties instead of reassignment
            Object.assign(shoppingListData, updatedList);
            
            // Re-render items to show updated quantities
            renderShoppingItems();
            renderShoppingRecipes();
            
            console.log('Successfully updated portions');
          } else {
            console.error('Failed to update portions:', response.statusText);
            
            // Reset to original value
            const recipe = shoppingListData.recipes.find(r => r.id === recipeId);
            if (recipe) {
              input.value = recipe.currentServings || recipe.servings;
            }
          }
        } catch (error) {
          console.error('Error updating portions:', error);
          
          // Reset to original value
          const recipe = shoppingListData.recipes.find(r => r.id === recipeId);
          if (recipe) {
            input.value = recipe.currentServings || recipe.servings;
          }
        }
      }
      
      // Setup Server-Sent Events for real-time updates
      let eventSource = null;
      let reconnectTimer = null;
      let isOnline = navigator.onLine;
      
      function connectSSE() {
        if (eventSource) {
          eventSource.close();
        }
        
        try {
          eventSource = new EventSource(`/api/shopping-lists/stream?listId=${shoppingListId}`);
          
          eventSource.onopen = () => {
            console.log('✅ Real-time sync connected');
            // Clear any reconnect timer
            if (reconnectTimer) {
              clearTimeout(reconnectTimer);
              reconnectTimer = null;
            }
            // Show online indicator
            showSyncStatus('online');
          };
          
          eventSource.onmessage = (event) => {
            try {
              const data = JSON.parse(event.data);
              
              if (data.type === 'connected') {
                console.log('Connected to shopping list updates');
              } else if (data.type === 'update' && data.data) {
                // Update received from another client
                console.log('📱 Real-time update received');
                updateFromServer(data.data);
                showSyncStatus('synced');
              }
            } catch (error) {
              console.error('Error parsing SSE message:', error);
            }
          };
          
          eventSource.onerror = (error) => {
            console.log('❌ Real-time sync disconnected');
            showSyncStatus('offline');
            
            // Attempt to reconnect after delay
            if (!reconnectTimer) {
              reconnectTimer = setTimeout(() => {
                if (isOnline) {
                  console.log('🔄 Attempting to reconnect...');
                  connectSSE();
                }
              }, 3000);
            }
          };
          
        } catch (error) {
          console.error('Error setting up SSE:', error);
          showSyncStatus('offline');
        }
      }
      
      function updateFromServer(updatedList) {
        if (!updatedList) return;
        
        // Only update if data is different
        const currentItemsJson = JSON.stringify(shoppingListData.items || []);
        const newItemsJson = JSON.stringify(updatedList.items || []);
        const currentRecipesJson = JSON.stringify(shoppingListData.recipes || []);
        const newRecipesJson = JSON.stringify(updatedList.recipes || []);
        
        if (currentItemsJson !== newItemsJson || currentRecipesJson !== newRecipesJson) {
          // Update properties individually to avoid reassignment
          if (updatedList.items) {
            shoppingListData.items = updatedList.items;
          }
          if (updatedList.recipes) {
            shoppingListData.recipes = updatedList.recipes;
          }
          
          // Re-render the UI
          renderShoppingItems();
          renderShoppingRecipes();
        }
      }
      
      function showSyncStatus(status) {
        let indicator;
        
        // Remove any existing sync status indicators
        document.querySelectorAll('.sync-status').forEach(el => el.remove());
        
        // Create new indicator based on status
        if (status === 'online') {
          indicator = '<span class="sync-status text-xs text-green-600 dark:text-green-400 flex items-center space-x-1"><span class="w-2 h-2 bg-green-500 rounded-full"></span><span>Live</span></span>';
        } else if (status === 'synced') {
          indicator = '<span class="sync-status text-xs text-blue-600 dark:text-blue-400 flex items-center space-x-1"><span class="w-2 h-2 bg-blue-500 rounded-full animate-pulse"></span><span>Synchronisiert</span></span>';
          // Hide synced indicator after 2 seconds and restore live indicator
          setTimeout(() => {
            document.querySelector('.sync-status')?.remove();
            showSyncStatus('online');
          }, 2000);
        } else {
          indicator = '<span class="sync-status text-xs text-red-600 dark:text-red-400 flex items-center space-x-1"><span class="w-2 h-2 bg-red-500 rounded-full"></span><span>Offline</span></span>';
        }
        
        // Insert the indicator into the container
        const container = document.getElementById('sync-status-container');
        if (container) {
          container.innerHTML = indicator;
        }
      }
      
      // Handle online/offline status
      window.addEventListener('online', () => {
        isOnline = true;
        connectSSE();
      });
      
      window.addEventListener('offline', () => {
        isOnline = false;
        showSyncStatus('offline');
        if (eventSource) {
          eventSource.close();
          eventSource = null;
        }
      });
      
      // Setup SSE connection
      if (isOnline) {
        connectSSE();
      }
      
      // Cleanup on page unload
      window.addEventListener('beforeunload', () => {
        if (eventSource) {
          eventSource.close();
        }
        if (reconnectTimer) {
          clearTimeout(reconnectTimer);
        }
      });

      // Function to remove a recipe from the shopping list
      async function removeRecipeFromShoppingList(recipeId) {
        try {
          const response = await fetch(`/api/shopping-lists/${shoppingListData.id}/recipes`, {
            method: 'DELETE',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              recipeId: recipeId
            })
          });
          
          if (response.ok) {
            // Update local data
            shoppingListData.recipes = shoppingListData.recipes.filter(r => r.id !== recipeId);
            shoppingListData.items = shoppingListData.items.filter(item => item.recipeId !== recipeId);
            
            // Clear highlights if this recipe was highlighted
            if (currentlyHighlightedRecipe === recipeId) {
              clearRecipeHighlights();
              currentlyHighlightedRecipe = null;
            }
            
            // Re-render the UI
            renderShoppingItems();
            renderShoppingRecipes();
          } else {
            console.error('Failed to remove recipe:', response.statusText);
            alert('Fehler beim Entfernen des Rezepts');
          }
        } catch (error) {
          console.error('Error removing recipe:', error);
          alert('Fehler beim Entfernen des Rezepts');
        }
      }

      // Add recipe modal handling
      const addRecipeBtn = document.getElementById('add-recipe-btn');
      const addRecipeModal = document.getElementById('add-recipe-modal');
      const selectAllRecipes = document.getElementById('select-all-recipes');
      const addSelectedRecipesBtn = document.getElementById('add-selected-recipes');

      // Open recipe modal and load recipes
      addRecipeBtn?.addEventListener('click', () => {
        // Reset selection state when opening the modal
        selectedRecipeIds.clear();
        if (selectAllRecipes) {
          selectAllRecipes.checked = false;
          selectAllRecipes.indeterminate = false;
        }

        addRecipeModal?.classList.remove('hidden');
        loadRecipes();
      });

      // Close recipe modal
      addRecipeModal?.querySelector('.modal-close')?.addEventListener('click', () => {
        addRecipeModal?.classList.add('hidden');
      });

      addRecipeModal?.querySelector('.modal-overlay')?.addEventListener('click', () => {
        addRecipeModal?.classList.add('hidden');
      });

      // Handle select all recipes
      selectAllRecipes?.addEventListener('change', (e) => {
        const target = e.target;
        const shouldSelectAll = target.checked;

        const checkboxes = document.querySelectorAll('.recipe-checkbox');
        checkboxes.forEach((checkbox) => {
          const input = checkbox;
          const recipeId = input.getAttribute('data-recipe-id');
          if (!recipeId) return;

          input.checked = shouldSelectAll;

          if (shouldSelectAll) {
            selectedRecipeIds.add(recipeId);
          } else {
            selectedRecipeIds.delete(recipeId);
          }
        });

        updateSelectedCount();
      });

      // Handle add selected recipes
      addSelectedRecipesBtn?.addEventListener('click', async () => {
        const selectedRecipes = Array.from(selectedRecipeIds);

        if (selectedRecipes.length > 0) {
          await addMultipleRecipesToShoppingList(selectedRecipes);
          addRecipeModal?.classList.add('hidden');
        }
      });
    });
  </script>
</Layout> 