---
// Component for handling ingredient linking functionality
---

<!-- Ingredient Linking Modal -->
<div id="ingredient-link-modal" class="fixed inset-0 bg-black bg-opacity-50 z-50 hidden flex items-center justify-center">
  <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg max-w-2xl w-full mx-4 max-h-[80vh] overflow-y-auto">
    <div class="p-6">
      <div class="flex items-center justify-between mb-4">
        <h3 class="text-lg font-semibold text-gray-900 dark:text-white">
          Zutaten manuell verlinken
        </h3>
        <button type="button" id="cancel-link-modal" class="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300">
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
          </svg>
        </button>
      </div>
      
      <div class="mb-4">
        <p class="text-sm text-gray-600 dark:text-gray-400 mb-3">
          Wählen Sie die Zutaten aus, die in diesem Zubereitungsschritt verwendet werden:
        </p>
        <div id="ingredient-list" class="space-y-2 max-h-60 overflow-y-auto">
          <!-- Ingredients will be populated dynamically -->
        </div>
      </div>
      
      <div class="flex justify-end space-x-3">
        <button type="button" id="cancel-link-modal" class="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 hover:bg-gray-200 dark:bg-gray-700 dark:text-gray-300 dark:hover:bg-gray-600 rounded-md transition-colors">
          Abbrechen
        </button>
        <button type="button" id="save-link-modal" class="px-4 py-2 text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 rounded-md transition-colors">
          Verknüpfungen speichern
        </button>
      </div>
    </div>
  </div>
</div>

<script>
// Extend Window interface for our custom properties
declare global {
  interface Window {
    currentRecipe: any;
    ingredientLinker: IngredientLinker;
    IngredientLinker: typeof IngredientLinker;
  }
}

interface LinkedIngredient {
  ingredientId: string;
  selectedQuantityIndex: number;
}

interface Recipe {
  preparationGroups: Array<{
    steps: Array<{
      id: string;
      text: string;
      linkedIngredients?: LinkedIngredient[];
    }>;
  }>;
  ingredientGroups: Array<{
    ingredients: Array<{
      id: string;
      name: string;
      quantities: Array<{
        amount: number;
        unit: string;
      }>;
    }>;
  }>;
}

class IngredientLinker {
  private currentStepElement: HTMLElement | null = null;
  private currentStepId: string | null = null;
  private recipe: Recipe | null = null;
  private linkedIngredients = new Map<string, LinkedIngredient[]>(); // stepId -> linkedIngredients array

  constructor() {
    this.init();
  }

  init(): void {
    // Get recipe data from page context
    if (window.currentRecipe) {
      this.recipe = window.currentRecipe;
      this.loadExistingLinks();
    }
    
    this.bindEvents();
    
    // Also listen for edit mode changes to refresh displays
    this.setupEditModeListener();
  }

  setupEditModeListener(): void {
    // Watch for edit mode activation to refresh displays
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
          const editContent = document.getElementById('edit-content');
          if (editContent && !editContent.classList.contains('hidden')) {
            // Edit mode activated, refresh all displays after a short delay
            setTimeout(() => {
              this.refreshAllDisplays();
            }, 200);
          }
        }
      });
    });
    
    const editContent = document.getElementById('edit-content');
    if (editContent) {
      observer.observe(editContent, { attributes: true });
    }
  }

  refreshAllDisplays(): void {
    // Refresh all step displays with current linked ingredients
    this.linkedIngredients.forEach((links, stepId) => {
      const stepElement = document.querySelector(`[data-step-id="${stepId}"]`) as HTMLElement;
      if (stepElement) {
        this.updateStepDisplay(stepElement, stepId);
      }
    });
  }

  loadExistingLinks(): void {
    // Load existing ingredient links from recipe data
    if (this.recipe) {
      this.recipe.preparationGroups.forEach((group: any) => {
        group.steps.forEach((step: any) => {
          if (step.text && step.linkedIngredients && step.linkedIngredients.length > 0) {
            this.linkedIngredients.set(step.id, step.linkedIngredients);
            
            // Also update the display if the step element exists
            setTimeout(() => {
              const stepElement = document.querySelector(`[data-step-id="${step.id}"]`) as HTMLElement;
              if (stepElement) {
                this.updateStepDisplay(stepElement, step.id);
              }
            }, 100);
          }
        });
      });
    }
  }

  bindEvents(): void {
    // Auto-link button click events
    document.addEventListener('click', (e: Event) => {
      const target = e.target as HTMLElement;
      if (target?.closest('.auto-link-btn')) {
        e.preventDefault();
        const stepElement = target.closest('.step-edit-item') as HTMLElement;
        this.autoLinkIngredients(stepElement);
      }
    });

    // Manual link button click events
    document.addEventListener('click', (e: Event) => {
      const target = e.target as HTMLElement;
      if (target?.closest('.manual-link-btn')) {
        e.preventDefault();
        const stepElement = target.closest('.step-edit-item') as HTMLElement;
        this.openManualLinkModal(stepElement);
      }
    });

    // Modal event handlers
    const modal = document.getElementById('ingredient-link-modal');
    const cancelBtn = document.getElementById('cancel-link-modal');
    const saveBtn = document.getElementById('save-link-modal');

    if (cancelBtn) {
      cancelBtn.addEventListener('click', () => this.closeModal());
    }

    if (saveBtn) {
      saveBtn.addEventListener('click', () => this.saveManualLinks());
    }

    // Close modal on outside click
    if (modal) {
      modal.addEventListener('click', (e: Event) => {
        if (e.target === modal) {
          this.closeModal();
        }
      });
    }
  }

  getAllIngredients(): Array<{id: string, name: string, quantities: Array<{amount: number, unit: string}>}> {
    // Read current ingredients from DOM instead of cached recipe data
    const ingredients: Array<{id: string, name: string, quantities: Array<{amount: number, unit: string}>}> = [];
    
    // Get all ingredient elements from the DOM
    const ingredientElements = document.querySelectorAll('.ingredient-edit-item');
    
    ingredientElements.forEach((ingredientElement: Element) => {
      const nameInput = ingredientElement.querySelector('input[type="text"]') as HTMLInputElement;
      const amountInput = ingredientElement.querySelector('input[type="number"]') as HTMLInputElement;
      const unitSelect = ingredientElement.querySelector('select') as HTMLSelectElement;
      const ingredientId = (ingredientElement as HTMLElement).dataset.ingredientId;
      
      const name = nameInput?.value.trim();
      const amount = parseFloat(amountInput?.value) || 0;
      const unit = unitSelect?.value || '';
      
      // Only include ingredients with a name and id
      if (name && ingredientId) {
        ingredients.push({
          id: ingredientId,
          name: name,
          quantities: [{
            amount: amount,
            unit: unit
          }]
        });
      }
    });
    
    // If no ingredients found in DOM, fallback to recipe data
    if (ingredients.length === 0 && this.recipe) {
      return this.recipe.ingredientGroups.flatMap((group: any) => 
        group.ingredients.filter((item: any) => item.id && item.name)
      );
    }
    
    return ingredients;
  }

  // Improved text analysis for automatic ingredient linking
  autoLinkIngredients(stepElement: HTMLElement): void {
    if (!this.recipe || !stepElement) return;

    const stepId = stepElement.dataset.stepId;
    const textArea = stepElement.querySelector('.step-text-input') as HTMLTextAreaElement;
    if (!textArea || !stepId) return;

    const stepText = textArea.value.toLowerCase();
    const allIngredients = this.getAllIngredients();
    const linkedIngredients: LinkedIngredient[] = [];

    // Enhanced text matching algorithm
    allIngredients.forEach((ingredient: any) => {
      const ingredientName = ingredient.name.toLowerCase();
      
      // Skip very short ingredient names (less than 3 characters) for partial matching
      if (ingredientName.length < 3) return;
      
      // Multiple matching strategies with improved logic
      const isDirectMatch = this.findDirectMatch(stepText, ingredientName);
      const isPartialMatch = this.findPartialMatch(stepText, ingredientName);
      const isPluralized = this.findPluralized(stepText, ingredientName);
      const isStemMatch = this.findStemMatch(stepText, ingredientName);
      const isMultiWordMatch = this.findMultiWordMatch(stepText, ingredientName);
      const isGermanCaseMatch = this.findGermanCaseMatch(stepText, ingredientName);
      
      if (isDirectMatch || isPartialMatch || isPluralized || isStemMatch || isMultiWordMatch || isGermanCaseMatch) {
        // Check if already linked to avoid duplicates
        const alreadyLinked = linkedIngredients.some((link: LinkedIngredient) => 
          link.ingredientId === ingredient.id
        );
        
        if (!alreadyLinked) {
          linkedIngredients.push({
            ingredientId: ingredient.id,
            selectedQuantityIndex: 0 // Default to first quantity
          });
        }
      }
    });

    // Update the linked ingredients for this step
    this.linkedIngredients.set(stepId, linkedIngredients);
    this.updateStepDisplay(stepElement, stepId);
    this.updateRecipeData();
    
    // Show success message
    this.showNotification(`${linkedIngredients.length} Zutaten automatisch verlinkt!`, 'success');
  }

  // Helper methods for improved text matching
  findDirectMatch(text: string, ingredient: string): boolean {
    // Direct substring match with word boundaries
    const regex = new RegExp(`\\b${this.escapeRegex(ingredient)}\\b`, 'i');
    return regex.test(text);
  }

  findPartialMatch(text: string, ingredient: string): boolean {
    // More intelligent partial matching
    const words = text.split(/\s+/);
    const minLength = Math.max(3, Math.floor(ingredient.length * 0.6)); // At least 60% of ingredient name or 3 chars
    
    return words.some((word: string) => {
      // Clean word (remove punctuation)
      const cleanWord = word.replace(/[.,!?;:()]/g, '');
      
      // Only match if the word is long enough and has significant overlap
      if (cleanWord.length < 3 || ingredient.length < 3) return false;
      
      // Check if word starts with ingredient (e.g., "Tomaten" starts with "Tomate")
      if (cleanWord.startsWith(ingredient) && cleanWord.length >= minLength) return true;
      
      // Check if ingredient starts with word (e.g., "Tomat" matches "Tomate")
      if (ingredient.startsWith(cleanWord) && cleanWord.length >= minLength) return true;
      
      // Check for strong similarity (Levenshtein-like)
      return this.isSimilar(cleanWord, ingredient);
    });
  }

  findPluralized(text: string, ingredient: string): boolean {
    // German pluralization patterns with word boundaries
    const pluralForms = [
      ingredient + 'n',    // Tomate -> Tomaten
      ingredient + 'en',   // Zwiebel -> Zwiebeln  
      ingredient + 's',    // Paprika -> Paprikas
      ingredient.slice(0, -1) + 'en', // Replace last char + en
      ingredient.slice(0, -2) + 'er'  // Ei -> Eier
    ];
    
    return pluralForms.some((plural: string) => {
      const regex = new RegExp(`\\b${this.escapeRegex(plural)}\\b`, 'i');
      return regex.test(text);
    });
  }

  findStemMatch(text: string, ingredient: string): boolean {
    // Match common German word stems
    if (ingredient.length < 4) return false;
    
    const stem = ingredient.slice(0, -2); // Remove last 2 characters for stem
    if (stem.length < 3) return false;
    
    const regex = new RegExp(`\\b${this.escapeRegex(stem)}\\w{0,3}\\b`, 'i');
    return regex.test(text);
  }

  isSimilar(word1: string, word2: string): boolean {
    // Improved similarity check to avoid false positives
    if (word1.length < 4 || word2.length < 4) return false;
    
    const longer = word1.length > word2.length ? word1 : word2;
    const shorter = word1.length <= word2.length ? word1 : word2;
    
    // Don't match if length difference is too big (> 50%)
    if (Math.abs(word1.length - word2.length) / longer.length > 0.5) return false;
    
    // Calculate Levenshtein-like distance with position awareness
    let matches = 0;
    let sequentialMatches = 0;
    
    for (let i = 0; i < shorter.length; i++) {
      const char = shorter[i];
      const index = longer.indexOf(char, i > 0 ? i - 1 : 0);
      
      if (index !== -1 && Math.abs(index - i) <= 2) {
        matches++;
        if (index === i) sequentialMatches++;
      }
    }
    
    const similarity = matches / longer.length;
    const sequentialBonus = sequentialMatches / shorter.length;
    
    // Require higher similarity + some sequential matches to avoid false positives
    return similarity >= 0.75 && sequentialBonus >= 0.4;
  }

    findMultiWordMatch(text: string, ingredient: string): boolean {
    // Handle multi-word ingredient names like "Guanciale oder Pancetta"
    // Split ingredient by common separators (oder, or, und, and, /, ,)
    const separators = /\s+(oder|or|und|and|\/|,)\s+/i;
    const ingredientParts = ingredient.split(separators);
    
    // Check if any individual word from the ingredient matches the text
    return ingredientParts.some((part: string) => {
      const trimmedPart = part.trim();
      
      // Skip common connecting words
      if (['oder', 'or', 'und', 'and'].includes(trimmedPart.toLowerCase())) {
        return false;
      }
      
      // Only check meaningful words (3+ characters)
      if (trimmedPart.length < 3) return false;
      
      // Use the same matching strategies for each part
      return this.findDirectMatch(text, trimmedPart) ||
             this.findPartialMatch(text, trimmedPart) ||
             this.findPluralized(text, trimmedPart) ||
             this.findStemMatch(text, trimmedPart) ||
             this.findGermanCaseMatch(text, trimmedPart);
    });
  }

  findGermanCaseMatch(text: string, ingredient: string): boolean {
    // Handle German grammatical cases and adjective declensions
    // Common patterns for adjectives and nouns in different cases
    
    // Split ingredient into words to handle multi-word ingredients
    const ingredientWords = ingredient.split(/\s+/);
    const textWords = text.split(/\s+/);
    
    // Check if we can match word by word with case variations
    return ingredientWords.some((ingredientWord: string) => {
      if (ingredientWord.length < 3) return false;
      
      return textWords.some((textWord: string) => {
        const cleanTextWord = textWord.replace(/[.,!?;:()]/g, '').toLowerCase();
        const cleanIngredientWord = ingredientWord.toLowerCase();
        
        if (cleanTextWord.length < 3) return false;
        
        // Direct match
        if (cleanTextWord === cleanIngredientWord) return true;
        
        // German adjective declensions (schwarzer -> schwarzem, schwarzen, schwarze, etc.)
        if (this.isGermanAdjectiveDeclension(cleanTextWord, cleanIngredientWord)) return true;
        
        // German noun declensions (Pfeffer -> Pfeffers, etc.)
        if (this.isGermanNounDeclension(cleanTextWord, cleanIngredientWord)) return true;
        
        return false;
      });
    });
  }

  isGermanAdjectiveDeclension(word1: string, word2: string): boolean {
    // Common German adjective endings
    const adjEndings = ['er', 'en', 'em', 'es', 'e'];
    
    // Check if removing endings makes them match
    for (const ending1 of adjEndings) {
      if (word1.endsWith(ending1)) {
        const stem1 = word1.slice(0, -ending1.length);
        
        for (const ending2 of adjEndings) {
          if (word2.endsWith(ending2)) {
            const stem2 = word2.slice(0, -ending2.length);
            if (stem1 === stem2 && stem1.length >= 3) {
              return true;
            }
          }
        }
        
        // Also check if stem matches the full word2
        if (stem1 === word2 && stem1.length >= 3) return true;
      }
    }
    
    // Check the reverse too
    for (const ending of adjEndings) {
      if (word2.endsWith(ending)) {
        const stem = word2.slice(0, -ending.length);
        if (stem === word1 && stem.length >= 3) return true;
      }
    }
    
    return false;
  }

  isGermanNounDeclension(word1: string, word2: string): boolean {
    // Common German noun case endings
    const nounEndings = ['s', 'es', 'n', 'en'];
    
    // Check if removing endings makes them match
    for (const ending of nounEndings) {
      if (word1.endsWith(ending) && word1.length > ending.length + 2) {
        const stem = word1.slice(0, -ending.length);
        if (stem === word2 && stem.length >= 3) return true;
      }
      
      if (word2.endsWith(ending) && word2.length > ending.length + 2) {
        const stem = word2.slice(0, -ending.length);
        if (stem === word1 && stem.length >= 3) return true;
      }
    }
    
    return false;
  }

  escapeRegex(string: string): string {
    // Escape special regex characters
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }

  showNotification(message: string, type: string = 'info'): void {
    // Simple notification system
    const notification = document.createElement('div');
    notification.className = `fixed top-4 right-4 z-50 px-4 py-2 rounded-lg shadow-lg text-white ${
      type === 'success' ? 'bg-green-500' : type === 'error' ? 'bg-red-500' : 'bg-blue-500'
    }`;
    notification.textContent = message;
    
    document.body.appendChild(notification);
    
    setTimeout(() => {
      notification.remove();
    }, 3000);
  }

  openManualLinkModal(stepElement: HTMLElement): void {
    if (!this.recipe || !stepElement) return;

    this.currentStepElement = stepElement;
    this.currentStepId = stepElement.dataset.stepId || null;
    
    const modal = document.getElementById('ingredient-link-modal');
    const ingredientList = document.getElementById('ingredient-list');
    
    if (!modal || !ingredientList || !this.currentStepId) return;

    // Get current linked ingredients for this step
    const currentLinks = this.linkedIngredients.get(this.currentStepId) || [];
    const currentLinkedIds = new Set(currentLinks.map((link: LinkedIngredient) => link.ingredientId));

    // Populate ingredient list
    const allIngredients = this.getAllIngredients();
    ingredientList.innerHTML = '';

    allIngredients.forEach((ingredient: any) => {
      const isLinked = currentLinkedIds.has(ingredient.id);
      const currentLink = currentLinks.find((link: LinkedIngredient) => link.ingredientId === ingredient.id);
      
      const ingredientDiv = document.createElement('div');
      ingredientDiv.className = 'flex items-center space-x-3 p-2 border border-gray-200 dark:border-gray-600 rounded';
      
      ingredientDiv.innerHTML = `
        <input type="checkbox" 
               id="ingredient-${ingredient.id}" 
               ${isLinked ? 'checked' : ''} 
               class="ingredient-checkbox"
               data-ingredient-id="${ingredient.id}">
        <label for="ingredient-${ingredient.id}" class="flex-1 text-sm text-gray-900 dark:text-white">
          ${ingredient.name}
        </label>
        <select class="quantity-select text-xs border border-gray-300 dark:border-gray-600 rounded px-2 py-1 bg-white dark:bg-gray-700 text-gray-900 dark:text-white" 
                data-ingredient-id="${ingredient.id}" 
                ${!isLinked ? 'disabled' : ''}>
          ${ingredient.quantities.map((quantity: any, index: number) => 
            `<option value="${index}" ${currentLink && currentLink.selectedQuantityIndex === index ? 'selected' : ''}>
              ${quantity.amount} ${quantity.unit}
            </option>`
          ).join('')}
        </select>
      `;

      // Add event listener for checkbox
      const checkbox = ingredientDiv.querySelector('.ingredient-checkbox') as HTMLInputElement;
      const select = ingredientDiv.querySelector('.quantity-select') as HTMLSelectElement;
      
      if (checkbox && select) {
        checkbox.addEventListener('change', () => {
          select.disabled = !checkbox.checked;
        });
      }

      ingredientList.appendChild(ingredientDiv);
    });

    // Show modal
    modal.classList.remove('hidden');
  }

  closeModal(): void {
    const modal = document.getElementById('ingredient-link-modal');
    if (modal) {
      modal.classList.add('hidden');
    }
    this.currentStepElement = null;
    this.currentStepId = null;
  }

  saveManualLinks(): void {
    if (!this.currentStepId) return;

    const ingredientList = document.getElementById('ingredient-list');
    if (!ingredientList) return;
    
    const checkboxes = ingredientList.querySelectorAll('.ingredient-checkbox:checked') as NodeListOf<HTMLInputElement>;
    const linkedIngredients: LinkedIngredient[] = [];

    checkboxes.forEach((checkbox: HTMLInputElement) => {
      const ingredientId = checkbox.dataset.ingredientId;
      if (!ingredientId) return;
      
      const select = ingredientList.querySelector(`.quantity-select[data-ingredient-id="${ingredientId}"]`) as HTMLSelectElement;
      if (!select) return;
      
      const selectedQuantityIndex = parseInt(select.value);

      linkedIngredients.push({
        ingredientId,
        selectedQuantityIndex
      });
    });

    // Update the linked ingredients for this step
    this.linkedIngredients.set(this.currentStepId, linkedIngredients);
    if (this.currentStepElement) {
      this.updateStepDisplay(this.currentStepElement, this.currentStepId);
    }
    this.updateRecipeData();
    this.closeModal();
    
    this.showNotification(`${linkedIngredients.length} Zutaten manuell verlinkt!`, 'success');
  }

  updateStepDisplay(stepElement: HTMLElement, stepId: string): void {
    const displayContainer = stepElement.querySelector('.linked-ingredients-display');
    if (!displayContainer) return;

    const linkedIngredients = this.linkedIngredients.get(stepId) || [];
    const allIngredients = this.getAllIngredients();

    if (linkedIngredients.length === 0) {
      displayContainer.innerHTML = '';
      return;
    }

    const tagsHtml = linkedIngredients.map((link: LinkedIngredient) => {
      const ingredient = allIngredients.find((ing: any) => ing.id === link.ingredientId);
      if (!ingredient) return '';
      
      const quantity = ingredient.quantities[link.selectedQuantityIndex];
      return `
        <span class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200">
          ${ingredient.name} (${quantity.amount} ${quantity.unit})
          <button type="button" class="ml-1 text-blue-600 hover:text-blue-800" onclick="window.ingredientLinker.removeIngredientLink('${stepId}', '${link.ingredientId}')">
            ×
          </button>
        </span>
      `;
    }).join('');

    displayContainer.innerHTML = `
      <div class="flex flex-wrap gap-2 mb-2">
        ${tagsHtml}
      </div>
    `;
  }

  removeIngredientLink(stepId: string, ingredientId: string): void {
    const currentLinks = this.linkedIngredients.get(stepId) || [];
    const updatedLinks = currentLinks.filter((link: LinkedIngredient) => link.ingredientId !== ingredientId);
    
    this.linkedIngredients.set(stepId, updatedLinks);
    
    const stepElement = document.querySelector(`[data-step-id="${stepId}"]`) as HTMLElement;
    if (stepElement) {
      this.updateStepDisplay(stepElement, stepId);
      this.updateRecipeData();
    }
  }

  updateRecipeData(): void {
    if (!this.recipe) return;

    // Update the recipe object with current linked ingredients
    this.recipe.preparationGroups.forEach((group: any) => {
      group.steps.forEach((step: any) => {
        if (step.text && step.id) {
          const linkedIngredients = this.linkedIngredients.get(step.id);
          if (linkedIngredients) {
            step.linkedIngredients = linkedIngredients;
          }
        }
      });
    });

    // Update the global recipe object
    window.currentRecipe = this.recipe;
  }

  // Export function to save recipe with linked ingredients
  getUpdatedRecipe(): Recipe | null {
    this.updateRecipeData();
    return this.recipe;
  }
}

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
  window.ingredientLinker = new IngredientLinker();
});

// Export for use in other scripts
window.IngredientLinker = IngredientLinker;
</script> 