---
import type { Recipe } from '../../../types/recipe';
import HeaderEdit from './HeaderEdit.astro';
import RecipeTagsEdit from './RecipeTagsEdit.astro';
import IngredientsEdit from './IngredientsEdit.astro'; 
import PreparationEdit from './PreparationEdit.astro';
import IngredientLinkingScript from './IngredientLinkingScript.astro';
import IngredientSuggestionScript from './IngredientSuggestionScript.astro';
import RecipeImageGallery from '../RecipeImageGallery.astro';

interface Props {
  recipe: Recipe;
}

const { recipe } = Astro.props;
---

<form id="edit-recipe-form" class="space-y-6">
  <HeaderEdit recipe={recipe} />
  <RecipeTagsEdit recipe={recipe} />
  <RecipeImageGallery recipe={recipe} mode="edit" />
  <IngredientsEdit recipe={recipe} />
  <PreparationEdit recipe={recipe} />
</form>

<div>
  <!-- Include the ingredient linking functionality -->
  <IngredientLinkingScript />
  
  <!-- Include the ingredient suggestion functionality -->
  <IngredientSuggestionScript />
</div>

<script define:vars={{ recipe }}>
  // Make recipe data available globally for ingredient linking
  window.currentRecipe = recipe;
  
  // Available units loaded from API
  let availableUnits = [];
  
  // Draft auto-save debounce timer
  let draftSaveTimeout = null;
  const DRAFT_SAVE_DELAY = 1000; // Save draft 1 second after last change
  
  // Flag to prevent draft saving right after a successful recipe save
  let justSavedRecipe = false;
  
  // Track initial recipe state for change detection
  let initialRecipeState = null;
  let hasChanges = false;
  
  // Store the last known draft timestamp for local time updates
  let lastKnownDraftTimestamp = null;
  
  // Store the time update interval ID so we can clear it when needed
  let timeUpdateIntervalId = null;
  
  // Placeholder functions that will be defined later - expose them early so they're available
  // This ensures the cancel handler can find them even if called before DOMContentLoaded
  window.saveDraftToStorage = null;
  window.collectRecipeData = null;
  
  // Draft storage functions (using API)
  async function saveDraft(recipeId, recipe) {
    try {
      const response = await fetch(`/api/drafts?recipeId=${recipeId}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(recipe)
      });
      
      if (!response.ok) {
        throw new Error('Failed to save draft');
      }
      
      hasChanges = true;
    } catch (error) {
      console.error('Error saving draft:', error);
    }
  }
  
  async function loadDraft(recipeId) {
    try {
      const response = await fetch(`/api/drafts?recipeId=${recipeId}`);
      if (!response.ok) {
        console.error('Error loading draft:', response.status, response.statusText);
        return null;
      }
      const draft = await response.json();
      // API returns null when no draft exists (instead of 404)
      return draft;
    } catch (error) {
      console.error('Error loading draft:', error);
      return null;
    }
  }
  
  async function deleteDraft(recipeId) {
    try {
      console.log(`Attempting to delete draft for recipe: ${recipeId}`);
      const response = await fetch(`/api/drafts?recipeId=${recipeId}`, {
        method: 'DELETE'
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        console.error(`Failed to delete draft: ${response.status} - ${errorText}`);
        return false;
      }
      
      const result = await response.json();
      console.log('Draft deletion response:', result);
      return true;
    } catch (error) {
      console.error('Error deleting draft:', error);
      return false;
    }
  }
  
  async function hasDraft(recipeId) {
    try {
      const response = await fetch(`/api/drafts?recipeId=${recipeId}`);
      if (!response.ok) {
        return false;
      }
      const draft = await response.json();
      // API returns null when no draft exists (instead of 404)
      return draft !== null;
    } catch (error) {
      console.error('Error checking draft:', error);
      return false;
    }
  }
  
  // Compare two recipe objects to detect changes
  function recipesAreEqual(recipe1, recipe2) {
    if (!recipe1 || !recipe2) return false;
    
    // Compare simple fields
    if (recipe1.title !== recipe2.title) return false;
    if (recipe1.subtitle !== recipe2.subtitle) return false;
    if (recipe1.description !== recipe2.description) return false;
    if (recipe1.sourceUrl !== recipe2.sourceUrl) return false;
    if (recipe1.category !== recipe2.category) return false;
    
    // Compare metadata
    if (JSON.stringify(recipe1.metadata) !== JSON.stringify(recipe2.metadata)) return false;
    
    // Compare tags
    if (JSON.stringify(recipe1.tags || []) !== JSON.stringify(recipe2.tags || [])) return false;
    
    // Compare ingredient groups
    if (JSON.stringify(recipe1.ingredientGroups) !== JSON.stringify(recipe2.ingredientGroups)) return false;
    
    // Compare preparation groups
    if (JSON.stringify(recipe1.preparationGroups) !== JSON.stringify(recipe2.preparationGroups)) return false;
    
    // Note: Images are not compared - they are directly applied to recipes and not part of drafts
    
    return true;
  }
  
  // Load available units
  async function loadUnits() {
    try {
      const response = await fetch('/api/units');
      if (response.ok) {
        const data = await response.json();
        // API returns { units: [...], conversions: {...} } or just array (backward compatibility)
        availableUnits = Array.isArray(data) ? data : (data.units || []);
        populateUnitDropdowns();
      }
    } catch (error) {
      console.error('Error loading units:', error);
    }
  }
  
  // Populate all unit dropdowns with available units
  function populateUnitDropdowns() {
    const unitSelects = document.querySelectorAll('.ingredient-unit-select');
    unitSelects.forEach(select => {
      // Get the current value from the selected option, not from select.value
      // This is more reliable when the select was just created from HTML
      const currentValue = select.querySelector('option[selected]')?.value || select.value || '';
      populateUnitDropdown(select, currentValue);
    });
  }
  
  // Populate a single unit dropdown
  function populateUnitDropdown(selectElement, selectedValue = '') {
    // Store the original selected value before clearing
    const originalValue = selectedValue || selectElement.value || '';
    
    // Clear existing options except the first one (if it's a placeholder)
    const firstOption = selectElement.querySelector('option');
    const isPlaceholder = firstOption && (firstOption.value === '' || firstOption.textContent === 'Einheit');
    
    if (isPlaceholder) {
      selectElement.innerHTML = '';
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'Einheit';
      selectElement.appendChild(placeholder);
    } else {
      selectElement.innerHTML = '';
    }
    
    // Use the original value for selection
    const valueToSelect = originalValue;
    let foundInAvailableUnits = false;
    
    // Add all available units
    if (availableUnits.length > 0) {
      availableUnits.forEach(unit => {
        const option = document.createElement('option');
        option.value = unit.name;
        option.textContent = unit.name;
        if (unit.name === valueToSelect) {
          option.selected = true;
          foundInAvailableUnits = true;
        }
        selectElement.appendChild(option);
      });
    }
    
    // If the original value wasn't found in base units, add it as a custom option
    // This preserves units that might not be in the base units list
    if (valueToSelect && !foundInAvailableUnits) {
      const customOption = document.createElement('option');
      customOption.value = valueToSelect;
      customOption.textContent = valueToSelect;
      customOption.selected = true;
      selectElement.appendChild(customOption);
    }
  }
  
  // Add form submission handler
  document.addEventListener('DOMContentLoaded', async () => {
    const form = document.getElementById('edit-recipe-form');
    if (form) {
      form.addEventListener('submit', handleFormSubmit);
    }
    
    // Store initial recipe state for change detection
    initialRecipeState = JSON.parse(JSON.stringify(recipe));
    
    // Load units first
    await loadUnits();
    
    // Initialize edit functionality first
    initializeEditHandlers();
    
    // Only initialize draft functionality if we're in edit mode
    const editContent = document.getElementById('edit-content');
    if (editContent && !editContent.classList.contains('hidden')) {
      // Load draft if it exists
      await loadDraftIfExists();
      
      // Set up auto-save draft on form changes
      setupDraftAutoSave();
      
      // Don't create initial draft - only create when user makes changes
      // await createInitialDraftIfNeeded();
      
      // Update draft last updated time display
      await updateDraftTimeDisplay();
      
      // Start the time update interval when entering edit mode
      startTimeUpdateInterval();
      
      // Check for external draft updates and refresh timestamp every minute
      // Only update timestamp if it's actually newer (to avoid overwriting with stale data)
      setInterval(async () => {
        // Only update if still in edit mode
        const currentEditContent = document.getElementById('edit-content');
        if (currentEditContent && !currentEditContent.classList.contains('hidden')) {
          const recipeId = window.location.pathname.split('/').pop();
          if (recipeId) {
            const draft = await loadDraft(recipeId);
            if (draft && draft.updatedAt) {
              const serverTimestamp = new Date(draft.updatedAt);
              // Only update if server timestamp is newer than our current timestamp
              // This prevents overwriting with stale data when we just saved
              if (!lastKnownDraftTimestamp || serverTimestamp.getTime() > lastKnownDraftTimestamp.getTime()) {
                lastKnownDraftTimestamp = serverTimestamp;
                await updateDraftTimeDisplay();
              }
            }
          }
          await checkForExternalDraftUpdates();
        }
      }, 60000); // Check for external updates every minute
      
      // Also check for external updates when window gains focus
      window.addEventListener('focus', async () => {
        const currentEditContent = document.getElementById('edit-content');
        if (currentEditContent && !currentEditContent.classList.contains('hidden')) {
          await checkForExternalDraftUpdates();
        }
      });
    }
    
    // Set up unload handlers once (they check edit mode internally)
    // Save draft immediately on page unload (reload, close, etc.)
    window.addEventListener('beforeunload', () => {
      // Only save if we're in edit mode
      const editContent = document.getElementById('edit-content');
      if (editContent && !editContent.classList.contains('hidden')) {
        // Clear debounce timeout and save immediately
        if (draftSaveTimeout) {
          clearTimeout(draftSaveTimeout);
          draftSaveTimeout = null;
        }
        saveDraftImmediately();
      }
    });
    
    // Save draft when page becomes hidden (mobile: app switching, tab switching, etc.)
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        // Only save if we're in edit mode
        const editContent = document.getElementById('edit-content');
        if (editContent && !editContent.classList.contains('hidden')) {
          // Clear debounce timeout and save immediately
          if (draftSaveTimeout) {
            clearTimeout(draftSaveTimeout);
            draftSaveTimeout = null;
          }
          saveDraftImmediately();
        }
      }
    });
  });
  
  // Listen for edit mode changes to initialize draft functionality
  document.addEventListener('editModeChanged', async (event) => {
    const isEditMode = event.detail.isEditMode;
    
    if (isEditMode) {
      // Entering edit mode - initialize draft functionality
      await loadDraftIfExists();
      setupDraftAutoSave();
      // Don't create initial draft - only create when user makes changes
      // await createInitialDraftIfNeeded();
      await updateDraftTimeDisplay();
      // Start the time update interval
      startTimeUpdateInterval();
    } else {
      // Exiting edit mode - stop the time update interval
      stopTimeUpdateInterval();
    }
  });
  
  // Load draft if it exists
  async function loadDraftIfExists() {
    try {
      const recipeId = window.location.pathname.split('/').pop();
      if (!recipeId) return;
      
      const draft = await loadDraft(recipeId);
      if (draft) {
        // Show the status bar since a draft exists
        const statusBar = document.getElementById('draft-status-bar');
        if (statusBar) {
          statusBar.classList.remove('hidden');
        }
        
        // Restore draft data to the form
        restoreDraftToForm(draft);
        window.currentRecipe = draft;
        
        // Update ingredient linker if available
        if (window.ingredientLinker) {
          window.ingredientLinker.recipe = draft;
        }
        
        // Show notification that draft was loaded
        showNotification('Entwurf wurde geladen.', 'info');
      }
    } catch (error) {
      console.error('Error loading draft:', error);
    }
  }
  
  // Create initial draft when entering edit mode if it doesn't exist
  // Only creates a draft if there are actual changes from the original recipe
  async function createInitialDraftIfNeeded() {
    try {
      const recipeId = window.location.pathname.split('/').pop();
      if (!recipeId) return;
      
      // Only create if we're in edit mode
      const editContent = document.getElementById('edit-content');
      if (!editContent || editContent.classList.contains('hidden')) {
        return; // Not in edit mode, don't create draft
      }
      
      // Check if draft already exists
      const draftExists = await hasDraft(recipeId);
      if (draftExists) {
        return; // Draft already exists
      }
      
      // Get current form state
      const currentState = collectRecipeData();
      
      // Compare with original recipe state - only create draft if there are changes
      if (initialRecipeState && recipesAreEqual(currentState, initialRecipeState)) {
        // No changes detected, don't create a draft
        console.log('No changes detected, skipping initial draft creation');
        return;
      }
      
      // There are changes, create initial draft
      await saveDraft(recipeId, currentState);
      hasChanges = false; // Initial save doesn't count as a change (we'll track future changes)
    } catch (error) {
      console.error('Error creating initial draft:', error);
    }
  }
  
  // Check for external draft updates (from other sessions/devices)
  async function checkForExternalDraftUpdates() {
    try {
      const recipeId = window.location.pathname.split('/').pop();
      if (!recipeId) return;
      
      const draft = await loadDraft(recipeId);
      if (!draft) return;
      
      // Compare current form state with draft
      const currentState = collectRecipeData();
      const currentStateStr = JSON.stringify(currentState);
      const draftStr = JSON.stringify(draft);
      
      // If draft is different from current state, ask user if they want to load it
      if (currentStateStr !== draftStr) {
        // Check if current state matches initial state (no local changes)
        const currentMatchesInitial = recipesAreEqual(currentState, initialRecipeState);
        
        if (currentMatchesInitial) {
          // No local changes, automatically load the draft
          restoreDraftToForm(draft);
          window.currentRecipe = draft;
          if (window.ingredientLinker) {
            window.ingredientLinker.recipe = draft;
          }
          showNotification('Entwurf wurde von einem anderen Gerät aktualisiert.', 'info');
        } else {
          // Local changes exist, notify user but don't auto-load
          showNotification('Entwurf wurde von einem anderen Gerät aktualisiert. Seite neu laden, um die Änderungen zu sehen.', 'info');
        }
      }
    } catch (error) {
      console.error('Error checking for external draft updates:', error);
    }
  }
  
  // Restore draft data to form fields
  function restoreDraftToForm(draft) {
    // Restore basic fields
    const titleInput = document.getElementById('edit-title');
    if (titleInput && draft.title) {
      titleInput.value = draft.title;
    }
    
    const subtitleInput = document.getElementById('edit-subtitle');
    if (subtitleInput) {
      subtitleInput.value = draft.subtitle || '';
    }
    
    const descriptionInput = document.getElementById('edit-description');
    if (descriptionInput) {
      descriptionInput.value = draft.description || '';
    }
    
    const sourceUrlInput = document.getElementById('edit-source-url');
    if (sourceUrlInput) {
      sourceUrlInput.value = draft.sourceUrl || '';
    }
    
    // Restore servings
    const servingsInput = document.getElementById('edit-servings');
    if (servingsInput && draft.metadata?.servings) {
      servingsInput.value = draft.metadata.servings.toString();
    }
    
    // Restore difficulty
    const difficultyInput = document.getElementById('edit-difficulty');
    if (difficultyInput && draft.metadata?.difficulty) {
      difficultyInput.value = draft.metadata.difficulty;
    }
    
    // Restore nutrition
    if (draft.metadata?.nutrition) {
      const caloriesInput = document.getElementById('edit-calories');
      if (caloriesInput) {
        caloriesInput.value = draft.metadata.nutrition.calories?.toString() || '';
      }
      
      const carbsInput = document.getElementById('edit-carbohydrates');
      if (carbsInput) {
        carbsInput.value = draft.metadata.nutrition.carbohydrates?.toString() || '';
      }
      
      const proteinInput = document.getElementById('edit-protein');
      if (proteinInput) {
        proteinInput.value = draft.metadata.nutrition.protein?.toString() || '';
      }
      
      const fatInput = document.getElementById('edit-fat');
      if (fatInput) {
        fatInput.value = draft.metadata.nutrition.fat?.toString() || '';
      }
    }
    
    // Note: Ingredient and preparation groups are more complex to restore
    // They will be restored when the form is re-rendered with draft data
    // For now, we rely on the server-side data being updated or manual restoration
  }
  
  // Set up auto-save draft on form changes
  function setupDraftAutoSave() {
    const form = document.getElementById('edit-recipe-form');
    if (!form) {
      console.warn('Edit form not found, cannot set up auto-save');
      return;
    }
    
    // Listen to all input, change, and other relevant events on the form
    form.addEventListener('input', handleDraftChange);
    form.addEventListener('change', handleDraftChange);
    
    // Also listen to dynamically added elements (delegated events)
    // This is important for elements added after page load
    document.addEventListener('input', (e) => {
      if (e.target && e.target.closest('#edit-recipe-form')) {
        handleDraftChange(e);
      }
    });
    
    document.addEventListener('change', (e) => {
      if (e.target && e.target.closest('#edit-recipe-form')) {
        handleDraftChange(e);
      }
    });
  }
  
  // Handle draft change with debouncing
  function handleDraftChange(e) {
    // Only save if we're in edit mode
    const editContent = document.getElementById('edit-content');
    if (!editContent || editContent.classList.contains('hidden')) {
      return; // Not in edit mode, don't save
    }
    
    // Clear existing timeout
    if (draftSaveTimeout) {
      clearTimeout(draftSaveTimeout);
    }
    
    // Set new timeout to save draft
    draftSaveTimeout = setTimeout(() => {
      saveDraftToStorage();
    }, DRAFT_SAVE_DELAY);
  }
  
  // Save current form state as draft
  async function saveDraftToStorage() {
    try {
      // Clear any pending debounce timeout since we're saving now
      if (draftSaveTimeout) {
        clearTimeout(draftSaveTimeout);
        draftSaveTimeout = null;
      }
      
      const recipeId = window.location.pathname.split('/').pop();
      if (!recipeId) {
        console.warn('No recipe ID found, cannot save draft');
        return false;
      }
      
      // Only save if we're in edit mode
      const editContent = document.getElementById('edit-content');
      if (!editContent || editContent.classList.contains('hidden')) {
        return false; // Not in edit mode, don't save
      }
      
      // Collect current recipe data directly from the form
      // We don't need to trigger events - collectRecipeData reads directly from the DOM
      let currentRecipeData;
      try {
        currentRecipeData = collectRecipeData();
        if (!currentRecipeData) {
          throw new Error('collectRecipeData returned null or undefined');
        }
      } catch (error) {
        console.error('Error collecting recipe data:', error);
        throw error;
      }
      
      // Check if there are actual changes before saving
      if (initialRecipeState && recipesAreEqual(currentRecipeData, initialRecipeState)) {
        console.log('No changes detected, skipping draft save');
        return false; // No changes, don't save draft
      }
      
      console.log('Saving draft with data:', {
        title: currentRecipeData.title,
        recipeId: recipeId
      });
      
      // Save draft and wait for it to complete
      const response = await fetch(`/api/drafts?recipeId=${recipeId}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(currentRecipeData)
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        console.error('Failed to save draft:', response.status, errorText);
        throw new Error('Failed to save draft');
      }
      
      console.log('Draft saved successfully');
      hasChanges = true;
      
      // Show the status bar now that a draft exists
      const statusBar = document.getElementById('draft-status-bar');
      if (statusBar) {
        statusBar.classList.remove('hidden');
      }
      
      // Update the timestamp immediately to current time for instant display update
      // This ensures the time display shows "gerade eben" or "vor 1 Sekunde" immediately
      const saveTime = new Date();
      lastKnownDraftTimestamp = saveTime;
      
      // Update last updated time display immediately
      const timeDisplay = document.getElementById('draft-last-updated');
      if (timeDisplay) {
        timeDisplay.textContent = 'Entwurf zuletzt aktualisiert: gerade eben';
      }
      
      // Don't overwrite the timestamp with server response - we just saved, so our immediate timestamp is correct
      // The interval will continue to update the display based on this timestamp
      
      return true;
    } catch (error) {
      console.error('Error saving draft:', error);
      return false;
    }
  }
  
  // Expose save function and collectRecipeData globally so they can be called from cancel handler
  // Do this immediately when the script loads, not just in DOMContentLoaded
  // Wrap in try-catch to handle any errors during exposure
  try {
    window.saveDraftToStorage = saveDraftToStorage;
    window.collectRecipeData = collectRecipeData;
    console.log('saveDraftToStorage function exposed globally');
  } catch (error) {
    console.error('Error exposing saveDraftToStorage:', error);
  }
  
  // Save draft immediately (synchronous, for page unload)
  function saveDraftImmediately() {
    try {
      // Don't save draft if we just saved the recipe (prevents creating new draft on reload)
      if (justSavedRecipe) {
        console.log('Skipping draft save - recipe was just saved');
        return false;
      }
      
      const recipeId = window.location.pathname.split('/').pop();
      if (!recipeId) return false;
      
      // Only save if we're in edit mode
      const editContent = document.getElementById('edit-content');
      if (!editContent || editContent.classList.contains('hidden')) {
        return false; // Not in edit mode, don't save
      }
      
      // Collect current recipe data
      const currentRecipeData = collectRecipeData();
      
      // Check if there are actual changes before saving
      if (initialRecipeState && recipesAreEqual(currentRecipeData, initialRecipeState)) {
        console.log('No changes detected in saveDraftImmediately, skipping save');
        return false; // No changes, don't save
      }
      
      // Update timestamp immediately for display
      lastKnownDraftTimestamp = new Date();
      
      // Use fetch with keepalive for reliable unload handling
      // This works better than sendBeacon for JSON data
      fetch(`/api/drafts?recipeId=${recipeId}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(currentRecipeData),
        keepalive: true
      }).catch(() => {
        // Silently fail - this is best effort
      });
      
      return true;
    } catch (error) {
      // Silently fail - this is best effort
      return false;
    }
  }
  
  // Start the time update interval
  function startTimeUpdateInterval() {
    // Clear any existing interval first
    if (timeUpdateIntervalId !== null) {
      clearInterval(timeUpdateIntervalId);
      timeUpdateIntervalId = null;
    }
    
    // Create new interval to update time display every second
    timeUpdateIntervalId = setInterval(() => {
      // Only update if still in edit mode
      const currentEditContent = document.getElementById('edit-content');
      if (currentEditContent && !currentEditContent.classList.contains('hidden')) {
        const timeDisplay = document.getElementById('draft-last-updated');
        if (timeDisplay && lastKnownDraftTimestamp) {
          // Update time display locally without API call
          const now = new Date();
          const diffMs = now.getTime() - lastKnownDraftTimestamp.getTime();
          const diffSecs = Math.floor(diffMs / 1000);
          const diffMins = Math.floor(diffMs / 60000);
          
          let timeText = '';
          if (diffSecs < 1) {
            timeText = 'gerade eben';
          } else if (diffSecs === 1) {
            timeText = 'vor 1 Sekunde';
          } else if (diffSecs < 60) {
            timeText = `vor ${diffSecs} Sekunden`;
          } else if (diffMins === 1) {
            timeText = 'vor 1 Minute';
          } else if (diffMins < 60) {
            timeText = `vor ${diffMins} Minuten`;
          } else {
            const diffHours = Math.floor(diffMins / 60);
            if (diffHours === 1) {
              timeText = 'vor 1 Stunde';
            } else if (diffHours < 24) {
              timeText = `vor ${diffHours} Stunden`;
            } else {
              const diffDays = Math.floor(diffHours / 24);
              if (diffDays === 1) {
                timeText = 'vor 1 Tag';
              } else {
                timeText = `vor ${diffDays} Tagen`;
              }
            }
          }
          
          timeDisplay.textContent = `Entwurf zuletzt aktualisiert: ${timeText}`;
        } else if (timeDisplay && !lastKnownDraftTimestamp) {
          // If we don't have a timestamp yet, show loading message
          timeDisplay.textContent = 'Entwurf wird automatisch gespeichert...';
        }
      } else {
        // Not in edit mode anymore, clear the interval
        if (timeUpdateIntervalId !== null) {
          clearInterval(timeUpdateIntervalId);
          timeUpdateIntervalId = null;
        }
      }
    }, 1000); // Update every second for precise time display
  }
  
  // Stop the time update interval
  function stopTimeUpdateInterval() {
    if (timeUpdateIntervalId !== null) {
      clearInterval(timeUpdateIntervalId);
      timeUpdateIntervalId = null;
    }
  }
  
  // Update draft last updated time display
  async function updateDraftTimeDisplay() {
    try {
      const recipeId = window.location.pathname.split('/').pop();
      if (!recipeId) return;
      
      const timeDisplay = document.getElementById('draft-last-updated');
      if (!timeDisplay) return;
      
      // Check if draft exists first
      const draftExists = await hasDraft(recipeId);
      const statusBar = document.getElementById('draft-status-bar');
      
      if (!draftExists) {
        // Hide the status bar if no draft exists
        if (statusBar) {
          statusBar.classList.add('hidden');
        }
        timeDisplay.textContent = 'Entwurf wird automatisch gespeichert...';
        lastKnownDraftTimestamp = null;
        return;
      }
      
      // Show the status bar if draft exists
      if (statusBar) {
        statusBar.classList.remove('hidden');
      }
      
      const draft = await loadDraft(recipeId);
      if (draft && draft.updatedAt) {
        // updatedAt now contains the draft's last_updated timestamp from recipe_drafts table
        const lastUpdated = new Date(draft.updatedAt);
        // Only update timestamp if it's newer than what we have (or if we don't have one)
        // This prevents overwriting a more recent timestamp we set when saving
        if (!lastKnownDraftTimestamp || lastUpdated.getTime() > lastKnownDraftTimestamp.getTime()) {
          lastKnownDraftTimestamp = lastUpdated; // Store for local updates
        }
        const now = new Date();
        const diffMs = now.getTime() - lastUpdated.getTime();
        const diffSecs = Math.floor(diffMs / 1000);
        const diffMins = Math.floor(diffMs / 60000);
        
        let timeText = '';
        if (diffSecs < 1) {
          timeText = 'gerade eben';
        } else if (diffSecs === 1) {
          timeText = 'vor 1 Sekunde';
        } else if (diffSecs < 60) {
          timeText = `vor ${diffSecs} Sekunden`;
        } else if (diffMins === 1) {
          timeText = 'vor 1 Minute';
        } else if (diffMins < 60) {
          timeText = `vor ${diffMins} Minuten`;
        } else {
          const diffHours = Math.floor(diffMins / 60);
          if (diffHours === 1) {
            timeText = 'vor 1 Stunde';
          } else if (diffHours < 24) {
            timeText = `vor ${diffHours} Stunden`;
          } else {
            const diffDays = Math.floor(diffHours / 24);
            if (diffDays === 1) {
              timeText = 'vor 1 Tag';
            } else {
              timeText = `vor ${diffDays} Tagen`;
            }
          }
        }
        
        timeDisplay.textContent = `Entwurf zuletzt aktualisiert: ${timeText}`;
      } else {
        timeDisplay.textContent = 'Entwurf wird automatisch gespeichert...';
        lastKnownDraftTimestamp = null;
      }
    } catch (error) {
      console.error('Error updating draft time display:', error);
      const timeDisplay = document.getElementById('draft-last-updated');
      if (timeDisplay) {
        timeDisplay.textContent = 'Entwurf wird automatisch gespeichert...';
      }
      lastKnownDraftTimestamp = null;
    }
  }

  function initializeEditHandlers() {
    // Ingredient functionality
    const addIngredientBtn = document.getElementById('add-ingredient-btn');
    const addIngredientGroupBtn = document.getElementById('add-ingredient-group-btn');
    
    // Preparation functionality
    const addStepBtn = document.getElementById('add-step-btn');
    const addPreparationGroupBtn = document.getElementById('add-preparation-group-btn');
    
    if (addIngredientBtn) {
      addIngredientBtn.addEventListener('click', (e) => {
        e.preventDefault();
        addIngredientToDefaultGroup();
      });
    }
    
    if (addIngredientGroupBtn) {
      addIngredientGroupBtn.addEventListener('click', (e) => {
        e.preventDefault();
        addIngredientGroup();
      });
    }
    
    if (addStepBtn) {
      addStepBtn.addEventListener('click', (e) => {
        e.preventDefault();
        addStepToDefaultGroup();
      });
    }
    
    if (addPreparationGroupBtn) {
      addPreparationGroupBtn.addEventListener('click', (e) => {
        e.preventDefault();
        addPreparationGroup();
      });
    }
    
    // Delegate events for dynamically created buttons
    document.addEventListener('click', handleDelegatedClicks);
    
    // Add event listeners for ingredient changes to keep linker updated
    document.addEventListener('input', (e) => {
      const target = e.target;
      if (target.closest('.ingredient-edit-item')) {
        // Debounce the update to avoid too many calls
        clearTimeout(window.ingredientUpdateTimeout);
        window.ingredientUpdateTimeout = setTimeout(() => {
          updateIngredientLinker();
          handleDraftChange(); // Also trigger draft save
        }, 300);
      }
    });
  }

  function handleDelegatedClicks(e) {
    const target = e.target.closest('button');
    if (!target) return;

    if (target.classList.contains('add-ingredient-to-group-btn')) {
      e.preventDefault();
      const groupElement = target.closest('.ingredient-group-edit, .nested-ingredient-group-edit');
      addIngredientToGroup(groupElement);
    }
    
    if (target.classList.contains('add-nested-group-btn')) {
      e.preventDefault();
      const groupElement = target.closest('.ingredient-group-edit, .nested-ingredient-group-edit');
      addNestedGroup(groupElement);
    }
    
    if (target.classList.contains('remove-ingredient-btn')) {
      e.preventDefault();
      removeIngredient(target);
    }
    
    if (target.classList.contains('remove-group-btn')) {
      e.preventDefault();
      const groupElement = target.closest('.ingredient-group-edit, .nested-ingredient-group-edit');
      removeIngredientGroup(groupElement);
    }
    
    if (target.classList.contains('add-step-to-group-btn')) {
      e.preventDefault();
      const groupElement = target.closest('.preparation-group-edit, .nested-preparation-group-edit');
      addStepToGroup(groupElement);
    }
    
    if (target.classList.contains('add-nested-prep-group-btn')) {
      e.preventDefault();
      const groupElement = target.closest('.preparation-group-edit, .nested-preparation-group-edit');
      addNestedPrepGroup(groupElement);
    }
    
    if (target.classList.contains('remove-step-btn')) {
      e.preventDefault();
      removePreparationStep(target);
    }
    
    if (target.classList.contains('remove-prep-group-btn')) {
      e.preventDefault();
      const groupElement = target.closest('.preparation-group-edit, .nested-preparation-group-edit');
      removePreparationGroup(groupElement);
    }
  }

  // Ingredient functions
  function addIngredientToDefaultGroup() {
    const defaultGroup = document.querySelector('.ingredient-group-edit.default-group');
    if (defaultGroup) {
      addIngredientToGroup(defaultGroup);
    }
  }

  function addIngredientToGroup(groupElement) {
    const ingredientsList = groupElement.querySelector('.ingredients-list');
    if (!ingredientsList) return;

    const ingredientId = generateId();
    const ingredientHtml = createIngredientEditElement(ingredientId, '', '', '', '');
    
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = ingredientHtml;
    const ingredientElement = tempDiv.firstElementChild;
    
    ingredientsList.appendChild(ingredientElement);
    
    // Populate unit dropdown for the new ingredient
    const unitSelect = ingredientElement.querySelector('.ingredient-unit-select');
    if (unitSelect) {
      populateUnitDropdown(unitSelect, '');
    }
    
    // Focus on the name input
    const nameInput = ingredientElement.querySelector('.ingredient-name-input');
    if (nameInput) {
      nameInput.focus();
      
      // Attach suggestion handlers to the new input
      if (window.attachIngredientSuggestionHandlers) {
        window.attachIngredientSuggestionHandlers(nameInput);
      }
    }
    
    // Update ingredient linker with current DOM state
    updateIngredientLinker();
    
    // Trigger draft save
    handleDraftChange();
  }

  function createIngredientEditElement(id, name, amount, unit, description = '') {
    return `
      <div class="ingredient-edit-item border border-gray-200 dark:border-gray-600 rounded-md p-3 bg-white dark:bg-gray-800 transition-colors duration-200" data-ingredient-id="${id}">
        <div class="space-y-3">
          <div class="flex flex-col sm:flex-row sm:space-x-3 space-y-2 sm:space-y-0 sm:items-center">
            <div class="flex-1 relative">
              <input 
                type="text" 
                value="${name}"
                placeholder="Zutatename"
                class="ingredient-name-input w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent bg-white dark:bg-gray-700 text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400"
              />
              <div class="ingredient-suggestions absolute top-full left-0 right-0 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-600 rounded-md shadow-lg mt-1 hidden z-20 max-h-32 overflow-y-auto">
              </div>
            </div>
            <div class="flex space-x-2 sm:space-x-3">
              <input 
                type="number" 
                value="${amount}"
                placeholder="Menge"
                step="0.1"
                class="w-20 sm:w-24 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent bg-white dark:bg-gray-700 text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400"
              />
              <select class="ingredient-unit-select w-20 sm:w-24 px-2 sm:px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent bg-white dark:bg-gray-700 text-gray-900 dark:text-white text-xs sm:text-sm">
                <option value="${unit}" selected>${unit || 'Einheit'}</option>
              </select>
              <button 
                type="button" 
                class="remove-ingredient-btn px-2 py-2 text-red-600 dark:text-red-400 hover:text-red-700 dark:hover:text-red-300 rounded transition-colors"
              >
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                </svg>
              </button>
            </div>
          </div>
          <div>
            <input 
              type="text" 
              value="${description}"
              placeholder="Beschreibung (optional)"
              class="ingredient-description-input w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent bg-white dark:bg-gray-700 text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400 text-sm"
            />
          </div>
        </div>
      </div>
    `;
  }

  function addIngredientGroup() {
    const container = document.getElementById('ingredients-edit-container');
    if (!container) return;

    const groupId = generateId();
    const groupHtml = createIngredientGroupElement(groupId, '');
    
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = groupHtml;
    const groupElement = tempDiv.firstElementChild;
    
    container.appendChild(groupElement);
    
    // Focus on the group title input
    const titleInput = groupElement.querySelector('.group-title-input');
    if (titleInput) {
      titleInput.focus();
    }
  }

  function createIngredientGroupElement(id, title, isNested = false) {
    const containerClass = isNested 
      ? 'nested-ingredient-group-edit border border-gray-200 dark:border-gray-600 rounded-md p-3 bg-gray-100 dark:bg-gray-700/30 transition-colors duration-200 ml-4'
      : 'ingredient-group-edit border border-gray-300 dark:border-gray-600 rounded-lg p-3 sm:p-4 bg-gray-50 dark:bg-gray-700/50 transition-colors duration-200';
    
    return `
      <div class="${containerClass}" data-group-id="${id}">
        <div class="flex flex-col sm:flex-row sm:justify-between sm:items-center mb-3 space-y-2 sm:space-y-0">
          <input 
            type="text" 
            value="${title}"
            placeholder="${isNested ? 'Untergruppenname (optional)' : 'Gruppenname'}"
            class="group-title-input flex-1 px-3 py-2 ${isNested ? 'text-sm' : 'text-base sm:text-lg'} font-medium border-b border-gray-300 dark:border-gray-600 focus:outline-none focus:border-orange-500 bg-transparent text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400"
          />
          <div class="flex space-x-2">
            ${!isNested ? `
            <button 
              type="button" 
              class="add-nested-group-btn px-2 py-1 text-xs bg-blue-500 hover:bg-blue-600 text-white rounded transition-colors"
              title="Untergruppe hinzufügen"
            >
              + Untergruppe
            </button>
            ` : ''}
            <button 
              type="button" 
              class="remove-group-btn ${isNested ? '' : 'ml-0 sm:ml-3'} px-2 py-1 text-red-600 dark:text-red-400 hover:text-red-700 dark:hover:text-red-300 rounded transition-colors self-end"
            >
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
              </svg>
            </button>
          </div>
        </div>
        
        <div class="ingredients-list space-y-3 ${isNested ? 'ml-2' : ''}">
        </div>
        
        <div class="flex space-x-2 mt-3">
          ${!isNested ? `
          <button 
            type="button" 
            class="add-nested-group-btn px-3 py-2 text-sm bg-blue-500 hover:bg-blue-600 text-white rounded transition-colors"
          >
            + Untergruppe hinzufügen
          </button>
          ` : ''}
          <button 
            type="button" 
            class="add-ingredient-to-group-btn px-3 py-2 text-sm bg-gray-500 hover:bg-gray-600 dark:bg-gray-600 dark:hover:bg-gray-500 text-white rounded transition-colors w-full sm:w-auto"
          >
            + Zutat ${isNested ? 'zu dieser Untergruppe' : 'zu dieser Gruppe'} hinzufügen
          </button>
        </div>
      </div>
    `;
  }

  function addNestedGroup(parentGroupElement) {
    if (!parentGroupElement) return;
    
    const ingredientsList = parentGroupElement.querySelector('.ingredients-list');
    if (!ingredientsList) return;
    
    const nestedGroupId = generateId();
    const nestedGroupHtml = createIngredientGroupElement(nestedGroupId, '', true);
    
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = nestedGroupHtml;
    const nestedGroupElement = tempDiv.firstElementChild;
    
    ingredientsList.appendChild(nestedGroupElement);
    
    // Focus on the nested group title input
    const titleInput = nestedGroupElement.querySelector('.group-title-input');
    if (titleInput) {
      titleInput.focus();
    }
    
    // Update ingredient linker
    updateIngredientLinker();
    
    // Trigger draft save
    handleDraftChange();
  }

  function removeIngredient(button) {
    const ingredientElement = button.closest('.ingredient-edit-item');
    if (ingredientElement) {
      ingredientElement.remove();
      // Update ingredient linker with current DOM state
      updateIngredientLinker();
      // Trigger draft save
      handleDraftChange();
    }
  }

  function removeIngredientGroup(groupElement) {
    if (groupElement && !groupElement.classList.contains('default-group')) {
      groupElement.remove();
      // Update ingredient linker with current DOM state
      updateIngredientLinker();
      // Trigger draft save
      handleDraftChange();
    }
  }

  // Preparation functions
  function addStepToDefaultGroup() {
    const defaultGroup = document.querySelector('.preparation-group-edit.default-group');
    if (defaultGroup) {
      addStepToGroup(defaultGroup);
    }
  }

  function addStepToGroup(groupElement) {
    const stepsList = groupElement.querySelector('.steps-list');
    if (!stepsList) return;

    const stepId = generateId();
    const stepNumber = stepsList.children.length + 1;
    const stepHtml = createStepEditElement(stepId, '', stepNumber);
    
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = stepHtml;
    const stepElement = tempDiv.firstElementChild;
    
    stepsList.appendChild(stepElement);
    
    // Focus on the textarea
    const textarea = stepElement.querySelector('.step-text-input');
    if (textarea) {
      textarea.focus();
    }

    // Update step numbers
    updateStepNumbers(groupElement);
    
    // Trigger draft save
    handleDraftChange();
  }

  function createStepEditElement(id, text, stepNumber) {
    return `
      <div class="step-edit-item border border-gray-200 dark:border-gray-600 rounded-md p-4 bg-white dark:bg-gray-800 transition-colors duration-200" draggable="true" data-step-id="${id}">
        <div class="flex items-start space-x-3">
          <div class="flex items-center space-x-2">
            <div class="drag-handle cursor-move text-gray-400 hover:text-gray-600 dark:text-gray-500 dark:hover:text-gray-400">
              <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                <path d="M10 6a2 2 0 110-4 2 2 0 010 4zM10 12a2 2 0 110-4 2 2 0 010 4zM10 18a2 2 0 110-4 2 2 0 010 4z"/>
              </svg>
            </div>
            <div class="flex-shrink-0 w-8 h-8 bg-orange-500 text-white rounded-full flex items-center justify-center text-sm font-bold">
              ${stepNumber}
            </div>
          </div>
          <div class="flex-1 space-y-3">
            <textarea 
              rows="3"
              placeholder="Zubereitungsschritt..."
              class="step-text-input w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent bg-white dark:bg-gray-700 text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400"
            >${text}</textarea>
            
            <!-- Intermediate Ingredients Section -->
            <div class="intermediate-ingredients-section border-t border-gray-200 dark:border-gray-600 pt-3">
              <div class="flex justify-between items-center mb-2">
                <h4 class="text-sm font-medium text-gray-700 dark:text-gray-300">Zwischenzutaten</h4>
                <button 
                  type="button" 
                  class="add-intermediate-ingredient-btn px-2 py-1 text-xs bg-teal-500 hover:bg-teal-600 text-white rounded transition-colors"
                  title="Zwischenzutat hinzufügen"
                >
                  + Zwischenzutat
                </button>
              </div>
              <div class="intermediate-ingredients-list space-y-2">
                <!-- Intermediate ingredients will be populated dynamically -->
              </div>
            </div>
            
            <!-- Linked Ingredients Display -->
            <div class="linked-ingredients-display">
            </div>
            
            <!-- Ingredient Linking Buttons -->
            <div class="flex justify-between items-center">
              <div class="flex space-x-2">
                <button 
                  type="button" 
                  class="auto-link-btn px-3 py-1 text-xs bg-purple-500 hover:bg-purple-600 text-white rounded transition-colors flex items-center space-x-1"
                  title="Zutaten automatisch verlinken"
                >
                  <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v10a2 2 0 002 2h8a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01"/>
                  </svg>
                  <span>Auto-Link</span>
                </button>
                <button 
                  type="button" 
                  class="manual-link-btn px-3 py-1 text-xs bg-indigo-500 hover:bg-indigo-600 text-white rounded transition-colors flex items-center space-x-1"
                  title="Zutaten manuell verlinken"
                >
                  <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"/>
                  </svg>
                  <span>Manual-Link</span>
                </button>
              </div>
              <button 
                type="button" 
                class="remove-step-btn px-2 py-1 text-red-600 dark:text-red-400 hover:text-red-700 dark:hover:text-red-300 rounded transition-colors"
              >
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                </svg>
              </button>
            </div>
          </div>
        </div>
      </div>
    `;
  }

  function addPreparationGroup() {
    const container = document.getElementById('preparation-edit-container');
    if (!container) return;

    const groupId = generateId();
    const groupHtml = createPreparationGroupElement(groupId, '');
    
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = groupHtml;
    const groupElement = tempDiv.firstElementChild;
    
    container.appendChild(groupElement);
    
    // Focus on the group title input
    const titleInput = groupElement.querySelector('.group-title-input');
    if (titleInput) {
      titleInput.focus();
    }
  }

  function createPreparationGroupElement(id, title, isNested = false) {
    const containerClass = isNested 
      ? 'nested-preparation-group-edit border border-gray-200 dark:border-gray-600 rounded-md p-3 bg-gray-100 dark:bg-gray-700/30 transition-colors duration-200 ml-4'
      : 'preparation-group-edit border border-gray-300 dark:border-gray-600 rounded-lg p-4 bg-gray-50 dark:bg-gray-700/50 transition-colors duration-200';
    
    return `
      <div class="${containerClass}" data-group-id="${id}">
        <div class="flex flex-col sm:flex-row sm:justify-between sm:items-center mb-3 space-y-2 sm:space-y-0">
          <input 
            type="text" 
            value="${title}"
            placeholder="${isNested ? 'Untergruppenname (optional)' : 'Gruppenname'}"
            class="group-title-input flex-1 px-3 py-2 ${isNested ? 'text-sm' : 'text-lg'} font-medium border-b border-gray-300 dark:border-gray-600 focus:outline-none focus:border-green-500 bg-transparent text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400"
          />
          <div class="flex space-x-2">
            ${!isNested ? `
            <button 
              type="button" 
              class="add-nested-prep-group-btn px-2 py-1 text-xs bg-blue-500 hover:bg-blue-600 text-white rounded transition-colors"
              title="Untergruppe hinzufügen"
            >
              + Untergruppe
            </button>
            ` : ''}
            <button 
              type="button" 
              class="remove-prep-group-btn ${isNested ? '' : 'ml-0 sm:ml-3'} px-2 py-1 text-red-600 dark:text-red-400 hover:text-red-700 dark:hover:text-red-300 rounded transition-colors self-end"
            >
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
              </svg>
            </button>
          </div>
        </div>
        
        <div class="steps-list space-y-4 min-h-[60px] relative ${isNested ? 'ml-2' : ''}">
        </div>
        
        <div class="flex space-x-2 mt-3">
          ${!isNested ? `
          <button 
            type="button" 
            class="add-nested-prep-group-btn px-3 py-2 text-sm bg-blue-500 hover:bg-blue-600 text-white rounded transition-colors"
          >
            + Untergruppe hinzufügen
          </button>
          ` : ''}
          <button 
            type="button" 
            class="add-step-to-group-btn px-3 py-2 text-sm bg-gray-500 hover:bg-gray-600 dark:bg-gray-600 dark:hover:bg-gray-500 text-white rounded transition-colors"
          >
            + Schritt ${isNested ? 'zu dieser Untergruppe' : 'zu dieser Gruppe'} hinzufügen
          </button>
        </div>
      </div>
    `;
  }

  function addNestedPrepGroup(parentGroupElement) {
    if (!parentGroupElement) return;
    
    const stepsList = parentGroupElement.querySelector('.steps-list');
    if (!stepsList) return;
    
    const nestedGroupId = generateId();
    const nestedGroupHtml = createPreparationGroupElement(nestedGroupId, '', true);
    
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = nestedGroupHtml;
    const nestedGroupElement = tempDiv.firstElementChild;
    
    stepsList.appendChild(nestedGroupElement);
    
    // Focus on the nested group title input
    const titleInput = nestedGroupElement.querySelector('.group-title-input');
    if (titleInput) {
      titleInput.focus();
    }
    
    // Trigger draft save
    handleDraftChange();
  }

  function removePreparationStep(button) {
    const stepElement = button.closest('.step-edit-item');
    if (stepElement) {
      // Find the immediate parent group (could be nested or top-level)
      // Check for nested group first, then fall back to top-level group
      let groupElement = stepElement.closest('.nested-preparation-group-edit');
      if (!groupElement) {
        groupElement = stepElement.closest('.preparation-group-edit');
      }
      stepElement.remove();
      if (groupElement) {
        updateStepNumbers(groupElement);
      }
      // Trigger draft save
      handleDraftChange();
    }
  }

  function removePreparationGroup(groupElement) {
    if (groupElement && !groupElement.classList.contains('default-group')) {
      groupElement.remove();
      // Trigger draft save
      handleDraftChange();
    }
  }

  function updateStepNumbers(groupElement) {
    // Find the steps-list container first, then get its step children
    // Steps are nested inside .steps-list, not direct children of the group
    const stepsList = groupElement.querySelector('.steps-list');
    if (stepsList) {
      // Get only actual step elements, filtering out nested groups
      const directSteps = Array.from(stepsList.children)
        .filter(child => child.classList.contains('step-edit-item'));
      
      directSteps.forEach((step, index) => {
        const numberElement = step.querySelector('.bg-green-500');
        if (numberElement) {
          numberElement.textContent = index + 1;
        }
      });
    }
    
    // Also update step numbers in any nested groups within this group
    const nestedGroups = groupElement.querySelectorAll('.nested-preparation-group-edit');
    nestedGroups.forEach(nestedGroup => {
      const nestedStepsList = nestedGroup.querySelector('.steps-list');
      if (nestedStepsList) {
        const nestedSteps = Array.from(nestedStepsList.children)
          .filter(child => child.classList.contains('step-edit-item'));
        nestedSteps.forEach((step, index) => {
          const numberElement = step.querySelector('.bg-green-500');
          if (numberElement) {
            numberElement.textContent = index + 1;
          }
        });
      }
    });
  }

  // Utility function to generate IDs
  function generateId() {
    return 'id-' + Math.random().toString(36).substr(2, 9) + Date.now().toString(36);
  }

  // Update ingredient linker with current DOM state
  function updateIngredientLinker() {
    if (window.ingredientLinker) {
      // Update the recipe object in the ingredient linker with current ingredient groups
      const currentIngredientGroups = collectIngredientGroups();
      const currentPreparationGroups = collectPreparationGroupsForLinker();
      
      // Update the recipe data
      window.currentRecipe = {
        ...window.currentRecipe,
        ingredientGroups: currentIngredientGroups,
        preparationGroups: currentPreparationGroups
      };
      
      // Update the linker's internal recipe reference
      window.ingredientLinker.recipe = window.currentRecipe;
    }
  }

  // Collect preparation groups while preserving existing linked ingredients
  function collectPreparationGroupsForLinker() {
    const preparationGroups = [];
    
    // Helper function to collect items from a group element (recursively)
    function collectItemsFromPrepGroup(groupElement) {
      const items = [];
      const stepsList = groupElement.querySelector('.steps-list');
      if (!stepsList) return items;
      
      // Get direct children (steps and nested groups)
      Array.from(stepsList.children).forEach((child) => {
        // Check if it's a step
        if (child.classList.contains('step-edit-item')) {
          const textArea = child.querySelector('.step-text-input');
          const stepId = child.dataset.stepId;
          const stepText = textArea?.value.trim();
          
          // Only add steps with text or existing IDs
          if (stepText || stepId) {
            // Get existing linked ingredients from the linker's memory
            let linkedIngredients = [];
            if (window.ingredientLinker && stepId) {
              linkedIngredients = window.ingredientLinker.linkedIngredients.get(stepId) || [];
            }
            
            // Collect intermediate ingredients from this step
            let intermediateIngredients = [];
            if (window.intermediateIngredientManager && stepId) {
              const intermediateItems = child.querySelectorAll('.intermediate-ingredient-item');
              intermediateItems.forEach((item) => {
                const nameInput = item.querySelector('.intermediate-name-input');
                const descriptionInput = item.querySelector('.intermediate-description-input');
                const intermediateId = item.dataset.intermediateId;

                const name = nameInput?.value.trim();
                if (name && intermediateId) {
                  intermediateIngredients.push({
                    id: intermediateId,
                    name: name,
                    description: descriptionInput?.value.trim() || undefined
                  });
                }
              });
            }
            
            items.push({
              id: stepId || generateId(),
              text: stepText || '',
              linkedIngredients: linkedIngredients,
              intermediateIngredients: intermediateIngredients
            });
          }
        }
        // Check if it's a nested group
        else if (child.classList.contains('nested-preparation-group-edit')) {
          const nestedTitleInput = child.querySelector('.group-title-input');
          const nestedGroupTitle = nestedTitleInput?.value.trim() || null;
          const nestedGroupId = child.dataset.groupId || generateId();
          
          // Recursively collect items from nested group
          const nestedItems = collectItemsFromPrepGroup(child);
          
          // Only add nested group if it has items or a title
          if (nestedItems.length > 0 || nestedGroupTitle) {
            items.push({
              id: nestedGroupId,
              title: nestedGroupTitle,
              steps: nestedItems
            });
          }
        }
      });
      
      return items;
    }
    
    // Collect all top-level preparation group elements from the DOM
    const topLevelGroups = document.querySelectorAll('.preparation-group-edit:not(.nested-preparation-group-edit)');
    
    topLevelGroups.forEach((groupElement) => {
      const titleInput = groupElement.querySelector('.group-title-input');
      const isDefaultGroup = groupElement.classList.contains('default-group');
      
      // Get group title (null for default group)
      const groupTitle = isDefaultGroup ? null : (titleInput?.value.trim() || null);
      
      // Recursively collect all items (steps and nested groups)
      const items = collectItemsFromPrepGroup(groupElement);
      
      // Add group if it has items or a title
      if (items.length > 0 || (groupTitle && groupTitle.length > 0)) {
        preparationGroups.push({
          id: groupElement.dataset.groupId || generateId(),
          title: groupTitle,
          steps: items
        });
      }
    });
    
    // Ensure we always have at least one group (default group)
    if (preparationGroups.length === 0) {
      preparationGroups.push({
        id: generateId(),
        title: null,
        steps: []
      });
    }
    
    return preparationGroups;
  }

  async function handleFormSubmit(e) {
    e.preventDefault();
    
    // Get the save buttons (from header and bottom)
    const saveBtn = document.getElementById('save-btn');
    const saveBtnMobile = document.getElementById('save-btn-mobile');
    const saveBtnBottom = document.getElementById('save-btn-bottom');
    const saveBtnBottomMobile = document.getElementById('save-btn-bottom-mobile');
    const saveButtons = [saveBtn, saveBtnMobile, saveBtnBottom, saveBtnBottomMobile].filter(btn => btn instanceof HTMLButtonElement);
    
    try {
      // Show loading state on all save buttons
      saveButtons.forEach(btn => {
        const span = btn.querySelector('span');
        const svg = btn.querySelector('svg');
        if (span) span.textContent = 'Speichert...';
        if (svg) svg.style.display = 'none';
        btn.disabled = true;
      });
      
      // Collect updated recipe data
      const updatedRecipe = collectRecipeData();
      
      // Get current recipe ID from URL
      const recipeId = window.location.pathname.split('/').pop();
      
      // Send to backend
      const response = await fetch(`/api/recipes?id=${recipeId}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(updatedRecipe)
      });
      
      if (response.ok) {
        const savedRecipe = await response.json();
        window.currentRecipe = savedRecipe;
        
        // Delete draft after successful save
        const recipeId = window.location.pathname.split('/').pop();
        if (recipeId) {
          try {
            console.log('Deleting draft after successful save...');
            const deleted = await deleteDraft(recipeId);
            if (deleted) {
              console.log('Draft deleted successfully');
              // Hide the status bar since draft is deleted
              const statusBar = document.getElementById('draft-status-bar');
              if (statusBar) {
                statusBar.classList.add('hidden');
              }
            } else {
              console.warn('Failed to delete draft - API returned non-OK status');
            }
          } catch (error) {
            console.error('Error deleting draft after save:', error);
            // Continue anyway - the draft will be cleaned up later or on next page load
          }
        }
        
        // Set flag to prevent draft saving right after successful save
        justSavedRecipe = true;
        
        // Show success notification
        showNotification('Rezept erfolgreich gespeichert!', 'success');
        
        // Exit edit mode before reloading to prevent beforeunload from creating a new draft
        if (window.toggleEditMode && typeof window.toggleEditMode === 'function') {
          window.toggleEditMode();
        }
        
        // Reload the page to show updated content after a short delay
        setTimeout(() => {
          window.location.reload();
        }, 1500);
      } else {
        throw new Error(`Server error: ${response.status}`);
      }
      
    } catch (error) {
      console.error('Error saving recipe:', error);
      showNotification('Fehler beim Speichern des Rezepts. Bitte versuchen Sie es erneut.', 'error');
      
      // Restore button state on error
      saveButtons.forEach(btn => {
        const span = btn.querySelector('span');
        const svg = btn.querySelector('svg');
        if (span) span.textContent = 'Speichern';
        if (svg) svg.style.display = 'block';
        btn.disabled = false;
      });
    }
  }

  function collectRecipeData() {
    // Get updated recipe data from ingredient linker if available
    let updatedRecipe = window.currentRecipe;
    if (window.ingredientLinker) {
      updatedRecipe = window.ingredientLinker.getUpdatedRecipe() || updatedRecipe;
    }
    
    // Get tags data if available
    const tagsData = window.getRecipeTagsData ? window.getRecipeTagsData() : { category: updatedRecipe.category, tags: updatedRecipe.tags };
    
    // Collect form data
    const formData = {
      ...updatedRecipe,
      title: document.getElementById('edit-title')?.value || updatedRecipe.title,
      subtitle: document.getElementById('edit-subtitle')?.value ?? updatedRecipe.subtitle,
      description: document.getElementById('edit-description')?.value ?? updatedRecipe.description,
      sourceUrl: (() => {
        const sourceUrlValue = document.getElementById('edit-source-url')?.value?.trim();
        return sourceUrlValue && sourceUrlValue !== '' ? sourceUrlValue : undefined;
      })(),
      category: tagsData.category,
      tags: tagsData.tags,
              metadata: {
          ...updatedRecipe.metadata,
                  servings: parseInt(document.getElementById('edit-servings')?.value) || updatedRecipe.metadata.servings,
        timeEntries: window.getCurrentTimeEntries ? window.getCurrentTimeEntries() : (updatedRecipe.metadata.timeEntries || []),
        difficulty: (() => {
          const difficultyValue = document.getElementById('edit-difficulty')?.value;
          return difficultyValue && difficultyValue !== '' ? difficultyValue : undefined;
        })(),
          nutrition: {
            calories: parseFloat(document.getElementById('edit-calories')?.value) || undefined,
            carbohydrates: parseFloat(document.getElementById('edit-carbohydrates')?.value) || undefined,
            protein: parseFloat(document.getElementById('edit-protein')?.value) || undefined,
            fat: parseFloat(document.getElementById('edit-fat')?.value) || undefined
          }
        },
      // Include ingredient groups and preparation groups with linked ingredients
      ingredientGroups: collectIngredientGroups(),
      preparationGroups: collectPreparationGroups()
    };
    
    return formData;
  }

  function collectIngredientGroups() {
    const ingredientGroups = [];
    
    // Helper function to collect items from a group element (recursively)
    function collectItemsFromGroup(groupElement) {
      const items = [];
      const ingredientsList = groupElement.querySelector('.ingredients-list');
      if (!ingredientsList) return items;
      
      // Get direct children (ingredients and nested groups)
      Array.from(ingredientsList.children).forEach((child) => {
        // Check if it's an ingredient
        if (child.classList.contains('ingredient-edit-item')) {
          const nameInput = child.querySelector('.ingredient-name-input');
          const descriptionInput = child.querySelector('.ingredient-description-input');
          const amountInput = child.querySelector('input[type="number"]');
          const unitSelect = child.querySelector('.ingredient-unit-select');
          const ingredientId = child.dataset.ingredientId;
          
          const name = nameInput?.value.trim();
          const description = descriptionInput?.value.trim();
          const amount = parseFloat(amountInput?.value) || 0;
          const unit = unitSelect?.value || '';
          
          // Only add ingredients with a name
          if (name) {
            items.push({
              id: ingredientId || generateId(),
              name: name,
              description: description || undefined,
              quantities: [{
                amount: amount,
                unit: unit
              }]
            });
          }
        }
        // Check if it's a nested group
        else if (child.classList.contains('nested-ingredient-group-edit')) {
          const nestedTitleInput = child.querySelector('.group-title-input');
          const nestedGroupTitle = nestedTitleInput?.value.trim() || null;
          const nestedGroupId = child.dataset.groupId || generateId();
          
          // Recursively collect items from nested group
          const nestedItems = collectItemsFromGroup(child);
          
          // Only add nested group if it has items or a title
          if (nestedItems.length > 0 || nestedGroupTitle) {
            items.push({
              id: nestedGroupId,
              title: nestedGroupTitle,
              ingredients: nestedItems
            });
          }
        }
      });
      
      return items;
    }
    
    // Collect all top-level ingredient group elements from the DOM
    const topLevelGroups = document.querySelectorAll('.ingredient-group-edit:not(.nested-ingredient-group-edit)');
    
    topLevelGroups.forEach((groupElement) => {
      const titleInput = groupElement.querySelector('.group-title-input');
      const isDefaultGroup = groupElement.classList.contains('default-group');
      
      // Get group title (null for default group)
      const groupTitle = isDefaultGroup ? null : (titleInput?.value.trim() || null);
      
      // Recursively collect all items (ingredients and nested groups)
      const items = collectItemsFromGroup(groupElement);
      
      // Only add groups that have items or a title
      if (items.length > 0 || (groupTitle && groupTitle.length > 0)) {
        ingredientGroups.push({
          id: groupElement.dataset.groupId || generateId(),
          title: groupTitle,
          ingredients: items
        });
      }
    });
    
    // Ensure we always have at least one group (default group)
    if (ingredientGroups.length === 0) {
      ingredientGroups.push({
        id: generateId(),
        title: null,
        ingredients: []
      });
    }
    
    return ingredientGroups;
  }

  function collectPreparationGroups() {
    // Ensure the ingredient linker is up to date first
    updateIngredientLinker();
    
    // Now collect preparation groups with the preserved linked ingredients
    return collectPreparationGroupsForLinker();
  }

  function showNotification(message, type = 'info') {
    const notification = document.createElement('div');
    notification.className = `fixed top-4 right-4 z-50 px-4 py-2 rounded-lg shadow-lg text-white ${
      type === 'success' ? 'bg-green-500' : type === 'error' ? 'bg-red-500' : 'bg-blue-500'
    }`;
    notification.textContent = message;
    
    document.body.appendChild(notification);
    
    setTimeout(() => {
      notification.remove();
    }, 3000);
  }
</script> 