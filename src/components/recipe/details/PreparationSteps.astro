---
import type { Recipe, PreparationStep } from '../../../types/recipe';

interface Props {
  recipe: Recipe;
}

const { recipe } = Astro.props;

// Safety check: ensure preparationGroups exists and handle empty arrays
const preparationGroups = recipe?.preparationGroups || [];

// Recursive function to check if there are any steps (including nested groups)
function hasAnyStepsRecursive(groups: any[]): boolean {
  return groups.some(group => {
    if (!group?.steps || group.steps.length === 0) return false;
    return group.steps.some((item: any) => {
      if ('text' in item && item.text.trim()) {
        return true; // It's a step
      } else if ('steps' in item) {
        return hasAnyStepsRecursive([item]); // It's a nested group - recursively check
      }
      return false;
    });
  });
}
const hasAnySteps = hasAnyStepsRecursive(preparationGroups);

// Pre-calculate global step indices for all steps (shared across all rendering)
// This ensures consistent indexing and fixes Bug 2 where each step was recalculating from 0
const stepIndexMap = new Map<any, number>();
const globalStepCounter = { value: 0 };

// Helper to recursively map all steps to their global indices
function mapStepIndicesToGlobalIndex(groups: any[]) {
  groups.forEach(group => {
    if (group?.steps) {
      group.steps.forEach((item: any) => {
        if ('text' in item) {
          stepIndexMap.set(item, globalStepCounter.value);
          globalStepCounter.value++;
        } else if ('steps' in item) {
          // Nested group - recursively map its steps
          mapStepIndicesToGlobalIndex([item]);
        }
      });
    }
  });
}
mapStepIndicesToGlobalIndex(preparationGroups);

// Helper function to get all ingredients from the recipe (recursively)
function getAllIngredients(recipe: Recipe) {
  const ingredientGroups = recipe?.ingredientGroups || [];
  const allIngredients: any[] = [];
  
  // Recursive function to traverse nested groups
  function collectIngredients(groups: any[]) {
    groups.forEach(group => {
      if (group?.ingredients) {
        group.ingredients.forEach((item: any) => {
          if ('id' in item && 'name' in item) {
            // It's an ingredient
            allIngredients.push(item);
          } else if ('ingredients' in item) {
            // It's a nested group - recursively collect ingredients
            collectIngredients([item]);
          }
        });
      }
    });
  }
  
  collectIngredients(ingredientGroups);
  return allIngredients;
}

// Helper function to convert Celsius to gas mark
function getGasMark(celsius: number): string {
  // Gas mark conversion table
  const gasMarks = [
    { mark: '¼', min: 110, max: 120 },
    { mark: '½', min: 121, max: 135 },
    { mark: '1', min: 136, max: 150 },
    { mark: '2', min: 151, max: 165 },
    { mark: '3', min: 166, max: 180 },
    { mark: '4', min: 181, max: 195 },
    { mark: '5', min: 196, max: 210 },
    { mark: '6', min: 211, max: 225 },
    { mark: '7', min: 226, max: 240 },
    { mark: '8', min: 241, max: 260 },
    { mark: '9', min: 261, max: 290 },
    { mark: '10', min: 291, max: 320 }
  ];

  const gasMark = gasMarks.find(mark => celsius >= mark.min && celsius <= mark.max);
  return gasMark ? `Gasherd-Stufe ${gasMark.mark}` : '';
}

// Helper function to process text and add temperature tooltips
function processText(text: string): string {
  // Match temperatures like "180°C", "180 °C", "180° C", "180 Grad", etc.
  return text.replace(
    /(\d+)\s*(?:°|Grad|grad|°C|° C|°c|° c)\b/g, 
    (match, temp) => {
      const celsius = parseInt(temp);
      const gasMark = getGasMark(celsius);
      if (gasMark) {
        return `<button type="button" class="temperature-mark tooltip-trigger" data-tooltip="${gasMark}">${match}</button>`;
      }
      return match;
    }
  );
}

// Helper function to recursively count all steps (including nested groups)
function countAllStepsRecursive(groups: any[]): number {
  let count = 0;
  groups.forEach(group => {
    if (group?.steps) {
      group.steps.forEach((item: any) => {
        if ('text' in item) {
          count++;
        } else if ('steps' in item) {
          // It's a nested group
          count += countAllStepsRecursive([item]);
        }
      });
    }
  });
  return count;
}

// Helper function to recursively get all steps in order
function getAllStepsRecursive(groups: any[]): any[] {
  const allSteps: any[] = [];
  groups.forEach(group => {
    if (group?.steps) {
      group.steps.forEach((item: any) => {
        if ('text' in item) {
          allSteps.push(item);
        } else if ('steps' in item) {
          // It's a nested group - recursively get steps
          allSteps.push(...getAllStepsRecursive([item]));
        }
      });
    }
  });
  return allSteps;
}

// Helper function to track used ingredients across steps
function getUsedIngredients(preparationGroups: any[], currentStepIndex: number) {
  const usedIngredients = new Set<string>();
  const allSteps = getAllStepsRecursive(preparationGroups);
  
  for (let i = 0; i < Math.min(currentStepIndex, allSteps.length); i++) {
    const step = allSteps[i];
    if (step.linkedIngredients) {
      step.linkedIngredients.forEach((link: any) => {
        usedIngredients.add(link.ingredientId);
      });
    }
  }
  
  return usedIngredients;
}

// Helper function to calculate the global step index (recursively)
// Returns the global step index if found, or -1 if not found
// The currentIndex parameter is mutated to track the current position
function calculateGlobalStepIndexRecursive(preparationGroups: any[], targetGroup: any, targetItem: any, currentIndex: { value: number } = { value: 0 }): number {
  for (const group of preparationGroups) {
    if (group === targetGroup) {
      // We're in the target group - count steps until we find the target item
      if (group.steps) {
        for (const item of group.steps) {
          if (item === targetItem) {
            // Found the target item
            if ('text' in item) {
              return currentIndex.value;
            }
            // If it's a nested group, the target is the group itself
            // Return current index (before counting steps in the nested group)
            if ('steps' in item) {
              return currentIndex.value;
            }
            // Unknown item type, return current index
            return currentIndex.value;
          }
          // Count steps as we iterate (matching getAllStepsRecursive order)
          if ('text' in item) {
            currentIndex.value++;
          } else if ('steps' in item) {
            // Nested group - check if target is inside it
            const indexBeforeNested = currentIndex.value;
            // Create a separate counter for searching (to avoid mutating currentIndex if not found)
            const searchIndex = { value: indexBeforeNested };
            // Search for target in the nested group (pass the nested group's steps, not the group itself)
            const nestedIndex = calculateGlobalStepIndexRecursive([item], item, targetItem, searchIndex);
            if (nestedIndex !== -1) {
              // Found target in nested group - update main counter and return
              currentIndex.value = nestedIndex;
              return nestedIndex;
            }
            // Target not in nested group - count all steps in nested group
            // Pass the nested group as both the groups array and targetGroup to count all steps
            const countIndex = { value: indexBeforeNested };
            calculateGlobalStepIndexRecursive([item], item, null, countIndex);
            // Update main counter with the count from nested group
            currentIndex.value = countIndex.value;
            // Continue to next item (currentIndex now points after nested group)
          }
        }
      }
      // Target not found in this group
      return -1;
    } else {
      // Count all steps in this group (recursively) - target is in a different group
      if (group.steps) {
        group.steps.forEach((item: any) => {
          if ('text' in item) {
            currentIndex.value++;
          } else if ('steps' in item) {
            // Recursively count all steps in nested group (target is null, so just count)
            calculateGlobalStepIndexRecursive([item], item, null, currentIndex);
          }
        });
      }
    }
  }
  // Target not found
  return -1;
}
---

<div class="bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 transition-colors duration-200">
  <div class="p-6">
    <h2 class="text-2xl font-bold text-gray-900 dark:text-white mb-4 flex items-center">
      <svg class="w-6 h-6 mr-2 text-green-500" fill="currentColor" viewBox="0 0 20 20">
        <path fill-rule="evenodd" d="M12.316 3.051a1 1 0 01.633 1.265l-4 12a1 1 0 11-1.898-.632l4-12a1 1 0 011.265-.633zM5.707 6.293a1 1 0 010 1.414L3.414 10l2.293 2.293a1 1 0 11-1.414 1.414l-3-3a1 1 0 010-1.414l3-3a1 1 0 011.414 0zm8.586 0a1 1 0 011.414 0l3 3a1 1 0 010 1.414l-3 3a1 1 0 11-1.414-1.414L16.586 10l-2.293-2.293a1 1 0 010-1.414z" clip-rule="evenodd"/>
      </svg>
      Zubereitung
    </h2>
    
    {!hasAnySteps ? (
      <div class="text-gray-500 dark:text-gray-400 italic">
        Keine Zubereitungsschritte gefunden - bitte manuell hinzufügen.
      </div>
    ) : (
      <div class="space-y-4">
        {/* First show ungrouped steps */}
        {preparationGroups.filter(group => group && !group.title).map((group, ungroupedGroupIndex) => {
            let stepCounter = { value: 0 };
            
            // Helper function to render a step
            const renderStep = (step: PreparationStep, stepIndex: number, isNested: boolean = false) => {
              const allIngredients = getAllIngredients(recipe);
              // Use pre-calculated index from map
              const globalStepIndex = stepIndexMap.get(step) ?? 0;
              const usedIngredients = getUsedIngredients(recipe.preparationGroups, globalStepIndex);
            // Use global step index to ensure unique IDs across all ungrouped groups
            const stepId = `ungrouped-${ungroupedGroupIndex}-${globalStepIndex}`;
            
            // Process text for both temperatures and timers
            let processedText = processText(step.text);
            processedText = processedText.replace(
              /(\d+(?:[,\.]\d+)?(?:[-–]\d+(?:[,\.]\d+)?)?\s*(?:Minuten?|Min\.?|Stunden?|Std\.?))/gi,
              `<button class="timer-trigger text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-300 underline font-medium" data-time="$1" data-recipe-name="${recipe.title}" data-step-description="${step.text.replace(/"/g, '&quot;').replace(/\n/g, ' ').replace(/\s+/g, ' ').trim()}" data-step-id="${stepId}">$1</button>`
            );
            
            return (
              <li class="flex space-x-4" id={`step-${stepId}`}>
                <div class="flex-shrink-0 w-8 h-8 bg-orange-500 text-white rounded-full flex items-center justify-center text-sm font-bold">
                  {stepIndex + 1}
                </div>
                <div class="flex-1">
                  <p class="text-gray-900 dark:text-white leading-relaxed mb-2" set:html={processedText}></p>
                  
                  {/* Linked Ingredients Tags */}
                  {step.linkedIngredients && step.linkedIngredients.length > 0 && (
                    <div class="flex flex-wrap gap-2 mt-2">
                      {step.linkedIngredients.map((link) => {
                        if (link.isIntermediate) {
                          // Find intermediate ingredient from previous steps
                          const allSteps = getAllStepsRecursive(recipe.preparationGroups);
                          let intermediateIngredient = null;
                          for (const s of allSteps) {
                            if (s.intermediateIngredients) {
                              intermediateIngredient = s.intermediateIngredients.find((int: any) => int.id === link.ingredientId);
                              if (intermediateIngredient) break;
                            }
                          }
                          if (!intermediateIngredient) return null;
                          
                          return (
                            <button type="button" 
                                    class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-purple-100 text-purple-800 dark:bg-purple-900 dark:text-purple-200 hover:bg-purple-200 dark:hover:bg-purple-800 transition-colors tooltip-trigger"
                                    data-tooltip={intermediateIngredient.description}>
                              {intermediateIngredient.name}
                            </button>
                          );
                        } else {
                          // Regular ingredient
                          const ingredient = allIngredients.find(ing => ing.id === link.ingredientId);
                          if (!ingredient || !('name' in ingredient)) return null;
                          const quantity = ingredient.quantities[link.selectedQuantityIndex];
                          const wasUsedBefore = usedIngredients.has(link.ingredientId);
                          let quantityElement = null;
                          if (quantity.amount >= 1 && quantity.unit !== '') {
                            quantityElement = (
                              <span class="ingredient-amount" data-original-amount={quantity.amount} data-unit={quantity.unit}>
                                (<span class="amount-value">{quantity.amount}</span> {quantity.unit})
                              </span>
                            );
                          } else if (quantity.amount === 0 && quantity.unit !== '') {
                            quantityElement = <span> ({quantity.unit})</span>;
                          } else if (quantity.amount >= 1 && quantity.unit === '') {
                            quantityElement = (
                              <span class="ingredient-amount" data-original-amount={quantity.amount} data-unit="">
                                (<span class="amount-value">{quantity.amount}</span>)
                              </span>
                            );
                          }
                          
                          return (
                            <button type="button" 
                                    class={`inline-flex items-center px-2 py-1 rounded-full text-xs font-medium transition-colors tooltip-trigger ${
                                      wasUsedBefore 
                                        ? 'bg-amber-100 text-amber-800 dark:bg-amber-900 dark:text-amber-200 hover:bg-amber-200 dark:hover:bg-amber-800' 
                                        : 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200 hover:bg-green-200 dark:hover:bg-green-800'
                                    }`}
                                    data-tooltip={ingredient.description}>
                              {ingredient.name}{quantityElement}
                            </button>
                          );
                        }
                      })}
                    </div>
                  )}
                </div>
              </li>
            );
          };
          
          // Helper function to render items recursively
          const renderItems = (items: any[], isNested: boolean = false, localStepIndex: { value: number } = { value: 0 }) => {
            return items.map((item) => {
              // Check if it's a step
              if ('text' in item) {
                const step = item as PreparationStep;
                const currentIndex = localStepIndex.value;
                localStepIndex.value++;
                return renderStep(step, currentIndex, isNested);
              }
              // Check if it's a nested group
              else if ('steps' in item) {
                const nestedGroup = item as any;
                // Create a new counter for the nested group so numbering restarts at 1
                const nestedStepCounter = { value: 0 };
                return (
                  <li class="py-2">
                    {nestedGroup.title && (
                      <h4 class="font-medium text-gray-700 dark:text-gray-300 mb-2 text-sm ml-12">
                        {nestedGroup.title}
                      </h4>
                    )}
                    <ol class="space-y-4 ml-12">
                      {renderItems(nestedGroup.steps || [], true, nestedStepCounter)}
                    </ol>
                  </li>
                );
              }
              return null;
            });
          };
          
          return (
            <ol class="space-y-4">
              {renderItems(group.steps || [], false, stepCounter)}
            </ol>
          );
        })}
      
      {/* Then show grouped steps */}
      {preparationGroups.filter(group => group && group.title).map((group) => {
          const groupedGroupIndex = preparationGroups.findIndex(g => g === group);
          let stepCounter = { value: 0 };
          
          // Helper function to render a step
          const renderStep = (step: PreparationStep, stepIndex: number, groupTitle: string | null, isNested: boolean = false) => {
            const allIngredients = getAllIngredients(recipe);
            // Use pre-calculated index from map
            const globalStepIndex = stepIndexMap.get(step) ?? 0;
            const usedIngredients = getUsedIngredients(recipe.preparationGroups, globalStepIndex);
          const stepId = `${groupTitle?.toLowerCase().replace(/\s+/g, '-') || 'group'}-${stepIndex}`;
          
          // Process text for both temperatures and timers
          let processedText = processText(step.text);
          processedText = processedText.replace(
            /(\d+(?:[,\.]\d+)?(?:[-–]\d+(?:[,\.]\d+)?)?\s*(?:Minuten?|Min\.?|Stunden?|Std\.?))/gi,
            `<button class="timer-trigger text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-300 underline font-medium" data-time="$1" data-recipe-name="${recipe.title}" data-step-description="${step.text.replace(/"/g, '&quot;').replace(/\n/g, ' ').replace(/\s+/g, ' ').trim()}" data-step-id="${stepId}">$1</button>`
          );
          
          return (
            <li class="flex space-x-4" id={`step-${stepId}`}>
              <div class="flex-shrink-0 w-8 h-8 bg-orange-500 text-white rounded-full flex items-center justify-center text-sm font-bold">
                {stepIndex + 1}
              </div>
              <div class="flex-1">
                <p class="text-gray-900 dark:text-white leading-relaxed mb-2" set:html={processedText}></p>
                
                {/* Linked Ingredients Tags */}
                {step.linkedIngredients && step.linkedIngredients.length > 0 && (
                  <div class="flex flex-wrap gap-2 mt-2">
                    {step.linkedIngredients.map((link) => {
                      if (link.isIntermediate) {
                        // Find intermediate ingredient from previous steps
                        const allSteps = getAllStepsRecursive(recipe.preparationGroups);
                        let intermediateIngredient = null;
                        for (const s of allSteps) {
                          if (s.intermediateIngredients) {
                            intermediateIngredient = s.intermediateIngredients.find((int: any) => int.id === link.ingredientId);
                            if (intermediateIngredient) break;
                          }
                        }
                        if (!intermediateIngredient) return null;
                        
                        return (
                          <button type="button" 
                                  class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-purple-100 text-purple-800 dark:bg-purple-900 dark:text-purple-200 hover:bg-purple-200 dark:hover:bg-purple-800 transition-colors tooltip-trigger"
                                  data-tooltip={intermediateIngredient.description}>
                            {intermediateIngredient.name}
                          </button>
                        );
                      } else {
                        // Regular ingredient
                        const ingredient = allIngredients.find(ing => ing.id === link.ingredientId);
                        if (!ingredient || !('name' in ingredient)) return null;
                        const quantity = ingredient.quantities[link.selectedQuantityIndex];
                        const wasUsedBefore = usedIngredients.has(link.ingredientId);
                        let quantityElement = null;
                        if (quantity.amount >= 1 && quantity.unit !== '') {
                          quantityElement = (
                            <span class="ingredient-amount" data-original-amount={quantity.amount} data-unit={quantity.unit}>
                              (<span class="amount-value">{quantity.amount}</span> {quantity.unit})
                            </span>
                          );
                        } else if (quantity.amount === 0 && quantity.unit !== '') {
                          quantityElement = <span> ({quantity.unit})</span>;
                        } else if (quantity.amount >= 1 && quantity.unit === '') {
                          quantityElement = (
                            <span class="ingredient-amount" data-original-amount={quantity.amount} data-unit="">
                              (<span class="amount-value">{quantity.amount}</span>)
                            </span>
                          );
                        }
                        
                        return (
                          <button type="button" 
                                  class={`inline-flex items-center px-2 py-1 rounded-full text-xs font-medium transition-colors tooltip-trigger ${
                                    wasUsedBefore 
                                      ? 'bg-amber-100 text-amber-800 dark:bg-amber-900 dark:text-amber-200 hover:bg-amber-200 dark:hover:bg-amber-800' 
                                      : 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200 hover:bg-green-200 dark:hover:bg-green-800'
                                  }`}
                                  data-tooltip={ingredient.description}>
                            {ingredient.name}{quantityElement}
                          </button>
                        );
                      }
                    })}
                  </div>
                )}
              </div>
            </li>
          );
        };
        
        // Helper function to render items recursively
        const renderItems = (items: any[], parentTitle: string | null, isNested: boolean = false, localStepIndex: { value: number } = { value: 0 }) => {
          return items.map((item) => {
            // Check if it's a step
            if ('text' in item) {
              const step = item as PreparationStep;
              const currentIndex = localStepIndex.value;
              localStepIndex.value++;
              return renderStep(step, currentIndex, parentTitle, isNested);
            }
            // Check if it's a nested group
            else if ('steps' in item) {
              const nestedGroup = item as any;
              // Create a new counter for the nested group so numbering restarts at 1
              const nestedStepCounter = { value: 0 };
              return (
                <li class="py-2">
                  {nestedGroup.title && (
                    <h4 class="font-medium text-gray-700 dark:text-gray-300 mb-2 text-sm ml-12">
                      {nestedGroup.title}
                    </h4>
                  )}
                  <ol class="space-y-4 ml-12">
                    {renderItems(nestedGroup.steps || [], nestedGroup.title, true, nestedStepCounter)}
                  </ol>
                </li>
              );
            }
            return null;
          });
        };
        
        return (
          <div>
            <h3 class="font-semibold text-gray-800 dark:text-gray-200 mb-3 border-b border-gray-200 dark:border-gray-600 pb-1">
              {group.title}
            </h3>
            <ol class="space-y-4">
              {renderItems(group.steps || [], group.title ?? null, false, stepCounter)}
            </ol>
          </div>
        );
      })}
      </div>
    )}
  </div>
</div>

<!-- Tooltip container -->
<div id="tooltip" class="fixed left-0 top-0 z-[9999] px-3 py-2 text-sm bg-gray-900 text-white dark:bg-gray-800 rounded shadow-lg pointer-events-none opacity-0 transition-all duration-200 max-w-[250px] sm:max-w-[300px]" style="display: none;">
  <div class="tooltip-content"></div>
  <div class="tooltip-arrow"></div>
</div>

<script>
  const tooltip = document.getElementById('tooltip');
  let activeTarget: Element | null = null;
  let hideTimeout: number | null = null;

  if (!tooltip) {
    console.error('Tooltip element not found!');
  } else {
    console.log('Tooltip element found and initialized');
  }

  function showTooltip(target: Element) {
    const tooltipText = target.getAttribute('data-tooltip');
    if (!tooltipText || !tooltip) {
      console.log('No tooltip text or tooltip element:', { tooltipText, tooltip });
      return;
    }

    console.log('Showing tooltip:', tooltipText);

    // Clear any pending hide timeout
    if (hideTimeout !== null) {
      clearTimeout(hideTimeout);
      hideTimeout = null;
    }

    // Update content
    tooltip.querySelector('.tooltip-content')!.textContent = tooltipText;
    
    // Make tooltip visible
    tooltip.style.display = 'block';
    
    // Get positions
    const targetRect = target.getBoundingClientRect();
    const tooltipRect = tooltip.getBoundingClientRect();
    
    // Calculate position
    let top = targetRect.top - tooltipRect.height - 10;
    let left = targetRect.left + (targetRect.width / 2) - (tooltipRect.width / 2);
    
    // Check if tooltip would go above viewport
    const showBelow = top < 10;
    if (showBelow) {
      top = targetRect.bottom + 10;
      tooltip.classList.add('tooltip-below');
    } else {
      tooltip.classList.remove('tooltip-below');
    }
    
    // Keep tooltip in viewport horizontally
    if (left < 10) {
      left = 10;
    } else if (left + tooltipRect.width > window.innerWidth - 10) {
      left = window.innerWidth - tooltipRect.width - 10;
    }
    
    // Apply position
    tooltip.style.transform = `translate(${left}px, ${top}px)`;
    
    // Show tooltip
    requestAnimationFrame(() => {
      tooltip.style.opacity = '1';
    });
    
    activeTarget = target;
    console.log('Tooltip positioned at:', { top, left, showBelow });
  }

  function hideTooltip() {
    if (!tooltip) return;
    
    console.log('Hiding tooltip');
    tooltip.style.opacity = '0';
    tooltip.classList.remove('tooltip-below');
    
    hideTimeout = window.setTimeout(() => {
      tooltip.style.display = 'none';
      hideTimeout = null;
    }, 200);
    
    activeTarget = null;
  }

  // Event delegation for better performance
  document.addEventListener('click', (e) => {
    const target = e.target as Element;
    const tooltipTrigger = target.closest('.tooltip-trigger');

    if (tooltipTrigger) {
      console.log('Tooltip trigger clicked:', tooltipTrigger);
      if (activeTarget === tooltipTrigger) {
        hideTooltip();
      } else {
        showTooltip(tooltipTrigger);
      }
    } else if (activeTarget) {
      hideTooltip();
    }
  });

  // Mouse events for desktop
  document.addEventListener('mouseover', (e) => {
    const target = e.target as Element;
    const tooltipTrigger = target.closest('.tooltip-trigger');
    
    if (tooltipTrigger && !('ontouchstart' in window)) {
      console.log('Tooltip trigger hovered:', tooltipTrigger);
      showTooltip(tooltipTrigger);
    }
  });

  document.addEventListener('mouseout', (e) => {
    const target = e.target as Element;
    const tooltipTrigger = target.closest('.tooltip-trigger');
    
    if (tooltipTrigger && !('ontouchstart' in window)) {
      hideTooltip();
    }
  });

  // Hide on scroll
  document.addEventListener('scroll', () => {
    if (activeTarget) {
      hideTooltip();
    }
  }, { passive: true });
</script> 