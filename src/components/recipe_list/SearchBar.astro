---
interface Props {
  categories: string[];
}

const { categories } = Astro.props;
---

<div class="flex flex-col md:flex-row gap-4 mb-6">
  <!-- Search Input -->
  <div class="flex-1">
    <div class="relative">
      <input
        type="text"
        id="recipe-search"
        class="w-full pl-10 pr-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:ring-2 focus:ring-orange-500 focus:border-orange-500"
        placeholder="Nach Rezepten oder Tags suchen..."
      />
      <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
        <svg class="w-5 h-5 text-gray-400 dark:text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/>
        </svg>
      </div>
    </div>
  </div>

  <!-- Category Filter -->
  <div class="w-full md:w-64">
    <select
      id="category-filter"
      class="w-full px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:ring-2 focus:ring-orange-500 focus:border-orange-500"
    >
      <option value="">Alle Kategorien</option>
      {categories.map((category) => (
        <option value={category}>{category}</option>
      ))}
    </select>
  </div>
</div>

<script>
  // Get DOM elements
  const searchInput = document.getElementById('recipe-search') as HTMLInputElement;
  const categoryFilter = document.getElementById('category-filter') as HTMLSelectElement;
  const recipeCards = document.querySelectorAll('.recipe-card');
  const recipeCountElement = document.getElementById('recipe-count');

  // Add styles for search highlights and tags
  const style = document.createElement('style');
  style.textContent = `
    .search-highlight {
      animation: fadeIn 0.3s ease-in-out;
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    /* Tag styles are already defined in the RecipeCard component */
  `;
  document.head.appendChild(style);

  // Function to filter recipes
  function filterRecipes() {
    const searchTerms = searchInput.value.toLowerCase().split(' ').filter(term => term.length > 0);
    const selectedCategory = categoryFilter.value.toLowerCase();
    let visibleCount = 0;

    // Helper function to highlight text
    function highlightText(text: string, terms: string[]): string {
      let result = text;
      terms.forEach(term => {
        const regex = new RegExp(`(${term})`, 'gi');
        result = result.replace(regex, '<mark class="bg-yellow-200 dark:bg-yellow-800">$1</mark>');
      });
      return result;
    }

    recipeCards.forEach((card) => {
      // Store original tag structure if not already stored
      if (!card.hasAttribute('data-original-tags')) {
        const tagsContainer = card.querySelector('.flex.flex-wrap.gap-1\\.5');
        if (tagsContainer) {
          card.setAttribute('data-original-tags', tagsContainer.innerHTML);
        }
      }

      const titleElement = card.querySelector('.heading-tertiary');
      const descriptionElement = card.querySelector('.text-body');
      const title = titleElement?.textContent?.toLowerCase() || '';
      const description = descriptionElement?.textContent?.toLowerCase() || '';
      const category = card.getAttribute('data-category')?.toLowerCase() || '';
      
      // Get all tags, including hidden ones
      const tagsContainer = card.querySelector('.flex.flex-wrap.gap-1\\.5');
      const visibleTags = Array.from(card.querySelectorAll('.tag')).map(tag => tag.textContent?.toLowerCase() || '');
      const hiddenTags = card.querySelector('.tag-more')?.getAttribute('title')?.split(', ').map(tag => tag.toLowerCase()) || [];
      const allTagTexts = [...visibleTags, ...hiddenTags];

      const matchesSearch = searchTerms.length === 0 || searchTerms.every(term => 
        title.includes(term) || 
        description.includes(term) ||
        allTagTexts.some(tag => tag.includes(term))
      );
      
      const matchesCategory = selectedCategory === '' || category === selectedCategory;
      const isVisible = matchesSearch && matchesCategory;
      
      if (isVisible && searchTerms.length > 0) {
        // Highlight matches in title
        if (titleElement) {
          titleElement.innerHTML = highlightText(titleElement.textContent || '', searchTerms);
        }
        
        // Highlight matches in description
        if (descriptionElement) {
          descriptionElement.innerHTML = highlightText(descriptionElement.textContent || '', searchTerms);
        }

        // Handle tags
        if (tagsContainer) {
          // Get the first 3 visible tags and remaining hidden tags
          const displayTags = visibleTags.slice(0, 3);
          const remainingTags = [...visibleTags.slice(3), ...hiddenTags];
          
          // Clear current tags
          tagsContainer.innerHTML = '';
          
          // Add visible tags with highlights if they match
          displayTags.forEach(tag => {
            const tagElement = document.createElement('span');
            tagElement.className = 'tag text-xs py-0.5 px-2 rounded-full bg-orange-50 text-orange-700 dark:bg-orange-900/30 dark:text-orange-300';
            tagElement.innerHTML = searchTerms.some(term => tag.includes(term)) 
              ? highlightText(tag, searchTerms)
              : tag;
            tagsContainer.appendChild(tagElement);
          });
          
          // Add matching tags from remaining tags
          const matchingRemainingTags = remainingTags.filter(tag => 
            searchTerms.some(term => tag.toLowerCase().includes(term))
          );
          
          matchingRemainingTags.forEach(tag => {
            const tagElement = document.createElement('span');
            tagElement.className = 'tag text-xs py-0.5 px-2 rounded-full bg-orange-50 text-orange-700 dark:bg-orange-900/30 dark:text-orange-300 search-highlight';
            tagElement.innerHTML = highlightText(tag, searchTerms);
            tagsContainer.appendChild(tagElement);
          });
          
          // Add overflow indicator for non-matching remaining tags
          const nonMatchingCount = remainingTags.length - matchingRemainingTags.length;
          if (nonMatchingCount > 0) {
            const moreTag = document.createElement('span');
            moreTag.className = 'tag-more text-xs py-0.5 px-2 rounded-full bg-gray-100 text-gray-600 dark:bg-gray-700 dark:text-gray-400';
            moreTag.title = remainingTags.filter(tag => 
              !searchTerms.some(term => tag.toLowerCase().includes(term))
            ).join(', ');
            moreTag.textContent = `+${nonMatchingCount} weitere`;
            tagsContainer.appendChild(moreTag);
          }
        }
      } else {
        // Reset highlights and restore original tag structure
        if (titleElement) {
          titleElement.textContent = titleElement.textContent;
        }
        if (descriptionElement) {
          descriptionElement.textContent = descriptionElement.textContent;
        }
        
        // Restore original tag structure from stored HTML
        if (tagsContainer && card.hasAttribute('data-original-tags')) {
          tagsContainer.innerHTML = card.getAttribute('data-original-tags') || '';
        }
      }

      card.classList.toggle('hidden', !isVisible);
      if (isVisible) visibleCount++;
    });

    // Update recipe count
    if (recipeCountElement) {
      recipeCountElement.textContent = visibleCount.toString();
    }
  }

  // Add event listeners
  searchInput.addEventListener('input', filterRecipes);
  categoryFilter.addEventListener('change', filterRecipes);
</script> 