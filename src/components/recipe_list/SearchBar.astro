---
interface Props {
  categories: string[];
  initialSearchQuery?: string;
  initialCategory?: string;
}

const { categories, initialSearchQuery = '', initialCategory = '' } = Astro.props;
---

<div class="flex flex-col sm:flex-row gap-4">
  <!-- Search Input -->
  <div class="flex-1">
    <input
      type="text"
      id="recipe-search"
      class="w-full px-4 py-2 rounded-lg border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 focus:ring-2 focus:ring-orange-500 dark:focus:ring-orange-400 focus:border-transparent"
      placeholder="Rezept suchen..."
      value={initialSearchQuery}
    />
  </div>

  <!-- Category Filter -->
  <div class="w-full sm:w-48">
    <select
      id="category-filter"
      class="w-full px-4 py-2 rounded-lg border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 focus:ring-2 focus:ring-orange-500 dark:focus:ring-orange-400 focus:border-transparent"
    >
      <option value="">Alle Kategorien</option>
      {categories.map(category => (
        <option value={category} selected={category === initialCategory}>
          {category}
        </option>
      ))}
    </select>
  </div>
</div>

<script>
  let searchInput: HTMLInputElement | null = null;
  let categoryFilter: HTMLSelectElement | null = null;
  let recipeCards: NodeListOf<Element> | null = null;
  let recipeCountElement: HTMLElement | null = null;
  
  // Function to get/refresh all element references
  function refreshElements() {
    searchInput = document.getElementById('recipe-search') as HTMLInputElement;
    categoryFilter = document.getElementById('category-filter') as HTMLSelectElement;
    recipeCards = document.querySelectorAll('.recipe-card');
    recipeCountElement = document.getElementById('recipe-count');
  }
  
  // Initialize elements immediately
  refreshElements();

  // Add styles for search highlights and tags
  const style = document.createElement('style');
  style.textContent = `
    .search-highlight {
      animation: fadeIn 0.3s ease-in-out;
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    /* Tag styles are already defined in the RecipeCard component */
  `;
  document.head.appendChild(style);

  // Function to decode HTML entities
  function decodeHtml(html: string): string {
    const textarea = document.createElement('textarea');
    textarea.innerHTML = html;
    return textarea.value;
  }

  // Function to highlight text while preserving HTML entities
  function highlightText(text: string, searchTerms: string[]): string {
    let result = text;
    
    // First decode the HTML entities in the text
    result = decodeHtml(result);
    
    // Escape special characters in the text for regex
    result = result.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    
    // Apply highlighting for each search term
    searchTerms.forEach(term => {
      // Remove quotes for quoted terms
      const searchTerm = term.startsWith('"') && term.endsWith('"') 
        ? term.slice(1, -1) 
        : term;
      
      // Escape special characters in the search term
      const escapedTerm = searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      
      // Create regex that ignores HTML tags
      const regex = new RegExp(`(?![^<]*>)(${escapedTerm})`, 'gi');
      result = result.replace(regex, '<mark class="bg-yellow-200 dark:bg-yellow-700">$1</mark>');
    });
    
    return result;
  }

  // Guard to prevent filter from running too frequently
  let isFiltering = false;
  let lastFilterTime = 0;
  const MIN_FILTER_INTERVAL = 50; // Minimum milliseconds between filter runs
  let isUpdatingInputs = false; // Flag to prevent event cascades when programmatically updating inputs
  
  // Function to filter recipes
  function filterRecipes() {
    // Prevent running too frequently
    const now = Date.now();
    if (isFiltering || (now - lastFilterTime < MIN_FILTER_INTERVAL)) {
      return;
    }
    
    isFiltering = true;
    lastFilterTime = now;
    
    try {
      // Ensure elements are available
      if (!searchInput || !categoryFilter || !recipeCards) {
        refreshElements();
        if (!searchInput || !categoryFilter || !recipeCards) {
          return; // Still not available, skip filtering
        }
      }
      
      // Make sure recipeCards is not empty
      if (recipeCards.length === 0) {
        refreshElements();
        if (!recipeCards || recipeCards.length === 0) {
          return; // No cards found, skip filtering
        }
      }
      
      // Safety check: if there are too many cards, use requestAnimationFrame to avoid blocking
      if (recipeCards.length > 100) {
        // Use requestAnimationFrame to break up the work
        requestAnimationFrame(() => {
          performFiltering();
        });
        return;
      }
      
      performFiltering();
    } finally {
      // Always reset the filtering flag
      isFiltering = false;
    }
  }
  
  // Separate function for the actual filtering logic
  function performFiltering() {
    
    // Parse search terms, handling quoted phrases and special tag search
    function parseSearchTerms(input: string): { regular: string[]; tagOnly: string[] } {
      const terms = {
        regular: [] as string[],
        tagOnly: [] as string[]
      };
      let currentTerm = '';
      let inQuotes = false;
      
      // Helper to add a term if it's not empty
      const addTerm = (term: string) => {
        const trimmed = term.trim().toLowerCase();
        if (trimmed) {
          // Check if this is a tag-specific search
          if (inQuotes && trimmed.startsWith('tag:')) {
            terms.tagOnly.push(trimmed.slice(4)); // Remove 'tag:' prefix
          } else {
            terms.regular.push(trimmed);
          }
        }
      };

      for (let i = 0; i < input.length; i++) {
        const char = input[i];
        
        if (char === '"') {
          if (inQuotes) {
            // End of quoted phrase
            addTerm(currentTerm);
            currentTerm = '';
          }
          inQuotes = !inQuotes;
        } else if (char === ' ' && !inQuotes) {
          // Space outside quotes - end current term
          addTerm(currentTerm);
          currentTerm = '';
        } else {
          currentTerm += char;
        }
      }
      
      // Add any remaining term
      addTerm(currentTerm);
      
      return terms;
    }

    // Check if text matches search terms
    function matchesSearchTerms(text: string, terms: string[]): boolean {
      // Decode HTML entities before matching
      const normalizedText = decodeHtml(text).toLowerCase();
      
      return terms.every(term => {
        if (term.startsWith('"') && term.endsWith('"')) {
          // Exact phrase match for quoted terms
          const phrase = term.slice(1, -1);
          return normalizedText.includes(phrase);
        } else {
          // Individual word match for unquoted terms
          return normalizedText.includes(term);
        }
      });
    }

    const searchTerms = parseSearchTerms(searchInput.value);
    const selectedCategory = categoryFilter.value.toLowerCase();
    let visibleCount = 0;

    recipeCards.forEach((card) => {
      // Store original tag structure if not already stored
      if (!card.hasAttribute('data-original-tags')) {
        const tagsContainer = card.querySelector('.flex.flex-wrap.gap-1\\.5');
        if (tagsContainer) {
          card.setAttribute('data-original-tags', tagsContainer.innerHTML);
        }
      }

      const titleElement = card.querySelector('.heading-tertiary');
      const descriptionElement = card.querySelector('.text-body');
      const title = titleElement?.textContent?.toLowerCase() || '';
      const description = descriptionElement?.textContent?.toLowerCase() || '';
      const category = card.getAttribute('data-category')?.toLowerCase() || '';
      
      // Get all tags, including hidden ones
      const tagsContainer = card.querySelector('.flex.flex-wrap.gap-1\\.5');
      const visibleTags = Array.from(card.querySelectorAll('.tag')).map(tag => tag.textContent?.toLowerCase() || '');
      const hiddenTags = card.querySelector('.tag-more')?.getAttribute('title')?.split(', ').map(tag => tag.toLowerCase()) || [];
      const allTagTexts = [...visibleTags, ...hiddenTags];

      // Check if all tag-specific terms match
      const matchesTags = searchTerms.tagOnly.length === 0 || 
        searchTerms.tagOnly.every(tagTerm => 
          allTagTexts.some(tag => tag.includes(tagTerm))
        );

      // Check if regular terms match in title, description, or tags
      const matchesRegular = searchTerms.regular.length === 0 || (
        matchesSearchTerms(title, searchTerms.regular) || 
        matchesSearchTerms(description, searchTerms.regular) ||
        allTagTexts.some(tag => matchesSearchTerms(tag, searchTerms.regular))
      );
      
      const matchesCategory = selectedCategory === '' || category === selectedCategory;
      const isVisible = matchesTags && matchesRegular && matchesCategory;
      
      if (isVisible && (searchTerms.regular.length > 0 || searchTerms.tagOnly.length > 0)) {
        // Highlight matches in title and description only for regular terms
        if (titleElement && titleElement.textContent && searchTerms.regular.length > 0) {
          titleElement.innerHTML = highlightText(titleElement.textContent, searchTerms.regular);
        }
        
        if (descriptionElement && descriptionElement.textContent && searchTerms.regular.length > 0) {
          descriptionElement.innerHTML = highlightText(descriptionElement.textContent, searchTerms.regular);
        }

        // Handle tags - highlight for both regular and tag-specific terms
        if (tagsContainer) {
          // Get the first 3 visible tags and remaining hidden tags
          const displayTags = visibleTags.slice(0, 3);
          const remainingTags = [...visibleTags.slice(3), ...hiddenTags];
          
          // Clear current tags
          tagsContainer.innerHTML = '';
          
          // Add visible tags with highlights if they match
          displayTags.forEach(tag => {
            if (!tag) return;
            const tagElement = document.createElement('span');
            tagElement.className = 'tag text-xs py-0.5 px-2 rounded-full bg-orange-50 text-orange-700 dark:bg-orange-900/30 dark:text-orange-300';
            
            // Check if tag matches any search term (regular or tag-specific)
            const matchesAnyTerm = 
              searchTerms.regular.some(term => matchesSearchTerms(tag, [term])) ||
              searchTerms.tagOnly.some(tagTerm => tag.includes(tagTerm));
            
            tagElement.innerHTML = matchesAnyTerm
              ? highlightText(tag, [...searchTerms.regular, ...searchTerms.tagOnly.map(t => `"${t}"`)])
              : decodeHtml(tag);
            tagsContainer.appendChild(tagElement);
          });
          
          // Add matching tags from remaining tags
          const matchingRemainingTags = remainingTags.filter(tag => 
            tag && (
              searchTerms.regular.some(term => matchesSearchTerms(tag, [term])) ||
              searchTerms.tagOnly.some(tagTerm => tag.includes(tagTerm))
            )
          );
          
          matchingRemainingTags.forEach(tag => {
            if (!tag) return;
            const tagElement = document.createElement('span');
            tagElement.className = 'tag text-xs py-0.5 px-2 rounded-full bg-orange-50 text-orange-700 dark:bg-orange-900/30 dark:text-orange-300 search-highlight';
            tagElement.innerHTML = highlightText(tag, [...searchTerms.regular, ...searchTerms.tagOnly.map(t => `"${t}"`)])
            tagsContainer.appendChild(tagElement);
          });
          
          // Add overflow indicator for non-matching remaining tags
          const nonMatchingCount = remainingTags.length - matchingRemainingTags.length;
          if (nonMatchingCount > 0) {
            const moreTag = document.createElement('span');
            moreTag.className = 'tag-more text-xs py-0.5 px-2 rounded-full bg-gray-100 text-gray-600 dark:bg-gray-700 dark:text-gray-400';
            moreTag.title = remainingTags.filter(tag => 
              tag && !(
                searchTerms.regular.some(term => matchesSearchTerms(tag, [term])) ||
                searchTerms.tagOnly.some(tagTerm => tag.includes(tagTerm))
              )
            ).map(tag => decodeHtml(tag || '')).join(', ');
            moreTag.textContent = `+${nonMatchingCount} weitere`;
            tagsContainer.appendChild(moreTag);
          }
        }
      } else {
        // Reset highlights and restore original content
        if (titleElement && titleElement.textContent) {
          titleElement.textContent = decodeHtml(titleElement.textContent);
        }
        if (descriptionElement && descriptionElement.textContent) {
          descriptionElement.textContent = decodeHtml(descriptionElement.textContent);
        }
        
        // Restore original tag structure from stored HTML
        if (tagsContainer && card.hasAttribute('data-original-tags')) {
          tagsContainer.innerHTML = card.getAttribute('data-original-tags') || '';
        }
      }

      card.classList.toggle('hidden', !isVisible);
      if (isVisible) visibleCount++;
    });

    // Update recipe count
    if (recipeCountElement) {
      recipeCountElement.textContent = visibleCount.toString();
    }
  }

  // Update URL when search or category changes
  function updateURL() {
    const url = new URL(window.location.href);
    
    if (searchInput.value) {
      url.searchParams.set('search', searchInput.value);
    } else {
      url.searchParams.delete('search');
    }
    
    if (categoryFilter.value) {
      url.searchParams.set('category', categoryFilter.value);
    } else {
      url.searchParams.delete('category');
    }
    
    window.history.replaceState({}, '', url);
  }

  // Debounce function to limit how often filterRecipes runs
  let searchTimeout: ReturnType<typeof setTimeout> | null = null;
  function debouncedFilter(immediate = false) {
    if (searchTimeout) {
      clearTimeout(searchTimeout);
      searchTimeout = null;
    }
    
    if (immediate) {
      // Run immediately without debounce (for restoring from URL)
      filterRecipes();
      updateURL();
    } else {
      // Normal debounced behavior
      searchTimeout = setTimeout(() => {
        filterRecipes();
        updateURL();
      }, 300); // Wait 300ms after user stops typing
    }
  }

  // Add event listeners with URL updates (only if elements exist)
  if (searchInput) {
    searchInput.addEventListener('input', () => {
      // Skip if we're programmatically updating the input
      if (isUpdatingInputs) return;
      debouncedFilter();
    });
  }

  if (categoryFilter) {
    categoryFilter.addEventListener('change', () => {
      // Skip if we're programmatically updating the input
      if (isUpdatingInputs) return;
      // Category changes don't need debouncing since they're discrete events
      filterRecipes();
      updateURL();
    });
  }

  // Function to apply initial filter based on URL parameters
  function applyInitialFilter() {
    // Prevent running if already filtering
    if (isFiltering || isReapplyingFilter) {
      return;
    }
    
    // Refresh elements to ensure they're available
    refreshElements();
    
    if (!searchInput || !categoryFilter) {
      return;
    }
    
    // Check both input values and URL parameters (URL takes precedence)
    const urlParams = new URLSearchParams(window.location.search);
    const urlSearch = urlParams.get('search') || '';
    const urlCategory = urlParams.get('category') || '';
    
    // Update input values from URL if they differ (without triggering events)
    isUpdatingInputs = true;
    try {
      if (urlSearch && searchInput.value !== urlSearch) {
        searchInput.value = urlSearch;
      }
      if (urlCategory && categoryFilter.value !== urlCategory) {
        categoryFilter.value = urlCategory;
      }
    } finally {
      isUpdatingInputs = false;
    }
    
    // Apply filter if we have search query or category (from either source)
    if (searchInput.value || categoryFilter.value || urlSearch || urlCategory) {
      filterRecipes();
    }
  }

  // Guard to prevent multiple simultaneous retry loops
  let isReapplyingFilter = false;
  let reapplyTimeout: ReturnType<typeof setTimeout> | null = null;
  
  // Function to re-apply filter when returning to page
  function reapplyFilterOnReturn(retryCount = 0) {
    // Prevent multiple simultaneous calls
    if (isReapplyingFilter && retryCount === 0) {
      return;
    }
    
    // Clear any pending timeout
    if (reapplyTimeout) {
      clearTimeout(reapplyTimeout);
      reapplyTimeout = null;
    }
    
    // Mark as reapplying
    if (retryCount === 0) {
      isReapplyingFilter = true;
    }
    
    // Refresh all element references
    refreshElements();
    
    // Check if URL parameters exist first (before checking elements)
    const urlParams = new URLSearchParams(window.location.search);
    const searchParam = urlParams.get('search') || '';
    const categoryParam = urlParams.get('category') || '';
    
    // If no search params, no need to filter
    if (!searchParam && !categoryParam) {
      isReapplyingFilter = false;
      return;
    }
    
    // If elements aren't ready yet, retry a few times
    if (!searchInput || !categoryFilter || !recipeCards || recipeCards.length === 0) {
      if (retryCount < 10) {
        reapplyTimeout = setTimeout(() => {
          reapplyFilterOnReturn(retryCount + 1);
        }, 50);
      } else {
        // Max retries reached, give up
        isReapplyingFilter = false;
      }
      return;
    }
    
    // Update input values to match URL (in case they're out of sync)
    // Use flag to prevent event cascades
    isUpdatingInputs = true;
    try {
      if (searchInput.value !== searchParam) {
        searchInput.value = searchParam;
      }
      if (categoryFilter.value !== categoryParam) {
        categoryFilter.value = categoryParam;
      }
    } finally {
      isUpdatingInputs = false;
    }
    
    // Re-apply filter
    filterRecipes();
    
    // Mark as done
    isReapplyingFilter = false;
  }

  // Apply filter on initial load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', applyInitialFilter);
  } else {
    applyInitialFilter();
  }

  // Debounce function for page events to prevent multiple simultaneous calls
  let pageEventTimeout: ReturnType<typeof setTimeout> | null = null;
  let isReapplyingPage = false;
  function debouncedReapply() {
    // Prevent multiple simultaneous calls
    if (isReapplyingPage) {
      return;
    }
    
    if (pageEventTimeout) {
      clearTimeout(pageEventTimeout);
    }
    pageEventTimeout = setTimeout(() => {
      // Only reapply if we're on the recipe list page
      if (window.location.pathname === '/rezepte') {
        isReapplyingPage = true;
        try {
          refreshElements();
          // Only call reapplyFilterOnReturn, which handles everything
          // Don't call applyInitialFilter separately to avoid double filtering
          reapplyFilterOnReturn();
        } finally {
          isReapplyingPage = false;
          pageEventTimeout = null;
        }
      } else {
        pageEventTimeout = null;
      }
    }, 100); // Small delay to batch multiple rapid events
  }
  
  // Guard to prevent duplicate event listeners
  if (!(window as any).searchBarListenersAdded) {
    (window as any).searchBarListenersAdded = true;
    
    // Re-apply filter when page is shown (including when restored from back/forward cache)
    // This handles the case when user navigates back to the recipe list
    window.addEventListener('pageshow', (event) => {
      debouncedReapply();
    });
    
    // Also listen for Astro navigation events if using client-side routing
    document.addEventListener('astro:after-swap', () => {
      debouncedReapply();
    });
    
    // Also check on focus in case page was in background (but debounced)
    window.addEventListener('focus', () => {
      debouncedReapply();
    });
  }
  
  // Expose filter functions globally so they can be called from page level
  (window as any).reapplyRecipeFilter = reapplyFilterOnReturn;
  (window as any).filterRecipes = filterRecipes;
  (window as any).debouncedFilter = debouncedFilter;
</script> 