---
interface Props {
  categories: string[];
  initialSearchQuery?: string;
  initialCategory?: string;
}

const { categories, initialSearchQuery = '', initialCategory = '' } = Astro.props;
---

<div class="flex flex-col sm:flex-row gap-4">
  <!-- Search Input -->
  <div class="flex-1">
    <input
      type="text"
      id="recipe-search"
      class="w-full px-4 py-2 rounded-lg border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 focus:ring-2 focus:ring-orange-500 dark:focus:ring-orange-400 focus:border-transparent"
      placeholder="Rezept suchen..."
      value={initialSearchQuery}
    />
  </div>

  <!-- Category Filter -->
  <div class="w-full sm:w-48">
    <select
      id="category-filter"
      class="w-full px-4 py-2 rounded-lg border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 focus:ring-2 focus:ring-orange-500 dark:focus:ring-orange-400 focus:border-transparent"
    >
      <option value="">Alle Kategorien</option>
      {categories.map(category => (
        <option value={category} selected={category === initialCategory}>
          {category}
        </option>
      ))}
    </select>
  </div>
</div>

<script>
  let searchInput: HTMLInputElement | null = null;
  let categoryFilter: HTMLSelectElement | null = null;
  let recipeCards: NodeListOf<Element> | null = null;
  let recipeCountElement: HTMLElement | null = null;
  
  // Function to get/refresh all element references
  function refreshElements() {
    try {
      searchInput = document.getElementById('recipe-search') as HTMLInputElement;
      categoryFilter = document.getElementById('category-filter') as HTMLSelectElement;
      recipeCards = document.querySelectorAll('.recipe-card');
      recipeCountElement = document.getElementById('recipe-count');
    } catch (error) {
      console.error('Error refreshing elements:', error);
    }
  }
  
  // Don't initialize elements immediately - wait for DOM to be ready
  // This prevents blocking on mobile devices

  // Add styles for search highlights and tags (deferred to avoid blocking)
  function addStyles() {
    if (document.getElementById('search-bar-styles')) return; // Already added
    
    const style = document.createElement('style');
    style.id = 'search-bar-styles';
    style.textContent = `
      .search-highlight {
        animation: fadeIn 0.3s ease-in-out;
      }
      @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
      }
      /* Tag styles are already defined in the RecipeCard component */
    `;
    document.head.appendChild(style);
  }

  // Function to decode HTML entities
  function decodeHtml(html: string): string {
    const textarea = document.createElement('textarea');
    textarea.innerHTML = html;
    return textarea.value;
  }

  // Function to highlight text while preserving HTML entities
  function highlightText(text: string, searchTerms: string[]): string {
    let result = text;
    
    // First decode the HTML entities in the text
    result = decodeHtml(result);
    
    // Escape special characters in the text for regex
    result = result.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    
    // Apply highlighting for each search term
    searchTerms.forEach(term => {
      // Remove quotes for quoted terms
      const searchTerm = term.startsWith('"') && term.endsWith('"') 
        ? term.slice(1, -1) 
        : term;
      
      // Escape special characters in the search term
      const escapedTerm = searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      
      // Create regex that ignores HTML tags
      const regex = new RegExp(`(?![^<]*>)(${escapedTerm})`, 'gi');
      result = result.replace(regex, '<mark class="bg-yellow-200 dark:bg-yellow-700">$1</mark>');
    });
    
    return result;
  }

  // Guard to prevent filter from running too frequently
  let isFiltering = false;
  let lastFilterTime = 0;
  const MIN_FILTER_INTERVAL = 100; // Increased to 100ms minimum between filter runs
  let isUpdatingInputs = false; // Flag to prevent event cascades when programmatically updating inputs
  let filterStartTime = 0;
  const MAX_FILTER_TIME = 100; // Maximum time filter should take (ms) - if exceeded, abort
  let isNavigating = false; // Flag to disable filtering during navigation
  
  // Function to filter recipes
  function filterRecipes() {
    // Don't filter during navigation
    if (isNavigating) {
      return;
    }
    
    // Prevent running too frequently
    const now = Date.now();
    if (isFiltering || (now - lastFilterTime < MIN_FILTER_INTERVAL)) {
      return;
    }
    
    isFiltering = true;
    lastFilterTime = now;
    
    try {
      // Ensure elements are available
      if (!searchInput || !categoryFilter || !recipeCards) {
        refreshElements();
        if (!searchInput || !categoryFilter || !recipeCards) {
          return; // Still not available, skip filtering
        }
      }
      
      // Make sure recipeCards is not empty
      if (recipeCards.length === 0) {
        refreshElements();
        if (!recipeCards || recipeCards.length === 0) {
          return; // No cards found, skip filtering
        }
      }
      
      // Safety check: if there are too many cards, use requestAnimationFrame to avoid blocking
      if (recipeCards.length > 100) {
        // Use requestAnimationFrame to break up the work
        requestAnimationFrame(() => {
          performFiltering();
        });
        return;
      }
      
      performFiltering();
    } finally {
      // Always reset the filtering flag
      isFiltering = false;
    }
  }
  
  // Separate function for the actual filtering logic
  function performFiltering() {
    filterStartTime = Date.now();
    
    // Parse search terms, handling quoted phrases and special tag search
    function parseSearchTerms(input: string): { regular: string[]; tagOnly: string[] } {
      const terms = {
        regular: [] as string[],
        tagOnly: [] as string[]
      };
      let currentTerm = '';
      let inQuotes = false;
      
      // Helper to add a term if it's not empty
      const addTerm = (term: string) => {
        const trimmed = term.trim().toLowerCase();
        if (trimmed) {
          // Check if this is a tag-specific search
          if (inQuotes && trimmed.startsWith('tag:')) {
            terms.tagOnly.push(trimmed.slice(4)); // Remove 'tag:' prefix
          } else {
            terms.regular.push(trimmed);
          }
        }
      };

      for (let i = 0; i < input.length; i++) {
        const char = input[i];
        
        if (char === '"') {
          if (inQuotes) {
            // End of quoted phrase
            addTerm(currentTerm);
            currentTerm = '';
          }
          inQuotes = !inQuotes;
        } else if (char === ' ' && !inQuotes) {
          // Space outside quotes - end current term
          addTerm(currentTerm);
          currentTerm = '';
        } else {
          currentTerm += char;
        }
      }
      
      // Add any remaining term
      addTerm(currentTerm);
      
      return terms;
    }

    // Check if text matches search terms
    function matchesSearchTerms(text: string, terms: string[]): boolean {
      // Decode HTML entities before matching
      const normalizedText = decodeHtml(text).toLowerCase();
      
      return terms.every(term => {
        if (term.startsWith('"') && term.endsWith('"')) {
          // Exact phrase match for quoted terms
          const phrase = term.slice(1, -1);
          return normalizedText.includes(phrase);
        } else {
          // Individual word match for unquoted terms
          return normalizedText.includes(term);
        }
      });
    }

    const searchTerms = parseSearchTerms(searchInput.value);
    const selectedCategory = categoryFilter.value.toLowerCase();
    let visibleCount = 0;

    // Check timeout before starting
    if (Date.now() - filterStartTime > MAX_FILTER_TIME) {
      console.warn('Filter timeout check failed before start');
      return;
    }
    
    recipeCards.forEach((card) => {
      // Check if we're taking too long (abort if so)
      if (Date.now() - filterStartTime > MAX_FILTER_TIME) {
        console.warn('Filter taking too long, aborting');
        return;
      }
      
      // Store original tag structure if not already stored
      if (!card.hasAttribute('data-original-tags')) {
        const tagsContainer = card.querySelector('.flex.flex-wrap.gap-1\\.5');
        if (tagsContainer) {
          card.setAttribute('data-original-tags', tagsContainer.innerHTML);
        }
      }

      const titleElement = card.querySelector('.heading-tertiary');
      const descriptionElement = card.querySelector('.text-body');
      const title = titleElement?.textContent?.toLowerCase() || '';
      const description = descriptionElement?.textContent?.toLowerCase() || '';
      const category = card.getAttribute('data-category')?.toLowerCase() || '';
      
      // Get all tags, including hidden ones
      const tagsContainer = card.querySelector('.flex.flex-wrap.gap-1\\.5');
      const visibleTags = Array.from(card.querySelectorAll('.tag')).map(tag => tag.textContent?.toLowerCase() || '');
      const hiddenTags = card.querySelector('.tag-more')?.getAttribute('title')?.split(', ').map(tag => tag.toLowerCase()) || [];
      const allTagTexts = [...visibleTags, ...hiddenTags];

      // Check if all tag-specific terms match
      const matchesTags = searchTerms.tagOnly.length === 0 || 
        searchTerms.tagOnly.every(tagTerm => 
          allTagTexts.some(tag => tag.includes(tagTerm))
        );

      // Check if regular terms match in title, description, or tags
      const matchesRegular = searchTerms.regular.length === 0 || (
        matchesSearchTerms(title, searchTerms.regular) || 
        matchesSearchTerms(description, searchTerms.regular) ||
        allTagTexts.some(tag => matchesSearchTerms(tag, searchTerms.regular))
      );
      
      const matchesCategory = selectedCategory === '' || category === selectedCategory;
      const isVisible = matchesTags && matchesRegular && matchesCategory;
      
      if (isVisible && (searchTerms.regular.length > 0 || searchTerms.tagOnly.length > 0)) {
        // Highlight matches in title and description only for regular terms
        if (titleElement && titleElement.textContent && searchTerms.regular.length > 0) {
          titleElement.innerHTML = highlightText(titleElement.textContent, searchTerms.regular);
        }
        
        if (descriptionElement && descriptionElement.textContent && searchTerms.regular.length > 0) {
          descriptionElement.innerHTML = highlightText(descriptionElement.textContent, searchTerms.regular);
        }

        // Handle tags - highlight for both regular and tag-specific terms
        if (tagsContainer) {
          // Get the first 3 visible tags and remaining hidden tags
          const displayTags = visibleTags.slice(0, 3);
          const remainingTags = [...visibleTags.slice(3), ...hiddenTags];
          
          // Clear current tags
          tagsContainer.innerHTML = '';
          
          // Add visible tags with highlights if they match
          displayTags.forEach(tag => {
            if (!tag) return;
            const tagElement = document.createElement('span');
            tagElement.className = 'tag text-xs py-0.5 px-2 rounded-full bg-orange-50 text-orange-700 dark:bg-orange-900/30 dark:text-orange-300';
            
            // Check if tag matches any search term (regular or tag-specific)
            const matchesAnyTerm = 
              searchTerms.regular.some(term => matchesSearchTerms(tag, [term])) ||
              searchTerms.tagOnly.some(tagTerm => tag.includes(tagTerm));
            
            tagElement.innerHTML = matchesAnyTerm
              ? highlightText(tag, [...searchTerms.regular, ...searchTerms.tagOnly.map(t => `"${t}"`)])
              : decodeHtml(tag);
            tagsContainer.appendChild(tagElement);
          });
          
          // Add matching tags from remaining tags
          const matchingRemainingTags = remainingTags.filter(tag => 
            tag && (
              searchTerms.regular.some(term => matchesSearchTerms(tag, [term])) ||
              searchTerms.tagOnly.some(tagTerm => tag.includes(tagTerm))
            )
          );
          
          matchingRemainingTags.forEach(tag => {
            if (!tag) return;
            const tagElement = document.createElement('span');
            tagElement.className = 'tag text-xs py-0.5 px-2 rounded-full bg-orange-50 text-orange-700 dark:bg-orange-900/30 dark:text-orange-300 search-highlight';
            tagElement.innerHTML = highlightText(tag, [...searchTerms.regular, ...searchTerms.tagOnly.map(t => `"${t}"`)])
            tagsContainer.appendChild(tagElement);
          });
          
          // Add overflow indicator for non-matching remaining tags
          const nonMatchingCount = remainingTags.length - matchingRemainingTags.length;
          if (nonMatchingCount > 0) {
            const moreTag = document.createElement('span');
            moreTag.className = 'tag-more text-xs py-0.5 px-2 rounded-full bg-gray-100 text-gray-600 dark:bg-gray-700 dark:text-gray-400';
            moreTag.title = remainingTags.filter(tag => 
              tag && !(
                searchTerms.regular.some(term => matchesSearchTerms(tag, [term])) ||
                searchTerms.tagOnly.some(tagTerm => tag.includes(tagTerm))
              )
            ).map(tag => decodeHtml(tag || '')).join(', ');
            moreTag.textContent = `+${nonMatchingCount} weitere`;
            tagsContainer.appendChild(moreTag);
          }
        }
      } else {
        // Reset highlights and restore original content
        if (titleElement && titleElement.textContent) {
          titleElement.textContent = decodeHtml(titleElement.textContent);
        }
        if (descriptionElement && descriptionElement.textContent) {
          descriptionElement.textContent = decodeHtml(descriptionElement.textContent);
        }
        
        // Restore original tag structure from stored HTML
        if (tagsContainer && card.hasAttribute('data-original-tags')) {
          tagsContainer.innerHTML = card.getAttribute('data-original-tags') || '';
        }
      }

      card.classList.toggle('hidden', !isVisible);
      if (isVisible) visibleCount++;
    });

    // Update recipe count
    if (recipeCountElement) {
      recipeCountElement.textContent = visibleCount.toString();
    }
  }

  // Update URL when search or category changes
  function updateURL() {
    const url = new URL(window.location.href);
    
    if (searchInput.value) {
      url.searchParams.set('search', searchInput.value);
    } else {
      url.searchParams.delete('search');
    }
    
    if (categoryFilter.value) {
      url.searchParams.set('category', categoryFilter.value);
    } else {
      url.searchParams.delete('category');
    }
    
    window.history.replaceState({}, '', url);
  }

  // Debounce function to limit how often filterRecipes runs
  let searchTimeout: ReturnType<typeof setTimeout> | null = null;
  function debouncedFilter(immediate = false) {
    if (searchTimeout) {
      clearTimeout(searchTimeout);
      searchTimeout = null;
    }
    
    if (immediate) {
      // Run immediately without debounce (for restoring from URL)
      filterRecipes();
      updateURL();
    } else {
      // Normal debounced behavior
      searchTimeout = setTimeout(() => {
        filterRecipes();
        updateURL();
      }, 300); // Wait 300ms after user stops typing
    }
  }

  // Function to setup event listeners (called after DOM is ready)
  function setupEventListeners() {
    // Refresh elements first
    refreshElements();
    
    // Add event listeners with URL updates (only if elements exist)
    if (searchInput) {
      // Remove existing listener if any (prevent duplicates)
      const newInputHandler = () => {
        // Skip if we're programmatically updating the input
        if (isUpdatingInputs) return;
        debouncedFilter();
      };
      searchInput.removeEventListener('input', (searchInput as any)._inputHandler);
      (searchInput as any)._inputHandler = newInputHandler;
      searchInput.addEventListener('input', newInputHandler);
    }

    if (categoryFilter) {
      // Remove existing listener if any (prevent duplicates)
      const newChangeHandler = () => {
        // Skip if we're programmatically updating the input
        if (isUpdatingInputs) return;
        // Category changes don't need debouncing since they're discrete events
        filterRecipes();
        updateURL();
      };
      categoryFilter.removeEventListener('change', (categoryFilter as any)._changeHandler);
      (categoryFilter as any)._changeHandler = newChangeHandler;
      categoryFilter.addEventListener('change', newChangeHandler);
    }
  }

  // Function to apply initial filter based on URL parameters
  function applyInitialFilter() {
    // Prevent running if already filtering
    if (isFiltering || isReapplyingFilter) {
      return;
    }
    
    // Refresh elements to ensure they're available
    refreshElements();
    
    if (!searchInput || !categoryFilter) {
      return;
    }
    
    // Check both input values and URL parameters (URL takes precedence)
    const urlParams = new URLSearchParams(window.location.search);
    const urlSearch = urlParams.get('search') || '';
    const urlCategory = urlParams.get('category') || '';
    
    // Update input values from URL if they differ (without triggering events)
    isUpdatingInputs = true;
    try {
      if (urlSearch && searchInput.value !== urlSearch) {
        searchInput.value = urlSearch;
      }
      if (urlCategory && categoryFilter.value !== urlCategory) {
        categoryFilter.value = urlCategory;
      }
    } finally {
      isUpdatingInputs = false;
    }
    
    // Apply filter if we have search query or category (from either source)
    if (searchInput.value || categoryFilter.value || urlSearch || urlCategory) {
      filterRecipes();
    }
  }

  // Guard to prevent multiple simultaneous retry loops
  let isReapplyingFilter = false;
  let reapplyTimeout: ReturnType<typeof setTimeout> | null = null;
  
  // Disable filtering during navigation (only register once)
  if (!(window as any).searchBarNavigationGuardsAdded) {
    (window as any).searchBarNavigationGuardsAdded = true;
    
    function disableFiltering() {
      isNavigating = true;
      if (reapplyTimeout) {
        clearTimeout(reapplyTimeout);
        reapplyTimeout = null;
      }
      isReapplyingFilter = false;
    }
    
    function enableFiltering() {
      // Re-enable after a short delay to let page settle
      setTimeout(() => {
        isNavigating = false;
      }, 200); // Increased delay
    }
    
    // Handle both Astro navigation and browser navigation
    document.addEventListener('astro:before-swap', disableFiltering);
    window.addEventListener('pagehide', disableFiltering);
    window.addEventListener('beforeunload', disableFiltering);
    
    document.addEventListener('astro:after-swap', enableFiltering);
    
    // Handle Android back button and bfcache restoration
    window.addEventListener('pageshow', (event) => {
      if (event.persisted) {
        // Page was restored from back/forward cache
        // Force complete reinitialization
        isNavigating = false; // Reset navigation flag
        isReapplyingFilter = false; // Reset filter flag
        isFiltering = false; // Reset filtering flag
        
        // Clear any pending timeouts
        if (reapplyTimeout) {
          clearTimeout(reapplyTimeout);
          reapplyTimeout = null;
        }
        if (pageEventTimeout) {
          clearTimeout(pageEventTimeout);
          pageEventTimeout = null;
        }
        
        // Force refresh of all element references
        refreshElements();
        
        // Re-enable after a delay to let page fully restore
        setTimeout(() => {
          isNavigating = false;
          // Reinitialize search bar (only if on recipe list page)
          if (window.location.pathname === '/rezepte') {
            // Force complete reinitialization by resetting element references first
            searchInput = null;
            categoryFilter = null;
            recipeCards = null;
            recipeCountElement = null;
            initializeSearchBar();
          }
        }, 300); // Longer delay for Android
      }
    });
    
    // Also handle popstate (Android back button often triggers this)
    window.addEventListener('popstate', () => {
      // Reset all flags when navigating back
      isNavigating = false;
      isReapplyingFilter = false;
      isFiltering = false;
      
      if (reapplyTimeout) {
        clearTimeout(reapplyTimeout);
        reapplyTimeout = null;
      }
      if (pageEventTimeout) {
        clearTimeout(pageEventTimeout);
        pageEventTimeout = null;
      }
      
      // Force refresh and reinitialize
      setTimeout(() => {
        // Reset element references first
        searchInput = null;
        categoryFilter = null;
        recipeCards = null;
        recipeCountElement = null;
        refreshElements();
        if (window.location.pathname === '/rezepte') {
          initializeSearchBar();
        }
      }, 100);
    });
    
    // Listen for PWA-specific pageshow event from Layout.astro
    window.addEventListener('pwa-pageshow', () => {
      // Reset all state and reinitialize
      isNavigating = false;
      isReapplyingFilter = false;
      isFiltering = false;
      
      if (reapplyTimeout) {
        clearTimeout(reapplyTimeout);
        reapplyTimeout = null;
      }
      if (pageEventTimeout) {
        clearTimeout(pageEventTimeout);
        pageEventTimeout = null;
      }
      
      // Reset element references and reinitialize
      searchInput = null;
      categoryFilter = null;
      recipeCards = null;
      recipeCountElement = null;
      
      setTimeout(() => {
        if (window.location.pathname === '/rezepte') {
          initializeSearchBar();
        }
      }, 100);
    });
  }
  
  // Function to re-apply filter when returning to page
  function reapplyFilterOnReturn(retryCount = 0) {
    // Don't reapply during navigation
    if (isNavigating) {
      return;
    }
    
    // Prevent multiple simultaneous calls
    if (isReapplyingFilter && retryCount === 0) {
      return;
    }
    
    // Clear any pending timeout
    if (reapplyTimeout) {
      clearTimeout(reapplyTimeout);
      reapplyTimeout = null;
    }
    
    // Mark as reapplying
    if (retryCount === 0) {
      isReapplyingFilter = true;
    }
    
    // Refresh all element references
    refreshElements();
    
    // Check if URL parameters exist first (before checking elements)
    const urlParams = new URLSearchParams(window.location.search);
    const searchParam = urlParams.get('search') || '';
    const categoryParam = urlParams.get('category') || '';
    
    // If no search params, no need to filter
    if (!searchParam && !categoryParam) {
      isReapplyingFilter = false;
      return;
    }
    
    // If elements aren't ready yet, retry a few times (reduced from 10 to 5)
    if (!searchInput || !categoryFilter || !recipeCards || recipeCards.length === 0) {
      if (retryCount < 5) {
        reapplyTimeout = setTimeout(() => {
          reapplyFilterOnReturn(retryCount + 1);
        }, 100); // Increased delay
      } else {
        // Max retries reached, give up
        isReapplyingFilter = false;
      }
      return;
    }
    
    // Update input values to match URL (in case they're out of sync)
    // Use flag to prevent event cascades
    isUpdatingInputs = true;
    try {
      if (searchInput.value !== searchParam) {
        searchInput.value = searchParam;
      }
      if (categoryFilter.value !== categoryParam) {
        categoryFilter.value = categoryParam;
      }
    } finally {
      isUpdatingInputs = false;
    }
    
    // Re-apply filter
    filterRecipes();
    
    // Mark as done
    isReapplyingFilter = false;
  }

  // Guard to prevent multiple initializations
  let isInitializing = false;
  
  // Initialize everything when DOM is ready
  function initializeSearchBar() {
    // Prevent multiple simultaneous initializations
    if (isInitializing) {
      return;
    }
    
    isInitializing = true;
    try {
      addStyles();
      setupEventListeners();
      applyInitialFilter();
    } catch (error) {
      console.error('Error initializing search bar:', error);
    } finally {
      // Reset flag after a delay to allow reinitialization if needed
      setTimeout(() => {
        isInitializing = false;
      }, 500);
    }
  }
  
  // Apply filter on initial load (wait for DOM)
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeSearchBar);
  } else {
    // DOM already ready, but use setTimeout to avoid blocking
    setTimeout(initializeSearchBar, 0);
  }

  // Debounce function for page events to prevent multiple simultaneous calls
  let pageEventTimeout: ReturnType<typeof setTimeout> | null = null;
  let isReapplyingPage = false;
  let lastReapplyTime = 0;
  const MIN_REAPPLY_INTERVAL = 500; // Minimum 500ms between reapplies
  
  function debouncedReapply() {
    // Prevent multiple simultaneous calls
    if (isReapplyingPage) {
      return;
    }
    
    // Throttle reapplies to prevent too frequent calls
    const now = Date.now();
    if (now - lastReapplyTime < MIN_REAPPLY_INTERVAL) {
      return;
    }
    
    if (pageEventTimeout) {
      clearTimeout(pageEventTimeout);
    }
    pageEventTimeout = setTimeout(() => {
      // Only reapply if we're on the recipe list page
      if (window.location.pathname === '/rezepte') {
        isReapplyingPage = true;
        lastReapplyTime = Date.now();
        try {
          refreshElements();
          // Only call reapplyFilterOnReturn, which handles everything
          // Don't call applyInitialFilter separately to avoid double filtering
          reapplyFilterOnReturn();
        } catch (error) {
          console.error('Error in debouncedReapply:', error);
        } finally {
          isReapplyingPage = false;
          pageEventTimeout = null;
        }
      } else {
        pageEventTimeout = null;
      }
    }, 200); // Increased delay to batch multiple rapid events
  }
  
  // Guard to prevent duplicate event listeners
  if (!(window as any).searchBarListenersAdded) {
    (window as any).searchBarListenersAdded = true;
    
    // Re-apply filter when page is shown (including when restored from back/forward cache)
    // This handles the case when user navigates back to the recipe list
    // Note: This is handled separately in the navigation guards above to avoid conflicts
    
    // Also listen for Astro navigation events if using client-side routing
    document.addEventListener('astro:after-swap', () => {
      debouncedReapply();
    });
    
    // Also check on focus in case page was in background (but debounced)
    window.addEventListener('focus', () => {
      debouncedReapply();
    });
  }
  
  // Expose filter functions globally so they can be called from page level
  (window as any).reapplyRecipeFilter = reapplyFilterOnReturn;
  (window as any).filterRecipes = filterRecipes;
  (window as any).debouncedFilter = debouncedFilter;
</script> 