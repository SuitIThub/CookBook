<div class="cast-controls">
    <button id="castbutton" class="cast-button">
        <!-- Cast icon SVG -->
        <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
            <path d="M1 18v3h3c0-1.66-1.34-3-3-3zm0-4v2c2.76 0 5 2.24 5 5h2c0-3.87-3.13-7-7-7zm0-4v2c4.97 0 9 4.03 9 9h2c0-6.08-4.93-11-11-11zm20-7H3c-1.1 0-2 .9-2 2v3h2V5h18v14h-7v2h7c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"/>
        </svg>
    </button>
    <div class="navigation-controls" style="display: none;">
        <button id="prevStep" class="nav-button">
            <span class="sr-only">Previous Step</span>
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z" clip-rule="evenodd" />
            </svg>
        </button>
        <button id="nextStep" class="nav-button">
            <span class="sr-only">Next Step</span>
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd" />
            </svg>
        </button>
    </div>
</div>

<script>
interface Recipe {
    title: string;
    subtitle?: string;
    ingredientGroups: IngredientGroup[];
    preparationGroups: PreparationGroup[];
}

interface IngredientGroup {
    id: string;
    title?: string;
    ingredients: Ingredient[];
}

interface Ingredient {
    id: string;
    name: string;
    description?: string;
    quantities: Quantity[];
}

interface Quantity {
    amount: number;
    unit: string;
}

interface PreparationGroup {
    id: string;
    title?: string;
    steps: PreparationStep[];
}

interface PreparationStep {
    id: string;
    text: string;
    linkedIngredients: LinkedIngredient[];
    intermediateIngredients: IntermediateIngredient[];
}

interface LinkedIngredient {
    ingredientId: string;
    selectedQuantityIndex: number;
    isIntermediate?: boolean;
}

interface IntermediateIngredient {
    id: string;
    name: string;
    description?: string;
}

declare global {
    interface Window {
        castManager: CastManager;
        __onGCastApiAvailable: (isAvailable: boolean) => void;
    }
    namespace chrome.cast {
        const media: { DEFAULT_MEDIA_RECEIVER_APP_ID: string };
        enum AutoJoinPolicy { ORIGIN_SCOPED }
    }
    namespace cast.framework {
        class CastContext {
            static getInstance(): CastContext;
            setOptions(options: { receiverApplicationId: string; autoJoinPolicy: chrome.cast.AutoJoinPolicy }): void;
            getCurrentSession(): any;
        }
        class RemotePlayer {
            isConnected: boolean;
        }
        class RemotePlayerController {
            constructor(player: RemotePlayer);
            addEventListener(event: string, callback: () => void): void;
        }
        enum RemotePlayerEventType {
            IS_CONNECTED_CHANGED = 'isConnectedChanged'
        }
    }
}

class CastManager {
    private remotePlayer: cast.framework.RemotePlayer | null;
    private remotePlayerController: cast.framework.RemotePlayerController | null;
    private currentSession: any | null;
    private static readonly RECEIVER_APP_ID = '3D0A6542';
    private initialized: boolean = false;
    private retryCount: number = 0;
    private maxRetries: number = 3;

    constructor() {
        console.log('CastManager: Constructor called');
        this.remotePlayer = null;
        this.remotePlayerController = null;
        this.currentSession = null;
        this.initializeCastApi();
    }

    private isChromiumBased(): boolean {
        // Check for Chromium-based browsers
        return !!(window.chrome || navigator.userAgent.includes('Chrome') || 
                 navigator.userAgent.includes('Chromium') || 
                 navigator.userAgent.includes('Vivaldi'));
    }

    private async waitForCastApi(timeout: number = 1000): Promise<boolean> {
        return new Promise((resolve) => {
            const checkCastApi = () => {
                if (window.chrome && window.chrome.cast) {
                    resolve(true);
                } else if (this.retryCount < this.maxRetries) {
                    this.retryCount++;
                    setTimeout(checkCastApi, timeout);
                } else {
                    resolve(false);
                }
            };
            checkCastApi();
        });
    }

    initializeCastApi() {
        console.log('CastManager: Starting initialization');
        const castButton = document.getElementById('castbutton');
        
        if (!this.isChromiumBased()) {
            console.log('CastManager: Not a Chromium-based browser, hiding cast button');
            if (castButton) castButton.style.display = 'none';
            return;
        }

        // Keep original button visible until we confirm Cast is available
        if (castButton) {
            castButton.style.display = 'block';
            console.log('CastManager: Original button made visible');
        }

        // Add script error handler before initializing
        const loadCastSdk = async () => {
            console.log('CastManager: Loading Cast SDK');
            
            const script = document.createElement('script');
            script.src = 'https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1';
            script.async = true;
            
            const scriptPromise = new Promise((resolve, reject) => {
                script.onload = resolve;
                script.onerror = reject;
            });

            document.head.appendChild(script);
            console.log('CastManager: Cast SDK script added to head');

            try {
                await scriptPromise;
                console.log('CastManager: Cast SDK script loaded');
                const apiAvailable = await this.waitForCastApi();
                if (apiAvailable) {
                    this.initializeCastContext();
                } else {
                    console.error('CastManager: Cast API not available after retries');
                }
            } catch (error) {
                console.error('CastManager: Error loading Cast SDK:', error);
            }
        };

        // Initialize Cast API once the DOM is ready
        if (document.readyState === 'loading') {
            console.log('CastManager: Document still loading, waiting for DOMContentLoaded');
            document.addEventListener('DOMContentLoaded', () => loadCastSdk());
        } else {
            console.log('CastManager: Document already loaded, initializing immediately');
            loadCastSdk();
        }
        
        window['__onGCastApiAvailable'] = (isAvailable: boolean) => {
            console.log('CastManager: Cast API availability callback, isAvailable:', isAvailable);
            if (isAvailable && !this.initialized) {
                this.initializeCastContext();
            }
        };
    }

    private initializeCastContext() {
        try {
            console.log('CastManager: Initializing Cast SDK');
            const context = cast.framework.CastContext.getInstance();
            context.setOptions({
                receiverApplicationId: CastManager.RECEIVER_APP_ID,
                autoJoinPolicy: chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED
            });
            console.log('CastManager: Cast context options set');

            const castButton = document.getElementById('castbutton');
            const castButtonElement = document.createElement('google-cast-launcher');
            castButtonElement.id = 'castbutton';
            castButtonElement.style.display = 'block';
            
            if (castButton && castButton.parentNode) {
                console.log('CastManager: Replacing original button with Cast button');
                castButton.parentNode.replaceChild(castButtonElement, castButton);
            } else {
                console.error('CastManager: Could not find original button or its parent');
            }

            this.remotePlayer = new cast.framework.RemotePlayer();
            this.remotePlayerController = new cast.framework.RemotePlayerController(this.remotePlayer);
            console.log('CastManager: Remote player initialized');
            
            this.remotePlayerController.addEventListener(
                cast.framework.RemotePlayerEventType.IS_CONNECTED_CHANGED,
                () => {
                    const navControls = document.querySelector('.navigation-controls') as HTMLElement;
                    if (this.remotePlayer && this.remotePlayer.isConnected) {
                        if (navControls) navControls.style.display = 'flex';
                        this.currentSession = cast.framework.CastContext.getInstance().getCurrentSession();
                        console.log('CastManager: Connected to Cast device');
                    } else {
                        if (navControls) navControls.style.display = 'none';
                        this.currentSession = null;
                        console.log('CastManager: Disconnected from Cast device');
                    }
                }
            );

            document.getElementById('prevStep')?.addEventListener('click', () => this.sendControl('previous'));
            document.getElementById('nextStep')?.addEventListener('click', () => this.sendControl('next'));

            this.initialized = true;
            console.log('CastManager: Cast SDK initialized successfully');
        } catch (error) {
            console.error('CastManager: Error initializing Cast SDK:', error);
            const castButton = document.getElementById('castbutton');
            if (castButton) {
                castButton.style.display = 'block';
                console.log('CastManager: Keeping original button visible due to error');
            }
        }
    }

    // Send control command to receiver
    async sendControl(action: 'previous' | 'next') {
        if (this.currentSession) {
            try {
                await this.currentSession.sendMessage('urn:x-cast:com.cookbook.recipes', {
                    type: 'control',
                    action: action
                });
            } catch (error) {
                console.error('Error sending control command:', error);
            }
        }
    }

    // Cast a recipe to the Cast device
    async castRecipe(recipe: Recipe) {
        const castSession = cast.framework.CastContext.getInstance().getCurrentSession();
        if (!castSession) {
            console.log('No cast session available');
            return;
        }

        try {
            await castSession.sendMessage('urn:x-cast:com.cookbook.recipes', {
                type: 'recipe',
                recipe: recipe
            });
            console.log('Recipe cast successfully');
        } catch (error) {
            console.error('Error casting recipe:', error);
        }
    }
}

// Initialize the Cast Manager
window.castManager = new CastManager();
</script>

<style>
.cast-controls {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    z-index: 100;
    position: relative;
}

.cast-button {
    width: 24px;
    height: 24px;
    padding: 0;
    border: none;
    background: none;
    color: #666666;
    cursor: pointer;
    transition: color 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    z-index: 101;
}

.cast-button:hover {
    color: #f97316;
}

google-cast-launcher {
    --connected-color: #f97316 !important;
    --disconnected-color: #666666 !important;
    cursor: pointer !important;
    width: 24px !important;
    height: 24px !important;
    padding: 0 !important;
    display: inline-block !important;
    opacity: 1 !important;
    visibility: visible !important;
    position: relative !important;
    z-index: 102 !important;
    min-width: 24px !important;
    min-height: 24px !important;
    border: none !important;
    outline: none !important;
    background: transparent !important;
}

.navigation-controls {
    display: none;
    gap: 0.5rem;
    margin-left: 0.5rem;
}

.nav-button {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 2rem;
    height: 2rem;
    padding: 0.5rem;
    border: none;
    border-radius: 0.375rem;
    background-color: #f97316;
    color: white;
    cursor: pointer;
    transition: all 0.2s;
}

.nav-button:hover {
    background-color: #ea580c;
}

.nav-button:disabled {
    background-color: #d1d5db;
    cursor: not-allowed;
}

.sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border-width: 0;
}
</style> 