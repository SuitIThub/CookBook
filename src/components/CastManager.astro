<div class="cast-controls">
    <div id="cast-button-container" class="cast-button-wrapper">
        <!-- Cast button will be inserted here -->
    </div>
    <div class="navigation-controls" style="display: none;">
        <button id="prevStep" class="nav-button">
            <span class="sr-only">Previous Step</span>
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z" clip-rule="evenodd" />
            </svg>
        </button>
        <button id="nextStep" class="nav-button">
            <span class="sr-only">Next Step</span>
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd" />
            </svg>
        </button>
    </div>
</div>

<script>
console.log('CastManager Script Starting...');

// Interfaces
interface Recipe {
    title: string;
    subtitle?: string;
    ingredientGroups: IngredientGroup[];
    preparationGroups: PreparationGroup[];
}

interface IngredientGroup {
    id: string;
    title?: string;
    ingredients: Ingredient[];
}

interface Ingredient {
    id: string;
    name: string;
    description?: string;
    quantities: Quantity[];
}

interface Quantity {
    amount: number;
    unit: string;
}

interface PreparationGroup {
    id: string;
    title?: string;
    steps: PreparationStep[];
}

interface PreparationStep {
    id: string;
    text: string;
    linkedIngredients: LinkedIngredient[];
    intermediateIngredients: IntermediateIngredient[];
}

interface LinkedIngredient {
    ingredientId: string;
    selectedQuantityIndex: number;
    isIntermediate?: boolean;
}

interface IntermediateIngredient {
    id: string;
    name: string;
    description?: string;
}

// Global type declarations
declare global {
    interface Window {
        castManager: CastManager;
        __onGCastApiAvailable: (isAvailable: boolean) => void;
    }
    namespace chrome.cast {
        const media: { DEFAULT_MEDIA_RECEIVER_APP_ID: string };
        enum AutoJoinPolicy { ORIGIN_SCOPED }
    }
    namespace cast.framework {
        class CastContext {
            static getInstance(): CastContext;
            setOptions(options: { receiverApplicationId: string; autoJoinPolicy: chrome.cast.AutoJoinPolicy }): void;
            getCurrentSession(): any;
        }
        class RemotePlayer {
            isConnected: boolean;
        }
        class RemotePlayerController {
            constructor(player: RemotePlayer);
            addEventListener(event: string, callback: () => void): void;
        }
        enum RemotePlayerEventType {
            IS_CONNECTED_CHANGED = 'isConnectedChanged'
        }
    }
}

// Immediately load Cast SDK
console.log('Loading Cast SDK script...');
const script = document.createElement('script');
script.src = 'https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1';
script.async = true;
document.head.appendChild(script);
console.log('Cast SDK script added to document head');

class CastManager {
    private remotePlayer: cast.framework.RemotePlayer | null;
    private remotePlayerController: cast.framework.RemotePlayerController | null;
    private currentSession: any | null;
    private static readonly RECEIVER_APP_ID = '3D0A6542';
    private initialized: boolean = false;

    constructor() {
        console.log('CastManager: Constructor called');
        this.remotePlayer = null;
        this.remotePlayerController = null;
        this.currentSession = null;
        
        // Set up the callback before anything else
        window['__onGCastApiAvailable'] = (isAvailable: boolean) => {
            console.log('CastManager: Cast API availability callback, isAvailable:', isAvailable);
            if (isAvailable && !this.initialized) {
                this.initializeCastContext();
            }
        };

        // Check if API is already available
        if (window.chrome && window.chrome.cast) {
            console.log('CastManager: Cast API already available, initializing...');
            this.initializeCastContext();
        } else {
            console.log('CastManager: Waiting for Cast API to become available...');
        }
    }

    private initializeCastContext() {
        try {
            console.log('CastManager: Initializing Cast context');
            const context = cast.framework.CastContext.getInstance();
            context.setOptions({
                receiverApplicationId: CastManager.RECEIVER_APP_ID,
                autoJoinPolicy: chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED
            });
            console.log('CastManager: Cast context options set');

            // Create the Cast button in its container
            const container = document.getElementById('cast-button-container');
            if (container) {
                console.log('CastManager: Found button container');
                const castButtonElement = document.createElement('google-cast-launcher');
                castButtonElement.id = 'castbutton';
                container.innerHTML = ''; // Clear any existing content
                container.appendChild(castButtonElement);
                console.log('CastManager: Cast button added to container');
            } else {
                console.error('CastManager: Could not find button container');
            }

            this.remotePlayer = new cast.framework.RemotePlayer();
            this.remotePlayerController = new cast.framework.RemotePlayerController(this.remotePlayer);
            
            this.remotePlayerController.addEventListener(
                cast.framework.RemotePlayerEventType.IS_CONNECTED_CHANGED,
                () => {
                    const navControls = document.querySelector('.navigation-controls') as HTMLElement;
                    if (this.remotePlayer && this.remotePlayer.isConnected) {
                        if (navControls) navControls.style.display = 'flex';
                        this.currentSession = cast.framework.CastContext.getInstance().getCurrentSession();
                        console.log('CastManager: Connected to Cast device');
                    } else {
                        if (navControls) navControls.style.display = 'none';
                        this.currentSession = null;
                        console.log('CastManager: Disconnected from Cast device');
                    }
                }
            );

            document.getElementById('prevStep')?.addEventListener('click', () => this.sendControl('previous'));
            document.getElementById('nextStep')?.addEventListener('click', () => this.sendControl('next'));

            this.initialized = true;
            console.log('CastManager: Cast SDK initialized successfully');
        } catch (error) {
            console.error('CastManager: Error initializing Cast SDK:', error);
        }
    }

    async sendControl(action: 'previous' | 'next') {
        if (this.currentSession) {
            try {
                await this.currentSession.sendMessage('urn:x-cast:com.cookbook.recipes', {
                    type: 'control',
                    action: action
                });
            } catch (error) {
                console.error('Error sending control command:', error);
            }
        }
    }

    async castRecipe(recipe: Recipe) {
        const castSession = cast.framework.CastContext.getInstance().getCurrentSession();
        if (!castSession) {
            console.log('No cast session available');
            return;
        }

        try {
            await castSession.sendMessage('urn:x-cast:com.cookbook.recipes', {
                type: 'recipe',
                recipe: recipe
            });
            console.log('Recipe cast successfully');
        } catch (error) {
            console.error('Error casting recipe:', error);
        }
    }
}

// Initialize the Cast Manager
console.log('Creating CastManager instance...');
window.castManager = new CastManager();
console.log('CastManager instance created');
</script>

<style>
.cast-controls {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    z-index: 100;
    position: relative;
}

.cast-button-wrapper {
    width: 24px;
    height: 24px;
    position: relative;
    z-index: 101;
}

google-cast-launcher {
    --connected-color: #f97316 !important;
    --disconnected-color: #666666 !important;
    cursor: pointer !important;
    width: 24px !important;
    height: 24px !important;
    padding: 0 !important;
    display: inline-block !important;
    opacity: 1 !important;
    visibility: visible !important;
    position: relative !important;
    z-index: 102 !important;
    min-width: 24px !important;
    min-height: 24px !important;
    border: none !important;
    outline: none !important;
    background: transparent !important;
    pointer-events: auto !important;
}

.navigation-controls {
    display: none;
    gap: 0.5rem;
    margin-left: 0.5rem;
}

.nav-button {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 2rem;
    height: 2rem;
    padding: 0.5rem;
    border: none;
    border-radius: 0.375rem;
    background-color: #f97316;
    color: white;
    cursor: pointer;
    transition: all 0.2s;
}

.nav-button:hover {
    background-color: #ea580c;
}

.nav-button:disabled {
    background-color: #d1d5db;
    cursor: not-allowed;
}

.sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border-width: 0;
}
</style> 