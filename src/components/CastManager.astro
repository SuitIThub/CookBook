<div class="cast-controls">
    <button id="castbutton" class="cast-button">
        <!-- Cast icon SVG -->
        <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
            <path d="M1 18v3h3c0-1.66-1.34-3-3-3zm0-4v2c2.76 0 5 2.24 5 5h2c0-3.87-3.13-7-7-7zm0-4v2c4.97 0 9 4.03 9 9h2c0-6.08-4.93-11-11-11zm20-7H3c-1.1 0-2 .9-2 2v3h2V5h18v14h-7v2h7c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"/>
        </svg>
    </button>
    <div class="navigation-controls" style="display: none;">
        <button id="prevStep" class="nav-button">
            <span class="sr-only">Previous Step</span>
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z" clip-rule="evenodd" />
            </svg>
        </button>
        <button id="nextStep" class="nav-button">
            <span class="sr-only">Next Step</span>
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd" />
            </svg>
        </button>
    </div>
</div>

<script>
interface Recipe {
    title: string;
    subtitle?: string;
    ingredientGroups: IngredientGroup[];
    preparationGroups: PreparationGroup[];
}

interface IngredientGroup {
    id: string;
    title?: string;
    ingredients: Ingredient[];
}

interface Ingredient {
    id: string;
    name: string;
    description?: string;
    quantities: Quantity[];
}

interface Quantity {
    amount: number;
    unit: string;
}

interface PreparationGroup {
    id: string;
    title?: string;
    steps: PreparationStep[];
}

interface PreparationStep {
    id: string;
    text: string;
    linkedIngredients: LinkedIngredient[];
    intermediateIngredients: IntermediateIngredient[];
}

interface LinkedIngredient {
    ingredientId: string;
    selectedQuantityIndex: number;
    isIntermediate?: boolean;
}

interface IntermediateIngredient {
    id: string;
    name: string;
    description?: string;
}

declare global {
    interface Window {
        castManager: CastManager;
        __onGCastApiAvailable: (isAvailable: boolean) => void;
    }
    namespace chrome.cast {
        const media: { DEFAULT_MEDIA_RECEIVER_APP_ID: string };
        enum AutoJoinPolicy { ORIGIN_SCOPED }
    }
    namespace cast.framework {
        class CastContext {
            static getInstance(): CastContext;
            setOptions(options: { receiverApplicationId: string; autoJoinPolicy: chrome.cast.AutoJoinPolicy }): void;
            getCurrentSession(): any;
        }
        class RemotePlayer {
            isConnected: boolean;
        }
        class RemotePlayerController {
            constructor(player: RemotePlayer);
            addEventListener(event: string, callback: () => void): void;
        }
        enum RemotePlayerEventType {
            IS_CONNECTED_CHANGED = 'isConnectedChanged'
        }
    }
}

class CastManager {
    private remotePlayer: cast.framework.RemotePlayer | null;
    private remotePlayerController: cast.framework.RemotePlayerController | null;
    private currentSession: any | null;
    private static readonly RECEIVER_APP_ID = '3D0A6542'; // Default custom receiver ID

    constructor() {
        this.initializeCastApi();
        this.remotePlayer = null;
        this.remotePlayerController = null;
        this.currentSession = null;
    }

    initializeCastApi() {
        const castButton = document.getElementById('castbutton');
        
        window['__onGCastApiAvailable'] = (isAvailable: boolean) => {
            if (isAvailable) {
                // Initialize Cast SDK with custom receiver
                cast.framework.CastContext.getInstance().setOptions({
                    receiverApplicationId: CastManager.RECEIVER_APP_ID,
                    autoJoinPolicy: chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED
                });

                // Replace placeholder with actual Cast button
                const castButtonElement = document.createElement('google-cast-launcher');
                castButtonElement.id = 'castbutton';
                if (castButton && castButton.parentNode) {
                    castButton.parentNode.replaceChild(castButtonElement, castButton);
                }

                this.remotePlayer = new cast.framework.RemotePlayer();
                this.remotePlayerController = new cast.framework.RemotePlayerController(this.remotePlayer);
                
                // Listen for connection changes
                this.remotePlayerController.addEventListener(
                    cast.framework.RemotePlayerEventType.IS_CONNECTED_CHANGED,
                    () => {
                        const navControls = document.querySelector('.navigation-controls') as HTMLElement;
                        if (this.remotePlayer && this.remotePlayer.isConnected) {
                            if (navControls) navControls.style.display = 'flex';
                            this.currentSession = cast.framework.CastContext.getInstance().getCurrentSession();
                        } else {
                            if (navControls) navControls.style.display = 'none';
                            this.currentSession = null;
                            console.log('Disconnected from Cast device');
                        }
                    }
                );

                // Add navigation controls event listeners
                document.getElementById('prevStep')?.addEventListener('click', () => this.sendControl('previous'));
                document.getElementById('nextStep')?.addEventListener('click', () => this.sendControl('next'));
            } else {
                console.error('Cast API not available');
                if (castButton) castButton.style.display = 'none';
            }
        };
    }

    // Send control command to receiver
    async sendControl(action: 'previous' | 'next') {
        if (this.currentSession) {
            try {
                await this.currentSession.sendMessage('urn:x-cast:com.cookbook.recipes', {
                    type: 'control',
                    action: action
                });
            } catch (error) {
                console.error('Error sending control command:', error);
            }
        }
    }

    // Cast a recipe to the Cast device
    async castRecipe(recipe: Recipe) {
        const castSession = cast.framework.CastContext.getInstance().getCurrentSession();
        if (!castSession) {
            console.log('No cast session available');
            return;
        }

        try {
            await castSession.sendMessage('urn:x-cast:com.cookbook.recipes', {
                type: 'recipe',
                recipe: recipe
            });
            console.log('Recipe cast successfully');
        } catch (error) {
            console.error('Error casting recipe:', error);
        }
    }
}

// Initialize the Cast Manager
window.castManager = new CastManager();
</script>

<style>
.cast-controls {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.cast-button {
    width: 24px;
    height: 24px;
    padding: 0;
    border: none;
    background: none;
    color: #666666;
    cursor: pointer;
    transition: color 0.2s;
}

.cast-button:hover {
    color: #f97316;
}

google-cast-launcher {
    --connected-color: #f97316;
    --disconnected-color: #666666;
    cursor: pointer;
    width: 24px;
    height: 24px;
    padding: 0;
}

.navigation-controls {
    display: none;
    gap: 0.5rem;
    margin-left: 0.5rem;
}

.nav-button {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 2rem;
    height: 2rem;
    padding: 0.5rem;
    border: none;
    border-radius: 0.375rem;
    background-color: #f97316;
    color: white;
    cursor: pointer;
    transition: all 0.2s;
}

.nav-button:hover {
    background-color: #ea580c;
}

.nav-button:disabled {
    background-color: #d1d5db;
    cursor: not-allowed;
}

.sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border-width: 0;
}
</style> 